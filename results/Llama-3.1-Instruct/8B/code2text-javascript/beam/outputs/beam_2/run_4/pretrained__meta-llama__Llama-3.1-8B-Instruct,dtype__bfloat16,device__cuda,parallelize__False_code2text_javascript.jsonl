[
  {
    "doc_id": 0,
    "doc": {
      "id": 0,
      "repo": "axios/axios",
      "path": "lib/axios.js",
      "func_name": "createInstance",
      "original_string": "function createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}",
      "language": "javascript",
      "code": "function createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}",
      "code_tokens": [
        "function",
        "createInstance",
        "(",
        "defaultConfig",
        ")",
        "{",
        "var",
        "context",
        "=",
        "new",
        "Axios",
        "(",
        "defaultConfig",
        ")",
        ";",
        "var",
        "instance",
        "=",
        "bind",
        "(",
        "Axios",
        ".",
        "prototype",
        ".",
        "request",
        ",",
        "context",
        ")",
        ";",
        "// Copy axios.prototype to instance",
        "utils",
        ".",
        "extend",
        "(",
        "instance",
        ",",
        "Axios",
        ".",
        "prototype",
        ",",
        "context",
        ")",
        ";",
        "// Copy context to instance",
        "utils",
        ".",
        "extend",
        "(",
        "instance",
        ",",
        "context",
        ")",
        ";",
        "return",
        "instance",
        ";",
        "}"
      ],
      "docstring": "Create an instance of Axios\n\n@param {Object} defaultConfig The default config for the instance\n@return {Axios} A new instance of Axios",
      "docstring_tokens": [
        "Create",
        "an",
        "instance",
        "of",
        "Axios"
      ],
      "sha": "92d231387fe2092f8736bc1746d4caa766b675f5",
      "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/axios.js#L15-L26"
    },
    "target": "Create an instance of Axios",
    "arguments": [
      [
        "function createInstance ( defaultConfig ) { var context = new Axios ( defaultConfig ) ; var instance = bind ( Axios . prototype . request , context ) ; // Copy axios.prototype to instance utils . extend ( instance , Axios . prototype , context ) ; // Copy context to instance utils . extend ( instance , context ) ; return instance ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function bind ( fn, context ) { return function ( /* args */ ) { return fn. apply ( context, arguments ) ; } ; } function utils ( ) { return { extend : function ( target, source, overwrite ) { for ( var key in source ) { if ( overwrite ||! target. hasOwnProperty ( key ) ) { target [ key ] = source [ key ] ; } } return target ; } } ; } function Axios ( config ) { this. defaults = config ; this. interceptors = { request : { pre : [ ], post : [ ] }, response : { pre : [ ], post : [ ] } } ; } Axios. prototype. request = function ( url, config ) { //... } Axios. prototype. interceptors = { request : { pre : [ ], post : [ ] }, response : { pre : [ ], post : [ ] } } ; Axios. prototype. request = function ( url, config ) { //... } Axios. prototype. interceptors = { request : { pre : [ ], post : [ ] }, response : { pre : [ ], post : [ ] } } ; Axios. prototype. request = function ("
      ]
    ],
    "filtered_resps": [
      " function bind ( fn, context ) { return function ( /* args */ ) { return fn. apply ( context, arguments ) ; } ; } function utils ( ) { return { extend : function ( target, source, overwrite ) { for ( var key in source ) { if ( overwrite ||! target. hasOwnProperty ( key ) ) { target [ key ] = source [ key ] ; } } return target ; } } ; } function Axios ( config ) { this. defaults = config ; this. interceptors = { request : { pre : [ ], post : [ ] }, response : { pre : [ ], post : [ ] } } ; } Axios. prototype. request = function ( url, config ) { //... } Axios. prototype. interceptors = { request : { pre : [ ], post : [ ] }, response : { pre : [ ], post : [ ] } } ; Axios. prototype. request = function ( url, config ) { //... } Axios. prototype. interceptors = { request : { pre : [ ], post : [ ] }, response : { pre : [ ], post : [ ] } } ; Axios. prototype. request = function ("
    ],
    "smoothed_bleu_4": 0.3933157614265924
  },
  {
    "doc_id": 1,
    "doc": {
      "id": 1,
      "repo": "axios/axios",
      "path": "lib/cancel/CancelToken.js",
      "func_name": "CancelToken",
      "original_string": "function CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}",
      "language": "javascript",
      "code": "function CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}",
      "code_tokens": [
        "function",
        "CancelToken",
        "(",
        "executor",
        ")",
        "{",
        "if",
        "(",
        "typeof",
        "executor",
        "!==",
        "'function'",
        ")",
        "{",
        "throw",
        "new",
        "TypeError",
        "(",
        "'executor must be a function.'",
        ")",
        ";",
        "}",
        "var",
        "resolvePromise",
        ";",
        "this",
        ".",
        "promise",
        "=",
        "new",
        "Promise",
        "(",
        "function",
        "promiseExecutor",
        "(",
        "resolve",
        ")",
        "{",
        "resolvePromise",
        "=",
        "resolve",
        ";",
        "}",
        ")",
        ";",
        "var",
        "token",
        "=",
        "this",
        ";",
        "executor",
        "(",
        "function",
        "cancel",
        "(",
        "message",
        ")",
        "{",
        "if",
        "(",
        "token",
        ".",
        "reason",
        ")",
        "{",
        "// Cancellation has already been requested",
        "return",
        ";",
        "}",
        "token",
        ".",
        "reason",
        "=",
        "new",
        "Cancel",
        "(",
        "message",
        ")",
        ";",
        "resolvePromise",
        "(",
        "token",
        ".",
        "reason",
        ")",
        ";",
        "}",
        ")",
        ";",
        "}"
      ],
      "docstring": "A `CancelToken` is an object that can be used to request cancellation of an operation.\n\n@class\n@param {Function} executor The executor function.",
      "docstring_tokens": [
        "A",
        "CancelToken",
        "is",
        "an",
        "object",
        "that",
        "can",
        "be",
        "used",
        "to",
        "request",
        "cancellation",
        "of",
        "an",
        "operation",
        "."
      ],
      "sha": "92d231387fe2092f8736bc1746d4caa766b675f5",
      "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/cancel/CancelToken.js#L11-L31"
    },
    "target": "A CancelToken is an object that can be used to request cancellation of an operation .",
    "arguments": [
      [
        "function CancelToken ( executor ) { if ( typeof executor !== 'function' ) { throw new TypeError ( 'executor must be a function.' ) ; } var resolvePromise ; this . promise = new Promise ( function promiseExecutor ( resolve ) { resolvePromise = resolve ; } ) ; var token = this ; executor ( function cancel ( message ) { if ( token . reason ) { // Cancellation has already been requested return ; } token . reason = new Cancel ( message ) ; resolvePromise ( token . reason ) ; } ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " CancelToken.prototype.throwIfRequested = function throwIfRequested ( reason ) { if ( reason && reason. __CANCEL__ ) { throw reason ; } } ; CancelToken.source = function source ( executor ) { if ( typeof executor!== 'function' ) { throw new TypeError ( 'executor must be a function.' ) ) ; } var cancelToken = new CancelToken ( executor ) ; return cancelToken. promise ; } ; return CancelToken ; } ( ) ) ( this ) ; ``` This code defines a `CancelToken` class that represents a token that can be used to cancel a promise. The `CancelToken` class has two methods: `throwIfRequested` and `source`. The `throwIfRequested` method throws an error if a cancellation has been requested. The `source` method creates a new `CancelToken` instance and returns its promise. The `CancelToken` class also has a constructor that takes an `executor` function as an argument. The `executor` function is called with a `cancel` function as an argument, which can be used to cancel the promise. The `cancel` function sets the `reason` property of the `CancelToken` instance to a new `Cancel` instance, which is"
      ]
    ],
    "filtered_resps": [
      " CancelToken.prototype.throwIfRequested = function throwIfRequested ( reason ) { if ( reason && reason. __CANCEL__ ) { throw reason ; } } ; CancelToken.source = function source ( executor ) { if ( typeof executor!== 'function' ) { throw new TypeError ( 'executor must be a function.' ) ) ; } var cancelToken = new CancelToken ( executor ) ; return cancelToken. promise ; } ; return CancelToken ; } ( ) ) ( this ) ; ``` This code defines a `CancelToken` class that represents a token that can be used to cancel a promise. The `CancelToken` class has two methods: `throwIfRequested` and `source`. The `throwIfRequested` method throws an error if a cancellation has been requested. The `source` method creates a new `CancelToken` instance and returns its promise. The `CancelToken` class also has a constructor that takes an `executor` function as an argument. The `executor` function is called with a `cancel` function as an argument, which can be used to cancel the promise. The `cancel` function sets the `reason` property of the `CancelToken` instance to a new `Cancel` instance, which is"
    ],
    "smoothed_bleu_4": 2.181536138472842
  },
  {
    "doc_id": 2,
    "doc": {
      "id": 2,
      "repo": "axios/axios",
      "path": "lib/utils.js",
      "func_name": "isArrayBufferView",
      "original_string": "function isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}",
      "language": "javascript",
      "code": "function isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}",
      "code_tokens": [
        "function",
        "isArrayBufferView",
        "(",
        "val",
        ")",
        "{",
        "var",
        "result",
        ";",
        "if",
        "(",
        "(",
        "typeof",
        "ArrayBuffer",
        "!==",
        "'undefined'",
        ")",
        "&&",
        "(",
        "ArrayBuffer",
        ".",
        "isView",
        ")",
        ")",
        "{",
        "result",
        "=",
        "ArrayBuffer",
        ".",
        "isView",
        "(",
        "val",
        ")",
        ";",
        "}",
        "else",
        "{",
        "result",
        "=",
        "(",
        "val",
        ")",
        "&&",
        "(",
        "val",
        ".",
        "buffer",
        ")",
        "&&",
        "(",
        "val",
        ".",
        "buffer",
        "instanceof",
        "ArrayBuffer",
        ")",
        ";",
        "}",
        "return",
        "result",
        ";",
        "}"
      ],
      "docstring": "Determine if a value is a view on an ArrayBuffer\n\n@param {Object} val The value to test\n@returns {boolean} True if value is a view on an ArrayBuffer, otherwise false",
      "docstring_tokens": [
        "Determine",
        "if",
        "a",
        "value",
        "is",
        "a",
        "view",
        "on",
        "an",
        "ArrayBuffer"
      ],
      "sha": "92d231387fe2092f8736bc1746d4caa766b675f5",
      "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L48-L56"
    },
    "target": "Determine if a value is a view on an ArrayBuffer",
    "arguments": [
      [
        "function isArrayBufferView ( val ) { var result ; if ( ( typeof ArrayBuffer !== 'undefined' ) && ( ArrayBuffer . isView ) ) { result = ArrayBuffer . isView ( val ) ; } else { result = ( val ) && ( val . buffer ) && ( val . buffer instanceof ArrayBuffer ) ; } return result ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function isTypedArray ( val ) { var result ; if ( ( typeof ArrayBuffer!== 'undefined' ) && ( ArrayBuffer. isView ) ) { result = ArrayBuffer. isView ( val ) ; } else { result = ( val ) && ( val. buffer ) && ( val. buffer instanceof ArrayBuffer ) && ( val instanceof Int8Array || val instanceof Uint8Array || val instanceof Uint8ClampedArray || val instanceof Int16Array || val instanceof Uint16Array || val instanceof Int32Array || val instanceof Uint32Array || val instanceof Float32Array || val instanceof Float64Array ) ; } return result ; } function isDataView ( val ) { var result ; if ( ( typeof ArrayBuffer!== 'undefined' ) && ( ArrayBuffer. isView ) ) { result = ArrayBuffer. isView ( val ) ; } else { result = ( val ) && ( val. buffer ) && ( val. buffer instanceof ArrayBuffer ) && ( val. byteLength ) && ( val. byteLength > 0 ) && ( val. getUint8 ) && ( val. setUint8 ) && ( val. getUint16 ) && ( val. setUint16 ) && ( val. getUint32 ) && ( val. set"
      ]
    ],
    "filtered_resps": [
      " function isTypedArray ( val ) { var result ; if ( ( typeof ArrayBuffer!== 'undefined' ) && ( ArrayBuffer. isView ) ) { result = ArrayBuffer. isView ( val ) ; } else { result = ( val ) && ( val. buffer ) && ( val. buffer instanceof ArrayBuffer ) && ( val instanceof Int8Array || val instanceof Uint8Array || val instanceof Uint8ClampedArray || val instanceof Int16Array || val instanceof Uint16Array || val instanceof Int32Array || val instanceof Uint32Array || val instanceof Float32Array || val instanceof Float64Array ) ; } return result ; } function isDataView ( val ) { var result ; if ( ( typeof ArrayBuffer!== 'undefined' ) && ( ArrayBuffer. isView ) ) { result = ArrayBuffer. isView ( val ) ; } else { result = ( val ) && ( val. buffer ) && ( val. buffer instanceof ArrayBuffer ) && ( val. byteLength ) && ( val. byteLength > 0 ) && ( val. getUint8 ) && ( val. setUint8 ) && ( val. getUint16 ) && ( val. setUint16 ) && ( val. getUint32 ) && ( val. set"
    ],
    "smoothed_bleu_4": 0.5055109501389962
  },
  {
    "doc_id": 3,
    "doc": {
      "id": 3,
      "repo": "axios/axios",
      "path": "lib/utils.js",
      "func_name": "isStandardBrowserEnv",
      "original_string": "function isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}",
      "language": "javascript",
      "code": "function isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}",
      "code_tokens": [
        "function",
        "isStandardBrowserEnv",
        "(",
        ")",
        "{",
        "if",
        "(",
        "typeof",
        "navigator",
        "!==",
        "'undefined'",
        "&&",
        "(",
        "navigator",
        ".",
        "product",
        "===",
        "'ReactNative'",
        "||",
        "navigator",
        ".",
        "product",
        "===",
        "'NativeScript'",
        "||",
        "navigator",
        ".",
        "product",
        "===",
        "'NS'",
        ")",
        ")",
        "{",
        "return",
        "false",
        ";",
        "}",
        "return",
        "(",
        "typeof",
        "window",
        "!==",
        "'undefined'",
        "&&",
        "typeof",
        "document",
        "!==",
        "'undefined'",
        ")",
        ";",
        "}"
      ],
      "docstring": "Determine if we're running in a standard browser environment\n\nThis allows axios to run in a web worker, and react-native.\nBoth environments support XMLHttpRequest, but not fully standard globals.\n\nweb workers:\ntypeof window -> undefined\ntypeof document -> undefined\n\nreact-native:\nnavigator.product -> 'ReactNative'\nnativescript\nnavigator.product -> 'NativeScript' or 'NS'",
      "docstring_tokens": [
        "Determine",
        "if",
        "we",
        "re",
        "running",
        "in",
        "a",
        "standard",
        "browser",
        "environment"
      ],
      "sha": "92d231387fe2092f8736bc1746d4caa766b675f5",
      "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L183-L193"
    },
    "target": "Determine if we re running in a standard browser environment",
    "arguments": [
      [
        "function isStandardBrowserEnv ( ) { if ( typeof navigator !== 'undefined' && ( navigator . product === 'ReactNative' || navigator . product === 'NativeScript' || navigator . product === 'NS' ) ) { return false ; } return ( typeof window !== 'undefined' && typeof document !== 'undefined' ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " module. exports = isStandardBrowserEnv ; });\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n[FILEPATH] src/utils/env.js [/FILEPATH]\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandard"
      ]
    ],
    "filtered_resps": [
      " module. exports = isStandardBrowserEnv ; });\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n[FILEPATH] src/utils/env.js [/FILEPATH]\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandardBrowserEnv ( ) ; } ;\n\n@@ -0,0 +1 @@\n+ module. exports = function ( ) { return isStandard"
    ],
    "smoothed_bleu_4": 5.06257364339918e-78
  },
  {
    "doc_id": 4,
    "doc": {
      "id": 4,
      "repo": "axios/axios",
      "path": "lib/utils.js",
      "func_name": "forEach",
      "original_string": "function forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}",
      "language": "javascript",
      "code": "function forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}",
      "code_tokens": [
        "function",
        "forEach",
        "(",
        "obj",
        ",",
        "fn",
        ")",
        "{",
        "// Don't bother if no value provided",
        "if",
        "(",
        "obj",
        "===",
        "null",
        "||",
        "typeof",
        "obj",
        "===",
        "'undefined'",
        ")",
        "{",
        "return",
        ";",
        "}",
        "// Force an array if not already something iterable",
        "if",
        "(",
        "typeof",
        "obj",
        "!==",
        "'object'",
        ")",
        "{",
        "/*eslint no-param-reassign:0*/",
        "obj",
        "=",
        "[",
        "obj",
        "]",
        ";",
        "}",
        "if",
        "(",
        "isArray",
        "(",
        "obj",
        ")",
        ")",
        "{",
        "// Iterate over array values",
        "for",
        "(",
        "var",
        "i",
        "=",
        "0",
        ",",
        "l",
        "=",
        "obj",
        ".",
        "length",
        ";",
        "i",
        "<",
        "l",
        ";",
        "i",
        "++",
        ")",
        "{",
        "fn",
        ".",
        "call",
        "(",
        "null",
        ",",
        "obj",
        "[",
        "i",
        "]",
        ",",
        "i",
        ",",
        "obj",
        ")",
        ";",
        "}",
        "}",
        "else",
        "{",
        "// Iterate over object keys",
        "for",
        "(",
        "var",
        "key",
        "in",
        "obj",
        ")",
        "{",
        "if",
        "(",
        "Object",
        ".",
        "prototype",
        ".",
        "hasOwnProperty",
        ".",
        "call",
        "(",
        "obj",
        ",",
        "key",
        ")",
        ")",
        "{",
        "fn",
        ".",
        "call",
        "(",
        "null",
        ",",
        "obj",
        "[",
        "key",
        "]",
        ",",
        "key",
        ",",
        "obj",
        ")",
        ";",
        "}",
        "}",
        "}",
        "}"
      ],
      "docstring": "Iterate over an Array or an Object invoking a function for each item.\n\nIf `obj` is an Array callback will be called passing\nthe value, index, and complete array for each item.\n\nIf 'obj' is an Object callback will be called passing\nthe value, key, and complete object for each property.\n\n@param {Object|Array} obj The object to iterate\n@param {Function} fn The callback to invoke for each item",
      "docstring_tokens": [
        "Iterate",
        "over",
        "an",
        "Array",
        "or",
        "an",
        "Object",
        "invoking",
        "a",
        "function",
        "for",
        "each",
        "item",
        "."
      ],
      "sha": "92d231387fe2092f8736bc1746d4caa766b675f5",
      "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L207-L232"
    },
    "target": "Iterate over an Array or an Object invoking a function for each item .",
    "arguments": [
      [
        "function forEach ( obj , fn ) { // Don't bother if no value provided if ( obj === null || typeof obj === 'undefined' ) { return ; } // Force an array if not already something iterable if ( typeof obj !== 'object' ) { /*eslint no-param-reassign:0*/ obj = [ obj ] ; } if ( isArray ( obj ) ) { // Iterate over array values for ( var i = 0 , l = obj . length ; i < l ; i ++ ) { fn . call ( null , obj [ i ] , i , obj ) ; } } else { // Iterate over object keys for ( var key in obj ) { if ( Object . prototype . hasOwnProperty . call ( obj , key ) ) { fn . call ( null , obj [ key ] , key , obj ) ; } } } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ; // Define a function that returns the first value which is truthy. function some ( obj, fn ) { for ( var i = 0, l = obj. length || 0 ; i < l ; i ++ ) { if ( fn. call ( null, obj [ i ], i, obj ) ) { return obj [ i ] ; } } for ( var key in obj ) { if ( Object. prototype. hasOwnProperty. call ( obj, key ) && fn. call ( null, obj [ key ], key, obj ) ) { return obj [ key ] ; } } return false ; } ; // Define a function that returns the last value which is truthy. function last ( obj, fn ) { for ( var i = obj. length - 1 ; i >= 0 ; i -- ) { if ( fn. call ( null, obj [ i ], i, obj ) ) { return obj [ i ] ; } } for ( var key in obj ) { if ( Object. prototype. hasOwnProperty. call ( obj, key ) && fn. call ( null, obj [ key ], key, obj ) ) { return obj [ key ] ; } } return false"
      ]
    ],
    "filtered_resps": [
      " ; // Define a function that returns the first value which is truthy. function some ( obj, fn ) { for ( var i = 0, l = obj. length || 0 ; i < l ; i ++ ) { if ( fn. call ( null, obj [ i ], i, obj ) ) { return obj [ i ] ; } } for ( var key in obj ) { if ( Object. prototype. hasOwnProperty. call ( obj, key ) && fn. call ( null, obj [ key ], key, obj ) ) { return obj [ key ] ; } } return false ; } ; // Define a function that returns the last value which is truthy. function last ( obj, fn ) { for ( var i = obj. length - 1 ; i >= 0 ; i -- ) { if ( fn. call ( null, obj [ i ], i, obj ) ) { return obj [ i ] ; } } for ( var key in obj ) { if ( Object. prototype. hasOwnProperty. call ( obj, key ) && fn. call ( null, obj [ key ], key, obj ) ) { return obj [ key ] ; } } return false"
    ],
    "smoothed_bleu_4": 0.71345607237973
  },
  {
    "doc_id": 5,
    "doc": {
      "id": 5,
      "repo": "axios/axios",
      "path": "lib/utils.js",
      "func_name": "extend",
      "original_string": "function extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}",
      "language": "javascript",
      "code": "function extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}",
      "code_tokens": [
        "function",
        "extend",
        "(",
        "a",
        ",",
        "b",
        ",",
        "thisArg",
        ")",
        "{",
        "forEach",
        "(",
        "b",
        ",",
        "function",
        "assignValue",
        "(",
        "val",
        ",",
        "key",
        ")",
        "{",
        "if",
        "(",
        "thisArg",
        "&&",
        "typeof",
        "val",
        "===",
        "'function'",
        ")",
        "{",
        "a",
        "[",
        "key",
        "]",
        "=",
        "bind",
        "(",
        "val",
        ",",
        "thisArg",
        ")",
        ";",
        "}",
        "else",
        "{",
        "a",
        "[",
        "key",
        "]",
        "=",
        "val",
        ";",
        "}",
        "}",
        ")",
        ";",
        "return",
        "a",
        ";",
        "}"
      ],
      "docstring": "Extends object a by mutably adding to it the properties of object b.\n\n@param {Object} a The object to be extended\n@param {Object} b The object to copy properties from\n@param {Object} thisArg The object to bind function to\n@return {Object} The resulting value of object a",
      "docstring_tokens": [
        "Extends",
        "object",
        "a",
        "by",
        "mutably",
        "adding",
        "to",
        "it",
        "the",
        "properties",
        "of",
        "object",
        "b",
        "."
      ],
      "sha": "92d231387fe2092f8736bc1746d4caa766b675f5",
      "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L301-L310"
    },
    "target": "Extends object a by mutably adding to it the properties of object b .",
    "arguments": [
      [
        "function extend ( a , b , thisArg ) { forEach ( b , function assignValue ( val , key ) { if ( thisArg && typeof val === 'function' ) { a [ key ] = bind ( val , thisArg ) ; } else { a [ key ] = val ; } } ) ; return a ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function bind ( fn, thisArg ) { return function boundFn ( /* args */ ) { var tmp = fn. apply ( thisArg, arguments ) ; if ( tmp === undefined ) { return this ; } else { return tmp ; } } ; } function curry ( fn, arity, thisArg ) { arity = arity || fn. length ; var boundFn = bind ( fn, thisArg ) ; return function ( /* args */ ) { if ( arguments. length >= arity ) { return boundFn. apply ( this, arguments ) ; } else { return curry ( boundFn, arity - arguments. length, this, arguments ) ; } } ; } function curryRight ( fn, arity, thisArg ) { arity = arity || fn. length ; var boundFn = bind ( fn, thisArg ) ; return function ( /* args */ ) { if ( arguments. length >= arity ) { return boundFn. apply ( this, arguments ) ; } else { return curryRight ( boundFn, arity - arguments. length, this, arguments ) ; } } ; } function partial ( fn, thisArg, var_args ) { var args = slice ( arguments, 1 ) ; return function ( /* args */ )"
      ]
    ],
    "filtered_resps": [
      " function bind ( fn, thisArg ) { return function boundFn ( /* args */ ) { var tmp = fn. apply ( thisArg, arguments ) ; if ( tmp === undefined ) { return this ; } else { return tmp ; } } ; } function curry ( fn, arity, thisArg ) { arity = arity || fn. length ; var boundFn = bind ( fn, thisArg ) ; return function ( /* args */ ) { if ( arguments. length >= arity ) { return boundFn. apply ( this, arguments ) ; } else { return curry ( boundFn, arity - arguments. length, this, arguments ) ; } } ; } function curryRight ( fn, arity, thisArg ) { arity = arity || fn. length ; var boundFn = bind ( fn, thisArg ) ; return function ( /* args */ ) { if ( arguments. length >= arity ) { return boundFn. apply ( this, arguments ) ; } else { return curryRight ( boundFn, arity - arguments. length, this, arguments ) ; } } ; } function partial ( fn, thisArg, var_args ) { var args = slice ( arguments, 1 ) ; return function ( /* args */ )"
    ],
    "smoothed_bleu_4": 0.4044512150843639
  },
  {
    "doc_id": 6,
    "doc": {
      "id": 6,
      "repo": "zeit/next.js",
      "path": "packages/next/taskfile-ncc.js",
      "func_name": "writePackageManifest",
      "original_string": "function writePackageManifest (packageName) {\n  const packagePath = require.resolve(packageName + '/package.json')\n  let { name, main, author, license, types, typings } = require(packagePath)\n  if (!main) {\n    main = 'index.js'\n  }\n\n  let typesFile = types || typings\n  if (typesFile) {\n    typesFile = require.resolve(join(packageName, typesFile))\n  }\n\n  const compiledPackagePath = join(__dirname, `dist/compiled/${packageName}`)\n\n  const potentialLicensePath = join(dirname(packagePath), './LICENSE')\n  if (existsSync(potentialLicensePath)) {\n    this._.files.push({\n      dir: compiledPackagePath,\n      base: 'LICENSE',\n      data: readFileSync(potentialLicensePath, 'utf8')\n    })\n  }\n\n  this._.files.push({\n    dir: compiledPackagePath,\n    base: 'package.json',\n    data:\n      JSON.stringify(\n        Object.assign(\n          {},\n          { name, main: `${basename(main, '.' + extname(main))}` },\n          author ? { author } : undefined,\n          license ? { license } : undefined,\n          typesFile\n            ? {\n              types: relative(compiledPackagePath, typesFile)\n            }\n            : undefined\n        )\n      ) + '\\n'\n  })\n}",
      "language": "javascript",
      "code": "function writePackageManifest (packageName) {\n  const packagePath = require.resolve(packageName + '/package.json')\n  let { name, main, author, license, types, typings } = require(packagePath)\n  if (!main) {\n    main = 'index.js'\n  }\n\n  let typesFile = types || typings\n  if (typesFile) {\n    typesFile = require.resolve(join(packageName, typesFile))\n  }\n\n  const compiledPackagePath = join(__dirname, `dist/compiled/${packageName}`)\n\n  const potentialLicensePath = join(dirname(packagePath), './LICENSE')\n  if (existsSync(potentialLicensePath)) {\n    this._.files.push({\n      dir: compiledPackagePath,\n      base: 'LICENSE',\n      data: readFileSync(potentialLicensePath, 'utf8')\n    })\n  }\n\n  this._.files.push({\n    dir: compiledPackagePath,\n    base: 'package.json',\n    data:\n      JSON.stringify(\n        Object.assign(\n          {},\n          { name, main: `${basename(main, '.' + extname(main))}` },\n          author ? { author } : undefined,\n          license ? { license } : undefined,\n          typesFile\n            ? {\n              types: relative(compiledPackagePath, typesFile)\n            }\n            : undefined\n        )\n      ) + '\\n'\n  })\n}",
      "code_tokens": [
        "function",
        "writePackageManifest",
        "(",
        "packageName",
        ")",
        "{",
        "const",
        "packagePath",
        "=",
        "require",
        ".",
        "resolve",
        "(",
        "packageName",
        "+",
        "'/package.json'",
        ")",
        "let",
        "{",
        "name",
        ",",
        "main",
        ",",
        "author",
        ",",
        "license",
        ",",
        "types",
        ",",
        "typings",
        "}",
        "=",
        "require",
        "(",
        "packagePath",
        ")",
        "if",
        "(",
        "!",
        "main",
        ")",
        "{",
        "main",
        "=",
        "'index.js'",
        "}",
        "let",
        "typesFile",
        "=",
        "types",
        "||",
        "typings",
        "if",
        "(",
        "typesFile",
        ")",
        "{",
        "typesFile",
        "=",
        "require",
        ".",
        "resolve",
        "(",
        "join",
        "(",
        "packageName",
        ",",
        "typesFile",
        ")",
        ")",
        "}",
        "const",
        "compiledPackagePath",
        "=",
        "join",
        "(",
        "__dirname",
        ",",
        "`",
        "${",
        "packageName",
        "}",
        "`",
        ")",
        "const",
        "potentialLicensePath",
        "=",
        "join",
        "(",
        "dirname",
        "(",
        "packagePath",
        ")",
        ",",
        "'./LICENSE'",
        ")",
        "if",
        "(",
        "existsSync",
        "(",
        "potentialLicensePath",
        ")",
        ")",
        "{",
        "this",
        ".",
        "_",
        ".",
        "files",
        ".",
        "push",
        "(",
        "{",
        "dir",
        ":",
        "compiledPackagePath",
        ",",
        "base",
        ":",
        "'LICENSE'",
        ",",
        "data",
        ":",
        "readFileSync",
        "(",
        "potentialLicensePath",
        ",",
        "'utf8'",
        ")",
        "}",
        ")",
        "}",
        "this",
        ".",
        "_",
        ".",
        "files",
        ".",
        "push",
        "(",
        "{",
        "dir",
        ":",
        "compiledPackagePath",
        ",",
        "base",
        ":",
        "'package.json'",
        ",",
        "data",
        ":",
        "JSON",
        ".",
        "stringify",
        "(",
        "Object",
        ".",
        "assign",
        "(",
        "{",
        "}",
        ",",
        "{",
        "name",
        ",",
        "main",
        ":",
        "`",
        "${",
        "basename",
        "(",
        "main",
        ",",
        "'.'",
        "+",
        "extname",
        "(",
        "main",
        ")",
        ")",
        "}",
        "`",
        "}",
        ",",
        "author",
        "?",
        "{",
        "author",
        "}",
        ":",
        "undefined",
        ",",
        "license",
        "?",
        "{",
        "license",
        "}",
        ":",
        "undefined",
        ",",
        "typesFile",
        "?",
        "{",
        "types",
        ":",
        "relative",
        "(",
        "compiledPackagePath",
        ",",
        "typesFile",
        ")",
        "}",
        ":",
        "undefined",
        ")",
        ")",
        "+",
        "'\\n'",
        "}",
        ")",
        "}"
      ],
      "docstring": "This function writes a minimal `package.json` file for a compiled package. It defines `name`, `main`, `author`, and `license`. It also defines `types`. n.b. types intended for development usage only.",
      "docstring_tokens": [
        "This",
        "function",
        "writes",
        "a",
        "minimal",
        "package",
        ".",
        "json",
        "file",
        "for",
        "a",
        "compiled",
        "package",
        ".",
        "It",
        "defines",
        "name",
        "main",
        "author",
        "and",
        "license",
        ".",
        "It",
        "also",
        "defines",
        "types",
        ".",
        "n",
        ".",
        "b",
        ".",
        "types",
        "intended",
        "for",
        "development",
        "usage",
        "only",
        "."
      ],
      "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd",
      "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/taskfile-ncc.js#L34-L75"
    },
    "target": "This function writes a minimal package . json file for a compiled package . It defines name main author and license . It also defines types . n . b . types intended for development usage only .",
    "arguments": [
      [
        "function writePackageManifest ( packageName ) { const packagePath = require . resolve ( packageName + '/package.json' ) let { name , main , author , license , types , typings } = require ( packagePath ) if ( ! main ) { main = 'index.js' } let typesFile = types || typings if ( typesFile ) { typesFile = require . resolve ( join ( packageName , typesFile ) ) } const compiledPackagePath = join ( __dirname , ` ${ packageName } ` ) const potentialLicensePath = join ( dirname ( packagePath ) , './LICENSE' ) if ( existsSync ( potentialLicensePath ) ) { this . _ . files . push ( { dir : compiledPackagePath , base : 'LICENSE' , data : readFileSync ( potentialLicensePath , 'utf8' ) } ) } this . _ . files . push ( { dir : compiledPackagePath , base : 'package.json' , data : JSON . stringify ( Object . assign ( { } , { name , main : ` ${ basename ( main , '.' + extname ( main ) ) } ` } , author ? { author } : undefined , license ? { license } : undefined , typesFile ? { types : relative ( compiledPackagePath , typesFile ) } : undefined ) ) + '\\n' } ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " writePackageManifest. __proto__. constructor = writePackageManifest } module. exports = writePackageManifest ; ``` This code defines a function `writePackageManifest` that takes a package name as an argument. It resolves the path to the package's `package.json` file, extracts relevant information from it, and writes a new `package.json` file to the compiled package directory. The new `package.json` file includes the package name, main file, author, license, and types information. If a `LICENSE` file exists in the package directory, it is also copied to the compiled package directory. The function uses the `require` function to read the `package.json` file and the `readFileSync` function to read the `LICENSE` file. The `join` function is used to construct paths, and the `basename` and `extname` functions are used to extract the file name and extension from the main file path. The `relative` function is used to construct the types file path relative to the compiled package directory. The `existsSync` function is used to check if the `LICENSE` file exists. The `Object.assign` function is used to merge the package information with default values. The `JSON.stringify`"
      ]
    ],
    "filtered_resps": [
      " writePackageManifest. __proto__. constructor = writePackageManifest } module. exports = writePackageManifest ; ``` This code defines a function `writePackageManifest` that takes a package name as an argument. It resolves the path to the package's `package.json` file, extracts relevant information from it, and writes a new `package.json` file to the compiled package directory. The new `package.json` file includes the package name, main file, author, license, and types information. If a `LICENSE` file exists in the package directory, it is also copied to the compiled package directory. The function uses the `require` function to read the `package.json` file and the `readFileSync` function to read the `LICENSE` file. The `join` function is used to construct paths, and the `basename` and `extname` functions are used to extract the file name and extension from the main file path. The `relative` function is used to construct the types file path relative to the compiled package directory. The `existsSync` function is used to check if the `LICENSE` file exists. The `Object.assign` function is used to merge the package information with default values. The `JSON.stringify`"
    ],
    "smoothed_bleu_4": 1.7852077166761113
  },
  {
    "doc_id": 7,
    "doc": {
      "id": 7,
      "repo": "zeit/next.js",
      "path": "packages/next/client/dev-error-overlay/hot-dev-client.js",
      "func_name": "processMessage",
      "original_string": "function processMessage (e) {\n  const obj = JSON.parse(e.data)\n  switch (obj.action) {\n    case 'building': {\n      console.log(\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\n        'rebuilding'\n      )\n      break\n    }\n    case 'built':\n    case 'sync': {\n      clearOutdatedErrors()\n\n      if (obj.hash) {\n        handleAvailableHash(obj.hash)\n      }\n\n      if (obj.warnings.length > 0) {\n        handleWarnings(obj.warnings)\n      }\n\n      if (obj.errors.length > 0) {\n        // When there is a compilation error coming from SSR we have to reload the page on next successful compile\n        if (obj.action === 'sync') {\n          hadRuntimeError = true\n        }\n        handleErrors(obj.errors)\n        break\n      }\n\n      handleSuccess()\n      break\n    }\n    default: {\n      if (customHmrEventHandler) {\n        customHmrEventHandler(obj)\n        break\n      }\n      break\n    }\n  }\n}",
      "language": "javascript",
      "code": "function processMessage (e) {\n  const obj = JSON.parse(e.data)\n  switch (obj.action) {\n    case 'building': {\n      console.log(\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\n        'rebuilding'\n      )\n      break\n    }\n    case 'built':\n    case 'sync': {\n      clearOutdatedErrors()\n\n      if (obj.hash) {\n        handleAvailableHash(obj.hash)\n      }\n\n      if (obj.warnings.length > 0) {\n        handleWarnings(obj.warnings)\n      }\n\n      if (obj.errors.length > 0) {\n        // When there is a compilation error coming from SSR we have to reload the page on next successful compile\n        if (obj.action === 'sync') {\n          hadRuntimeError = true\n        }\n        handleErrors(obj.errors)\n        break\n      }\n\n      handleSuccess()\n      break\n    }\n    default: {\n      if (customHmrEventHandler) {\n        customHmrEventHandler(obj)\n        break\n      }\n      break\n    }\n  }\n}",
      "code_tokens": [
        "function",
        "processMessage",
        "(",
        "e",
        ")",
        "{",
        "const",
        "obj",
        "=",
        "JSON",
        ".",
        "parse",
        "(",
        "e",
        ".",
        "data",
        ")",
        "switch",
        "(",
        "obj",
        ".",
        "action",
        ")",
        "{",
        "case",
        "'building'",
        ":",
        "{",
        "console",
        ".",
        "log",
        "(",
        "'[HMR] bundle '",
        "+",
        "(",
        "obj",
        ".",
        "name",
        "?",
        "\"'\"",
        "+",
        "obj",
        ".",
        "name",
        "+",
        "\"' \"",
        ":",
        "''",
        ")",
        "+",
        "'rebuilding'",
        ")",
        "break",
        "}",
        "case",
        "'built'",
        ":",
        "case",
        "'sync'",
        ":",
        "{",
        "clearOutdatedErrors",
        "(",
        ")",
        "if",
        "(",
        "obj",
        ".",
        "hash",
        ")",
        "{",
        "handleAvailableHash",
        "(",
        "obj",
        ".",
        "hash",
        ")",
        "}",
        "if",
        "(",
        "obj",
        ".",
        "warnings",
        ".",
        "length",
        ">",
        "0",
        ")",
        "{",
        "handleWarnings",
        "(",
        "obj",
        ".",
        "warnings",
        ")",
        "}",
        "if",
        "(",
        "obj",
        ".",
        "errors",
        ".",
        "length",
        ">",
        "0",
        ")",
        "{",
        "// When there is a compilation error coming from SSR we have to reload the page on next successful compile",
        "if",
        "(",
        "obj",
        ".",
        "action",
        "===",
        "'sync'",
        ")",
        "{",
        "hadRuntimeError",
        "=",
        "true",
        "}",
        "handleErrors",
        "(",
        "obj",
        ".",
        "errors",
        ")",
        "break",
        "}",
        "handleSuccess",
        "(",
        ")",
        "break",
        "}",
        "default",
        ":",
        "{",
        "if",
        "(",
        "customHmrEventHandler",
        ")",
        "{",
        "customHmrEventHandler",
        "(",
        "obj",
        ")",
        "break",
        "}",
        "break",
        "}",
        "}",
        "}"
      ],
      "docstring": "Handle messages from the server.",
      "docstring_tokens": [
        "Handle",
        "messages",
        "from",
        "the",
        "server",
        "."
      ],
      "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd",
      "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/hot-dev-client.js#L202-L244"
    },
    "target": "Handle messages from the server .",
    "arguments": [
      [
        "function processMessage ( e ) { const obj = JSON . parse ( e . data ) switch ( obj . action ) { case 'building' : { console . log ( '[HMR] bundle ' + ( obj . name ? \"'\" + obj . name + \"' \" : '' ) + 'rebuilding' ) break } case 'built' : case 'sync' : { clearOutdatedErrors ( ) if ( obj . hash ) { handleAvailableHash ( obj . hash ) } if ( obj . warnings . length > 0 ) { handleWarnings ( obj . warnings ) } if ( obj . errors . length > 0 ) { // When there is a compilation error coming from SSR we have to reload the page on next successful compile if ( obj . action === 'sync' ) { hadRuntimeError = true } handleErrors ( obj . errors ) break } handleSuccess ( ) break } default : { if ( customHmrEventHandler ) { customHmrEventHandler ( obj ) break } break } } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function handleAvailableHash ( hash ) { if ( hash === currentHash ) { return } currentHash = hash if ( hash!== previousHash ) { previousHash = hash } } function handleWarnings ( warnings ) { if ( warnings. length === 0 ) { return } console. log ( '[HMR] Warnings:' ) warnings. forEach ( ( warning ) => { console. log ( warning. message ) } ) } function handleErrors ( errors ) { if ( errors. length === 0 ) { return } console. log ( '[HMR] Errors:' ) errors. forEach ( ( error ) => { console. log ( error. message ) } ) } function handleSuccess ( ) { console. log ( '[HMR] Hot Module Replacement applied' ) } function clearOutdatedErrors ( ) { if ( hadRuntimeError ) { return } if ( errors. length === 0 ) { return } console. log ( '[HMR] Clearing outdated errors' ) errors. splice ( 0, errors. length ) } function handleErrors ( errors ) { if ( errors. length === 0 ) { return } console. log ( '[HMR] Errors:' ) errors. forEach ( ( error )"
      ]
    ],
    "filtered_resps": [
      " function handleAvailableHash ( hash ) { if ( hash === currentHash ) { return } currentHash = hash if ( hash!== previousHash ) { previousHash = hash } } function handleWarnings ( warnings ) { if ( warnings. length === 0 ) { return } console. log ( '[HMR] Warnings:' ) warnings. forEach ( ( warning ) => { console. log ( warning. message ) } ) } function handleErrors ( errors ) { if ( errors. length === 0 ) { return } console. log ( '[HMR] Errors:' ) errors. forEach ( ( error ) => { console. log ( error. message ) } ) } function handleSuccess ( ) { console. log ( '[HMR] Hot Module Replacement applied' ) } function clearOutdatedErrors ( ) { if ( hadRuntimeError ) { return } if ( errors. length === 0 ) { return } console. log ( '[HMR] Clearing outdated errors' ) errors. splice ( 0, errors. length ) } function handleErrors ( errors ) { if ( errors. length === 0 ) { return } console. log ( '[HMR] Errors:' ) errors. forEach ( ( error )"
    ],
    "smoothed_bleu_4": 0.4094189430946688
  },
  {
    "doc_id": 8,
    "doc": {
      "id": 8,
      "repo": "zeit/next.js",
      "path": "packages/next/client/dev-error-overlay/hot-dev-client.js",
      "func_name": "tryApplyUpdates",
      "original_string": "async function tryApplyUpdates (onHotUpdateSuccess) {\n  if (!module.hot) {\n    // HotModuleReplacementPlugin is not in Webpack configuration.\n    console.error('HotModuleReplacementPlugin is not in Webpack configuration.')\n    // window.location.reload();\n    return\n  }\n\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n\n  function handleApplyUpdates (err, updatedModules) {\n    if (err || hadRuntimeError) {\n      if (err) {\n        console.warn('Error while applying updates, reloading page', err)\n      }\n      if (hadRuntimeError) {\n        console.warn('Had runtime error previously, reloading page')\n      }\n      window.location.reload()\n      return\n    }\n\n    if (typeof onHotUpdateSuccess === 'function') {\n      // Maybe we want to do something.\n      onHotUpdateSuccess()\n    }\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdates()\n    }\n  }\n\n  // https://webpack.github.io/docs/hot-module-replacement.html#check\n  try {\n    const updatedModules = await module.hot.check(/* autoApply */ {\n      ignoreUnaccepted: true\n    })\n    if (updatedModules) {\n      handleApplyUpdates(null, updatedModules)\n    }\n  } catch (err) {\n    handleApplyUpdates(err, null)\n  }\n}",
      "language": "javascript",
      "code": "async function tryApplyUpdates (onHotUpdateSuccess) {\n  if (!module.hot) {\n    // HotModuleReplacementPlugin is not in Webpack configuration.\n    console.error('HotModuleReplacementPlugin is not in Webpack configuration.')\n    // window.location.reload();\n    return\n  }\n\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n\n  function handleApplyUpdates (err, updatedModules) {\n    if (err || hadRuntimeError) {\n      if (err) {\n        console.warn('Error while applying updates, reloading page', err)\n      }\n      if (hadRuntimeError) {\n        console.warn('Had runtime error previously, reloading page')\n      }\n      window.location.reload()\n      return\n    }\n\n    if (typeof onHotUpdateSuccess === 'function') {\n      // Maybe we want to do something.\n      onHotUpdateSuccess()\n    }\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdates()\n    }\n  }\n\n  // https://webpack.github.io/docs/hot-module-replacement.html#check\n  try {\n    const updatedModules = await module.hot.check(/* autoApply */ {\n      ignoreUnaccepted: true\n    })\n    if (updatedModules) {\n      handleApplyUpdates(null, updatedModules)\n    }\n  } catch (err) {\n    handleApplyUpdates(err, null)\n  }\n}",
      "code_tokens": [
        "async",
        "function",
        "tryApplyUpdates",
        "(",
        "onHotUpdateSuccess",
        ")",
        "{",
        "if",
        "(",
        "!",
        "module",
        ".",
        "hot",
        ")",
        "{",
        "// HotModuleReplacementPlugin is not in Webpack configuration.",
        "console",
        ".",
        "error",
        "(",
        "'HotModuleReplacementPlugin is not in Webpack configuration.'",
        ")",
        "// window.location.reload();",
        "return",
        "}",
        "if",
        "(",
        "!",
        "isUpdateAvailable",
        "(",
        ")",
        "||",
        "!",
        "canApplyUpdates",
        "(",
        ")",
        ")",
        "{",
        "return",
        "}",
        "function",
        "handleApplyUpdates",
        "(",
        "err",
        ",",
        "updatedModules",
        ")",
        "{",
        "if",
        "(",
        "err",
        "||",
        "hadRuntimeError",
        ")",
        "{",
        "if",
        "(",
        "err",
        ")",
        "{",
        "console",
        ".",
        "warn",
        "(",
        "'Error while applying updates, reloading page'",
        ",",
        "err",
        ")",
        "}",
        "if",
        "(",
        "hadRuntimeError",
        ")",
        "{",
        "console",
        ".",
        "warn",
        "(",
        "'Had runtime error previously, reloading page'",
        ")",
        "}",
        "window",
        ".",
        "location",
        ".",
        "reload",
        "(",
        ")",
        "return",
        "}",
        "if",
        "(",
        "typeof",
        "onHotUpdateSuccess",
        "===",
        "'function'",
        ")",
        "{",
        "// Maybe we want to do something.",
        "onHotUpdateSuccess",
        "(",
        ")",
        "}",
        "if",
        "(",
        "isUpdateAvailable",
        "(",
        ")",
        ")",
        "{",
        "// While we were updating, there was a new update! Do it again.",
        "tryApplyUpdates",
        "(",
        ")",
        "}",
        "}",
        "// https://webpack.github.io/docs/hot-module-replacement.html#check",
        "try",
        "{",
        "const",
        "updatedModules",
        "=",
        "await",
        "module",
        ".",
        "hot",
        ".",
        "check",
        "(",
        "/* autoApply */",
        "{",
        "ignoreUnaccepted",
        ":",
        "true",
        "}",
        ")",
        "if",
        "(",
        "updatedModules",
        ")",
        "{",
        "handleApplyUpdates",
        "(",
        "null",
        ",",
        "updatedModules",
        ")",
        "}",
        "}",
        "catch",
        "(",
        "err",
        ")",
        "{",
        "handleApplyUpdates",
        "(",
        "err",
        ",",
        "null",
        ")",
        "}",
        "}"
      ],
      "docstring": "Attempt to update code on the fly, fall back to a hard reload.",
      "docstring_tokens": [
        "Attempt",
        "to",
        "update",
        "code",
        "on",
        "the",
        "fly",
        "fall",
        "back",
        "to",
        "a",
        "hard",
        "reload",
        "."
      ],
      "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd",
      "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/hot-dev-client.js#L260-L306"
    },
    "target": "Attempt to update code on the fly fall back to a hard reload .",
    "arguments": [
      [
        "async function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { // HotModuleReplacementPlugin is not in Webpack configuration. console . error ( 'HotModuleReplacementPlugin is not in Webpack configuration.' ) // window.location.reload(); return } if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } function handleApplyUpdates ( err , updatedModules ) { if ( err || hadRuntimeError ) { if ( err ) { console . warn ( 'Error while applying updates, reloading page' , err ) } if ( hadRuntimeError ) { console . warn ( 'Had runtime error previously, reloading page' ) } window . location . reload ( ) return } if ( typeof onHotUpdateSuccess === 'function' ) { // Maybe we want to do something. onHotUpdateSuccess ( ) } if ( isUpdateAvailable ( ) ) { // While we were updating, there was a new update! Do it again. tryApplyUpdates ( ) } } // https://webpack.github.io/docs/hot-module-replacement.html#check try { const updatedModules = await module . hot . check ( /* autoApply */ { ignoreUnaccepted : true } ) if ( updatedModules ) { handleApplyUpdates ( null , updatedModules ) } } catch ( err ) { handleApplyUpdates ( err , null ) } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default tryApplyUpdates\n```\nThis code defines a function called `tryApplyUpdates` which is responsible for checking if there are any updates available for the application, and if so, applying them. It uses the `module.hot` API provided by Webpack to check for updates and apply them.\n\nHere's a breakdown of the code:\n\n1. The function first checks if the `HotModuleReplacementPlugin` is enabled in the Webpack configuration. If it's not, it logs an error message and returns.\n2. It then checks if there are any updates available using the `isUpdateAvailable` function (not shown in this code snippet). If there are no updates available, it returns.\n3. It then checks if the updates can be applied using the `canApplyUpdates` function (not shown in this code snippet). If the updates cannot be applied, it returns.\n4. If the updates can be applied, it defines a function called `handleApplyUpdates` which will be called after the updates have been applied.\n5. The `handleApplyUpdates` function checks if there was an error while applying the updates, or if a runtime error occurred previously. If either of these conditions is true, it reloads the page.\n"
      ]
    ],
    "filtered_resps": [
      " export default tryApplyUpdates\n```\nThis code defines a function called `tryApplyUpdates` which is responsible for checking if there are any updates available for the application, and if so, applying them. It uses the `module.hot` API provided by Webpack to check for updates and apply them.\n\nHere's a breakdown of the code:\n\n1. The function first checks if the `HotModuleReplacementPlugin` is enabled in the Webpack configuration. If it's not, it logs an error message and returns.\n2. It then checks if there are any updates available using the `isUpdateAvailable` function (not shown in this code snippet). If there are no updates available, it returns.\n3. It then checks if the updates can be applied using the `canApplyUpdates` function (not shown in this code snippet). If the updates cannot be applied, it returns.\n4. If the updates can be applied, it defines a function called `handleApplyUpdates` which will be called after the updates have been applied.\n5. The `handleApplyUpdates` function checks if there was an error while applying the updates, or if a runtime error occurred previously. If either of these conditions is true, it reloads the page.\n"
    ],
    "smoothed_bleu_4": 0.6329557678691783
  },
  {
    "doc_id": 9,
    "doc": {
      "id": 9,
      "repo": "zeit/next.js",
      "path": "packages/next/client/amp-dev.js",
      "func_name": "tryApplyUpdates",
      "original_string": "async function tryApplyUpdates () {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n  try {\n    const res = await fetch(`${hotUpdatePath}${curHash}.hot-update.json`)\n    const data = await res.json()\n    const curPage = page === '/' ? 'index' : page\n    const pageUpdated = Object.keys(data.c)\n      .some(mod => {\n        return (\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`) !== -1 ||\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`.replace(/\\//g, '\\\\')) !== -1\n        )\n      })\n\n    if (pageUpdated) {\n      document.location.reload(true)\n    } else {\n      curHash = mostRecentHash\n    }\n  } catch (err) {\n    console.error('Error occurred checking for update', err)\n    document.location.reload(true)\n  }\n}",
      "language": "javascript",
      "code": "async function tryApplyUpdates () {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n  try {\n    const res = await fetch(`${hotUpdatePath}${curHash}.hot-update.json`)\n    const data = await res.json()\n    const curPage = page === '/' ? 'index' : page\n    const pageUpdated = Object.keys(data.c)\n      .some(mod => {\n        return (\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`) !== -1 ||\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`.replace(/\\//g, '\\\\')) !== -1\n        )\n      })\n\n    if (pageUpdated) {\n      document.location.reload(true)\n    } else {\n      curHash = mostRecentHash\n    }\n  } catch (err) {\n    console.error('Error occurred checking for update', err)\n    document.location.reload(true)\n  }\n}",
      "code_tokens": [
        "async",
        "function",
        "tryApplyUpdates",
        "(",
        ")",
        "{",
        "if",
        "(",
        "!",
        "isUpdateAvailable",
        "(",
        ")",
        "||",
        "!",
        "canApplyUpdates",
        "(",
        ")",
        ")",
        "{",
        "return",
        "}",
        "try",
        "{",
        "const",
        "res",
        "=",
        "await",
        "fetch",
        "(",
        "`",
        "${",
        "hotUpdatePath",
        "}",
        "${",
        "curHash",
        "}",
        "`",
        ")",
        "const",
        "data",
        "=",
        "await",
        "res",
        ".",
        "json",
        "(",
        ")",
        "const",
        "curPage",
        "=",
        "page",
        "===",
        "'/'",
        "?",
        "'index'",
        ":",
        "page",
        "const",
        "pageUpdated",
        "=",
        "Object",
        ".",
        "keys",
        "(",
        "data",
        ".",
        "c",
        ")",
        ".",
        "some",
        "(",
        "mod",
        "=>",
        "{",
        "return",
        "(",
        "mod",
        ".",
        "indexOf",
        "(",
        "`",
        "${",
        "curPage",
        ".",
        "substr",
        "(",
        "0",
        ",",
        "1",
        ")",
        "===",
        "'/'",
        "?",
        "curPage",
        ":",
        "`",
        "${",
        "curPage",
        "}",
        "`",
        "}",
        "`",
        ")",
        "!==",
        "-",
        "1",
        "||",
        "mod",
        ".",
        "indexOf",
        "(",
        "`",
        "${",
        "curPage",
        ".",
        "substr",
        "(",
        "0",
        ",",
        "1",
        ")",
        "===",
        "'/'",
        "?",
        "curPage",
        ":",
        "`",
        "${",
        "curPage",
        "}",
        "`",
        "}",
        "`",
        ".",
        "replace",
        "(",
        "/",
        "\\/",
        "/",
        "g",
        ",",
        "'\\\\'",
        ")",
        ")",
        "!==",
        "-",
        "1",
        ")",
        "}",
        ")",
        "if",
        "(",
        "pageUpdated",
        ")",
        "{",
        "document",
        ".",
        "location",
        ".",
        "reload",
        "(",
        "true",
        ")",
        "}",
        "else",
        "{",
        "curHash",
        "=",
        "mostRecentHash",
        "}",
        "}",
        "catch",
        "(",
        "err",
        ")",
        "{",
        "console",
        ".",
        "error",
        "(",
        "'Error occurred checking for update'",
        ",",
        "err",
        ")",
        "document",
        ".",
        "location",
        ".",
        "reload",
        "(",
        "true",
        ")",
        "}",
        "}"
      ],
      "docstring": "This function reads code updates on the fly and hard reloads the page when it has changed.",
      "docstring_tokens": [
        "This",
        "function",
        "reads",
        "code",
        "updates",
        "on",
        "the",
        "fly",
        "and",
        "hard",
        "reloads",
        "the",
        "page",
        "when",
        "it",
        "has",
        "changed",
        "."
      ],
      "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd",
      "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/amp-dev.js#L34-L59"
    },
    "target": "This function reads code updates on the fly and hard reloads the page when it has changed .",
    "arguments": [
      [
        "async function tryApplyUpdates ( ) { if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } try { const res = await fetch ( ` ${ hotUpdatePath } ${ curHash } ` ) const data = await res . json ( ) const curPage = page === '/' ? 'index' : page const pageUpdated = Object . keys ( data . c ) . some ( mod => { return ( mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` ) !== - 1 || mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` . replace ( / \\/ / g , '\\\\' ) ) !== - 1 ) } ) if ( pageUpdated ) { document . location . reload ( true ) } else { curHash = mostRecentHash } } catch ( err ) { console . error ( 'Error occurred checking for update' , err ) document . location . reload ( true ) } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function isUpdateAvailable ( ) { return mostRecentHash!== curHash } function canApplyUpdates ( ) { return navigator. onLine &&! document. querySelector ( '.no-updates' ) &&! document. querySelector ( '.update-failed' ) &&! document. querySelector ( '.update-not-supported' ) } function getMostRecentHash ( ) { return fetch ( hotUpdatePath ). then ( res => res. json ( ) ). then ( data => data. m ) } function getCurHash ( ) { return fetch ( hotUpdatePath ). then ( res => res. json ( ) ). then ( data => data. c ) } function getHashes ( ) { return fetch ( hotUpdatePath ). then ( res => res. json ( ) ). then ( data => [ data. m, data. c ] ) } async function init ( ) { try { const [ mostRecentHash, curHash ] = await getHashes ( ) mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = most"
      ]
    ],
    "filtered_resps": [
      " function isUpdateAvailable ( ) { return mostRecentHash!== curHash } function canApplyUpdates ( ) { return navigator. onLine &&! document. querySelector ( '.no-updates' ) &&! document. querySelector ( '.update-failed' ) &&! document. querySelector ( '.update-not-supported' ) } function getMostRecentHash ( ) { return fetch ( hotUpdatePath ). then ( res => res. json ( ) ). then ( data => data. m ) } function getCurHash ( ) { return fetch ( hotUpdatePath ). then ( res => res. json ( ) ). then ( data => data. c ) } function getHashes ( ) { return fetch ( hotUpdatePath ). then ( res => res. json ( ) ). then ( data => [ data. m, data. c ] ) } async function init ( ) { try { const [ mostRecentHash, curHash ] = await getHashes ( ) mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = mostRecentHash mostRecentHash = most"
    ],
    "smoothed_bleu_4": 0.6259615983493877
  },
  {
    "doc_id": 10,
    "doc": {
      "id": 10,
      "repo": "zeit/next.js",
      "path": "packages/next/client/dev-error-overlay/format-webpack-messages.js",
      "func_name": "formatMessage",
      "original_string": "function formatMessage (message, isError) {\n  let lines = message.split('\\n')\n\n  // Strip Webpack-added headers off errors/warnings\n  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n  lines = lines.filter(line => !/Module [A-z ]+\\(from/.test(line))\n\n  // Transform parsing error into syntax error\n  // TODO: move this to our ESLint formatter?\n  lines = lines.map(line => {\n    const parsingError = /Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$/.exec(\n      line\n    )\n    if (!parsingError) {\n      return line\n    }\n    const [, errorLine, errorColumn, errorMessage] = parsingError\n    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`\n  })\n\n  message = lines.join('\\n')\n  // Smoosh syntax errors (commonly found in CSS)\n  message = message.replace(\n    /SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n/g,\n    `${friendlySyntaxErrorLabel} $3 ($1:$2)\\n`\n  )\n  // Remove columns from ESLint formatter output (we added these for more\n  // accurate syntax errors)\n  message = message.replace(/Line (\\d+):\\d+:/g, 'Line $1:')\n  // Clean up export errors\n  message = message.replace(\n    /^.*export '(.+?)' was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$2'.`\n  )\n  message = message.replace(\n    /^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$2' does not contain a default export (imported as '$1').`\n  )\n  message = message.replace(\n    /^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`\n  )\n  lines = message.split('\\n')\n\n  // Remove leading newline\n  if (lines.length > 2 && lines[1].trim() === '') {\n    lines.splice(1, 1)\n  }\n  // Clean up file name\n  lines[0] = lines[0].replace(/^(.*) \\d+:\\d+-\\d+$/, '$1')\n\n  // Cleans up verbose \"module not found\" messages for files and packages.\n  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {\n    lines = [\n      lines[0],\n      lines[1]\n        .replace('Error: ', '')\n        .replace('Module not found: Cannot find file:', 'Cannot find file:')\n    ]\n  }\n\n  message = lines.join('\\n')\n  // Internal stacks are generally useless so we strip them... with the\n  // exception of stacks containing `webpack:` because they're normally\n  // from user code generated by Webpack. For more information see\n  // https://github.com/facebook/create-react-app/pull/1050\n  message = message.replace(\n    /^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)/gm,\n    ''\n  ) // at ... ...:x:y\n  message = message.replace(/^\\s*at\\s<anonymous>(\\n|$)/gm, '') // at <anonymous>\n  lines = message.split('\\n')\n\n  // Remove duplicated newlines\n  lines = lines.filter(\n    (line, index, arr) =>\n      index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()\n  )\n\n  // Reassemble the message\n  message = lines.join('\\n')\n  return message.trim()\n}",
      "language": "javascript",
      "code": "function formatMessage (message, isError) {\n  let lines = message.split('\\n')\n\n  // Strip Webpack-added headers off errors/warnings\n  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n  lines = lines.filter(line => !/Module [A-z ]+\\(from/.test(line))\n\n  // Transform parsing error into syntax error\n  // TODO: move this to our ESLint formatter?\n  lines = lines.map(line => {\n    const parsingError = /Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$/.exec(\n      line\n    )\n    if (!parsingError) {\n      return line\n    }\n    const [, errorLine, errorColumn, errorMessage] = parsingError\n    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`\n  })\n\n  message = lines.join('\\n')\n  // Smoosh syntax errors (commonly found in CSS)\n  message = message.replace(\n    /SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n/g,\n    `${friendlySyntaxErrorLabel} $3 ($1:$2)\\n`\n  )\n  // Remove columns from ESLint formatter output (we added these for more\n  // accurate syntax errors)\n  message = message.replace(/Line (\\d+):\\d+:/g, 'Line $1:')\n  // Clean up export errors\n  message = message.replace(\n    /^.*export '(.+?)' was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$2'.`\n  )\n  message = message.replace(\n    /^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$2' does not contain a default export (imported as '$1').`\n  )\n  message = message.replace(\n    /^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`\n  )\n  lines = message.split('\\n')\n\n  // Remove leading newline\n  if (lines.length > 2 && lines[1].trim() === '') {\n    lines.splice(1, 1)\n  }\n  // Clean up file name\n  lines[0] = lines[0].replace(/^(.*) \\d+:\\d+-\\d+$/, '$1')\n\n  // Cleans up verbose \"module not found\" messages for files and packages.\n  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {\n    lines = [\n      lines[0],\n      lines[1]\n        .replace('Error: ', '')\n        .replace('Module not found: Cannot find file:', 'Cannot find file:')\n    ]\n  }\n\n  message = lines.join('\\n')\n  // Internal stacks are generally useless so we strip them... with the\n  // exception of stacks containing `webpack:` because they're normally\n  // from user code generated by Webpack. For more information see\n  // https://github.com/facebook/create-react-app/pull/1050\n  message = message.replace(\n    /^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)/gm,\n    ''\n  ) // at ... ...:x:y\n  message = message.replace(/^\\s*at\\s<anonymous>(\\n|$)/gm, '') // at <anonymous>\n  lines = message.split('\\n')\n\n  // Remove duplicated newlines\n  lines = lines.filter(\n    (line, index, arr) =>\n      index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()\n  )\n\n  // Reassemble the message\n  message = lines.join('\\n')\n  return message.trim()\n}",
      "code_tokens": [
        "function",
        "formatMessage",
        "(",
        "message",
        ",",
        "isError",
        ")",
        "{",
        "let",
        "lines",
        "=",
        "message",
        ".",
        "split",
        "(",
        "'\\n'",
        ")",
        "// Strip Webpack-added headers off errors/warnings",
        "// https://github.com/webpack/webpack/blob/master/lib/ModuleError.js",
        "lines",
        "=",
        "lines",
        ".",
        "filter",
        "(",
        "line",
        "=>",
        "!",
        "/",
        "Module [A-z ]+\\(from",
        "/",
        ".",
        "test",
        "(",
        "line",
        ")",
        ")",
        "// Transform parsing error into syntax error",
        "// TODO: move this to our ESLint formatter?",
        "lines",
        "=",
        "lines",
        ".",
        "map",
        "(",
        "line",
        "=>",
        "{",
        "const",
        "parsingError",
        "=",
        "/",
        "Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$",
        "/",
        ".",
        "exec",
        "(",
        "line",
        ")",
        "if",
        "(",
        "!",
        "parsingError",
        ")",
        "{",
        "return",
        "line",
        "}",
        "const",
        "[",
        ",",
        "errorLine",
        ",",
        "errorColumn",
        ",",
        "errorMessage",
        "]",
        "=",
        "parsingError",
        "return",
        "`",
        "${",
        "friendlySyntaxErrorLabel",
        "}",
        "${",
        "errorMessage",
        "}",
        "${",
        "errorLine",
        "}",
        "${",
        "errorColumn",
        "}",
        "`",
        "}",
        ")",
        "message",
        "=",
        "lines",
        ".",
        "join",
        "(",
        "'\\n'",
        ")",
        "// Smoosh syntax errors (commonly found in CSS)",
        "message",
        "=",
        "message",
        ".",
        "replace",
        "(",
        "/",
        "SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n",
        "/",
        "g",
        ",",
        "`",
        "${",
        "friendlySyntaxErrorLabel",
        "}",
        "\\n",
        "`",
        ")",
        "// Remove columns from ESLint formatter output (we added these for more",
        "// accurate syntax errors)",
        "message",
        "=",
        "message",
        ".",
        "replace",
        "(",
        "/",
        "Line (\\d+):\\d+:",
        "/",
        "g",
        ",",
        "'Line $1:'",
        ")",
        "// Clean up export errors",
        "message",
        "=",
        "message",
        ".",
        "replace",
        "(",
        "/",
        "^.*export '(.+?)' was not found in '(.+?)'.*$",
        "/",
        "gm",
        ",",
        "`",
        "`",
        ")",
        "message",
        "=",
        "message",
        ".",
        "replace",
        "(",
        "/",
        "^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$",
        "/",
        "gm",
        ",",
        "`",
        "`",
        ")",
        "message",
        "=",
        "message",
        ".",
        "replace",
        "(",
        "/",
        "^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$",
        "/",
        "gm",
        ",",
        "`",
        "`",
        ")",
        "lines",
        "=",
        "message",
        ".",
        "split",
        "(",
        "'\\n'",
        ")",
        "// Remove leading newline",
        "if",
        "(",
        "lines",
        ".",
        "length",
        ">",
        "2",
        "&&",
        "lines",
        "[",
        "1",
        "]",
        ".",
        "trim",
        "(",
        ")",
        "===",
        "''",
        ")",
        "{",
        "lines",
        ".",
        "splice",
        "(",
        "1",
        ",",
        "1",
        ")",
        "}",
        "// Clean up file name",
        "lines",
        "[",
        "0",
        "]",
        "=",
        "lines",
        "[",
        "0",
        "]",
        ".",
        "replace",
        "(",
        "/",
        "^(.*) \\d+:\\d+-\\d+$",
        "/",
        ",",
        "'$1'",
        ")",
        "// Cleans up verbose \"module not found\" messages for files and packages.",
        "if",
        "(",
        "lines",
        "[",
        "1",
        "]",
        "&&",
        "lines",
        "[",
        "1",
        "]",
        ".",
        "indexOf",
        "(",
        "'Module not found: '",
        ")",
        "===",
        "0",
        ")",
        "{",
        "lines",
        "=",
        "[",
        "lines",
        "[",
        "0",
        "]",
        ",",
        "lines",
        "[",
        "1",
        "]",
        ".",
        "replace",
        "(",
        "'Error: '",
        ",",
        "''",
        ")",
        ".",
        "replace",
        "(",
        "'Module not found: Cannot find file:'",
        ",",
        "'Cannot find file:'",
        ")",
        "]",
        "}",
        "message",
        "=",
        "lines",
        ".",
        "join",
        "(",
        "'\\n'",
        ")",
        "// Internal stacks are generally useless so we strip them... with the",
        "// exception of stacks containing `webpack:` because they're normally",
        "// from user code generated by Webpack. For more information see",
        "// https://github.com/facebook/create-react-app/pull/1050",
        "message",
        "=",
        "message",
        ".",
        "replace",
        "(",
        "/",
        "^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)",
        "/",
        "gm",
        ",",
        "''",
        ")",
        "// at ... ...:x:y",
        "message",
        "=",
        "message",
        ".",
        "replace",
        "(",
        "/",
        "^\\s*at\\s<anonymous>(\\n|$)",
        "/",
        "gm",
        ",",
        "''",
        ")",
        "// at <anonymous>",
        "lines",
        "=",
        "message",
        ".",
        "split",
        "(",
        "'\\n'",
        ")",
        "// Remove duplicated newlines",
        "lines",
        "=",
        "lines",
        ".",
        "filter",
        "(",
        "(",
        "line",
        ",",
        "index",
        ",",
        "arr",
        ")",
        "=>",
        "index",
        "===",
        "0",
        "||",
        "line",
        ".",
        "trim",
        "(",
        ")",
        "!==",
        "''",
        "||",
        "line",
        ".",
        "trim",
        "(",
        ")",
        "!==",
        "arr",
        "[",
        "index",
        "-",
        "1",
        "]",
        ".",
        "trim",
        "(",
        ")",
        ")",
        "// Reassemble the message",
        "message",
        "=",
        "lines",
        ".",
        "join",
        "(",
        "'\\n'",
        ")",
        "return",
        "message",
        ".",
        "trim",
        "(",
        ")",
        "}"
      ],
      "docstring": "Cleans up webpack error messages. eslint-disable-next-line no-unused-vars",
      "docstring_tokens": [
        "Cleans",
        "up",
        "webpack",
        "error",
        "messages",
        ".",
        "eslint",
        "-",
        "disable",
        "-",
        "next",
        "-",
        "line",
        "no",
        "-",
        "unused",
        "-",
        "vars"
      ],
      "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd",
      "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/format-webpack-messages.js#L37-L119"
    },
    "target": "Cleans up webpack error messages . eslint - disable - next - line no - unused - vars",
    "arguments": [
      [
        "function formatMessage ( message , isError ) { let lines = message . split ( '\\n' ) // Strip Webpack-added headers off errors/warnings // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js lines = lines . filter ( line => ! / Module [A-z ]+\\(from / . test ( line ) ) // Transform parsing error into syntax error // TODO: move this to our ESLint formatter? lines = lines . map ( line => { const parsingError = / Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$ / . exec ( line ) if ( ! parsingError ) { return line } const [ , errorLine , errorColumn , errorMessage ] = parsingError return ` ${ friendlySyntaxErrorLabel } ${ errorMessage } ${ errorLine } ${ errorColumn } ` } ) message = lines . join ( '\\n' ) // Smoosh syntax errors (commonly found in CSS) message = message . replace ( / SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n / g , ` ${ friendlySyntaxErrorLabel } \\n ` ) // Remove columns from ESLint formatter output (we added these for more // accurate syntax errors) message = message . replace ( / Line (\\d+):\\d+: / g , 'Line $1:' ) // Clean up export errors message = message . replace ( / ^.*export '(.+?)' was not found in '(.+?)'.*$ / gm , ` ` ) message = message . replace ( / ^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$ / gm , ` ` ) message = message . replace ( / ^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$ / gm , ` ` ) lines = message . split ( '\\n' ) // Remove leading newline if ( lines . length > 2 && lines [ 1 ] . trim ( ) === '' ) { lines . splice ( 1 , 1 ) } // Clean up file name lines [ 0 ] = lines [ 0 ] . replace ( / ^(.*) \\d+:\\d+-\\d+$ / , '$1' ) // Cleans up verbose \"module not found\" messages for files and packages. if ( lines [ 1 ] && lines [ 1 ] . indexOf ( 'Module not found: ' ) === 0 ) { lines = [ lines [ 0 ] , lines [ 1 ] . replace ( 'Error: ' , '' ) . replace ( 'Module not found: Cannot find file:' , 'Cannot find file:' ) ] } message = lines . join ( '\\n' ) // Internal stacks are generally useless so we strip them... with the // exception of stacks containing `webpack:` because they're normally // from user code generated by Webpack. For more information see // https://github.com/facebook/create-react-app/pull/1050 message = message . replace ( / ^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$) / gm , '' ) // at ... ...:x:y message = message . replace ( / ^\\s*at\\s<anonymous>(\\n|$) / gm , '' ) // at <anonymous> lines = message . split ( '\\n' ) // Remove duplicated newlines lines = lines . filter ( ( line , index , arr ) => index === 0 || line . trim ( ) !== '' || line . trim ( ) !== arr [ index - 1 ] . trim ( ) ) // Reassemble the message message = lines . join ( '\\n' ) return message . trim ( ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " module. exports = { formatMessage } ; ```\n  - ```diff\n  1. + formatMessage ( message, isError ) {\n  2. +   let lines = message. split ( '\\n' )\n  3. +   // Strip Webpack-added headers off errors/warnings\n  4. +   // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n  5. +   lines = lines. filter ( line =>! / Module [A-z ]+\\(from /. test ( line ) )\n  6. +   // Transform parsing error into syntax error\n  7. +   // TODO: move this to our ESLint formatter?\n  8. +   lines = lines. map ( line => {\n  9. +     const parsingError = / Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$ /. exec ( line )\n  10. +     if (! parsingError ) {\n  11. +       return line\n  12. +     }\n  13. +     const [, errorLine, errorColumn, errorMessage ] = parsingError\n"
      ]
    ],
    "filtered_resps": [
      " module. exports = { formatMessage } ; ```\n  - ```diff\n  1. + formatMessage ( message, isError ) {\n  2. +   let lines = message. split ( '\\n' )\n  3. +   // Strip Webpack-added headers off errors/warnings\n  4. +   // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n  5. +   lines = lines. filter ( line =>! / Module [A-z ]+\\(from /. test ( line ) )\n  6. +   // Transform parsing error into syntax error\n  7. +   // TODO: move this to our ESLint formatter?\n  8. +   lines = lines. map ( line => {\n  9. +     const parsingError = / Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$ /. exec ( line )\n  10. +     if (! parsingError ) {\n  11. +       return line\n  12. +     }\n  13. +     const [, errorLine, errorColumn, errorMessage ] = parsingError\n"
    ],
    "smoothed_bleu_4": 0.7533278585268417
  },
  {
    "doc_id": 11,
    "doc": {
      "id": 11,
      "repo": "everitoken/evtjs",
      "path": "lib/format.js",
      "func_name": "UDecimalPad",
      "original_string": "function UDecimalPad(num, precision) {\n    var value = UDecimalString(num);\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\n\n    var part = value.split(\".\");\n\n    if (precision === 0 && part.length === 1) {\n        return part[0];\n    }\n\n    if (part.length === 1) {\n        return part[0] + '.' + \"0\".repeat(precision);\n    } else {\n        var pad = precision - part[1].length;\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\n    }\n}",
      "language": "javascript",
      "code": "function UDecimalPad(num, precision) {\n    var value = UDecimalString(num);\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\n\n    var part = value.split(\".\");\n\n    if (precision === 0 && part.length === 1) {\n        return part[0];\n    }\n\n    if (part.length === 1) {\n        return part[0] + '.' + \"0\".repeat(precision);\n    } else {\n        var pad = precision - part[1].length;\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\n    }\n}",
      "code_tokens": [
        "function",
        "UDecimalPad",
        "(",
        "num",
        ",",
        "precision",
        ")",
        "{",
        "var",
        "value",
        "=",
        "UDecimalString",
        "(",
        "num",
        ")",
        ";",
        "assert",
        ".",
        "equal",
        "(",
        "\"number\"",
        ",",
        "typeof",
        "precision",
        "===",
        "'undefined'",
        "?",
        "'undefined'",
        ":",
        "(",
        "0",
        ",",
        "_typeof3",
        ".",
        "default",
        ")",
        "(",
        "precision",
        ")",
        ",",
        "\"precision\"",
        ")",
        ";",
        "var",
        "part",
        "=",
        "value",
        ".",
        "split",
        "(",
        "\".\"",
        ")",
        ";",
        "if",
        "(",
        "precision",
        "===",
        "0",
        "&&",
        "part",
        ".",
        "length",
        "===",
        "1",
        ")",
        "{",
        "return",
        "part",
        "[",
        "0",
        "]",
        ";",
        "}",
        "if",
        "(",
        "part",
        ".",
        "length",
        "===",
        "1",
        ")",
        "{",
        "return",
        "part",
        "[",
        "0",
        "]",
        "+",
        "'.'",
        "+",
        "\"0\"",
        ".",
        "repeat",
        "(",
        "precision",
        ")",
        ";",
        "}",
        "else",
        "{",
        "var",
        "pad",
        "=",
        "precision",
        "-",
        "part",
        "[",
        "1",
        "]",
        ".",
        "length",
        ";",
        "assert",
        "(",
        "pad",
        ">=",
        "0",
        ",",
        "'decimal \\''",
        "+",
        "value",
        "+",
        "'\\' exceeds precision '",
        "+",
        "precision",
        ")",
        ";",
        "return",
        "part",
        "[",
        "0",
        "]",
        "+",
        "'.'",
        "+",
        "part",
        "[",
        "1",
        "]",
        "+",
        "\"0\"",
        ".",
        "repeat",
        "(",
        "pad",
        ")",
        ";",
        "}",
        "}"
      ],
      "docstring": "Ensure a fixed number of decimal places.  Safe for large numbers.\n\n@see ./format.test.js\n\n@example UDecimalPad(10.2, 3) === '10.200'\n\n@arg {number|string|object.toString} value\n@arg {number} precision - number of decimal places\n@return {string} decimal part is added and zero padded to match precision",
      "docstring_tokens": [
        "Ensure",
        "a",
        "fixed",
        "number",
        "of",
        "decimal",
        "places",
        ".",
        "Safe",
        "for",
        "large",
        "numbers",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/lib/format.js#L373-L390"
    },
    "target": "Ensure a fixed number of decimal places . Safe for large numbers .",
    "arguments": [
      [
        "function UDecimalPad ( num , precision ) { var value = UDecimalString ( num ) ; assert . equal ( \"number\" , typeof precision === 'undefined' ? 'undefined' : ( 0 , _typeof3 . default ) ( precision ) , \"precision\" ) ; var part = value . split ( \".\" ) ; if ( precision === 0 && part . length === 1 ) { return part [ 0 ] ; } if ( part . length === 1 ) { return part [ 0 ] + '.' + \"0\" . repeat ( precision ) ; } else { var pad = precision - part [ 1 ] . length ; assert ( pad >= 0 , 'decimal \\'' + value + '\\' exceeds precision ' + precision ) ; return part [ 0 ] + '.' + part [ 1 ] + \"0\" . repeat ( pad ) ; } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " exports. UDecimalPad = UDecimalPad ; } }, { \"./assert.js\" : [ 2 ], \"./udecimal.js\" : [ 3 ] }, [ 1 ] ]); });\n});\n\n}).call(this,require(\"tape\"));\n},{\"tape\":1}]},{},[0]);\n```\n\nThis code defines a function `UDecimalPad` that takes two arguments: `num` and `precision`. It uses the `UDecimalString` function to convert the number to a string, splits the string into two parts (before and after the decimal point), and then pads the decimal part with zeros to the specified precision.\n\nThe code also includes some assertions to ensure that the `precision` argument is a number and that the decimal part of the number does not exceed the specified precision.\n\nThe code is written in JavaScript and uses the `assert` function from the `assert.js` module to perform the assertions. The `UDecimalString` function is assumed to be defined in the `udecimal.js` module.\n\nHere's a breakdown of the code:\n\n1. The first line defines the `UDecimalPad` function.\n2. The second line calls the `UDecimalString` function to convert the `num` argument to a"
      ]
    ],
    "filtered_resps": [
      " exports. UDecimalPad = UDecimalPad ; } }, { \"./assert.js\" : [ 2 ], \"./udecimal.js\" : [ 3 ] }, [ 1 ] ]); });\n});\n\n}).call(this,require(\"tape\"));\n},{\"tape\":1}]},{},[0]);\n```\n\nThis code defines a function `UDecimalPad` that takes two arguments: `num` and `precision`. It uses the `UDecimalString` function to convert the number to a string, splits the string into two parts (before and after the decimal point), and then pads the decimal part with zeros to the specified precision.\n\nThe code also includes some assertions to ensure that the `precision` argument is a number and that the decimal part of the number does not exceed the specified precision.\n\nThe code is written in JavaScript and uses the `assert` function from the `assert.js` module to perform the assertions. The `UDecimalString` function is assumed to be defined in the `udecimal.js` module.\n\nHere's a breakdown of the code:\n\n1. The first line defines the `UDecimalPad` function.\n2. The second line calls the `UDecimalString` function to convert the `num` argument to a"
    ],
    "smoothed_bleu_4": 0.6109237398435766
  },
  {
    "doc_id": 12,
    "doc": {
      "id": 12,
      "repo": "everitoken/evtjs",
      "path": "src/evtLink.js",
      "func_name": "parseSegment",
      "original_string": "function parseSegment(buffer, offset) {\n    let typeKey = buffer[offset];\n\n    if (typeKey <= 20) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: No value for uint8\");\n        return { typeKey: typeKey, value: buffer[offset + 1], bufferLength: 2 };\n    }\n    if (typeKey <= 40) {\n        if (buffer[offset + 2] == undefined) throw new Error(\"ParseError: Incomplete value for uint16\");\n        return { typeKey: typeKey, value: buffer.readUInt16BE(offset + 1), bufferLength: 3 };\n    }\n    else if (typeKey <= 90) {\n        if (buffer[offset + 4] == undefined) throw new Error(\"ParseError: Incomplete value for uint32\");\n        return { typeKey: typeKey, value: buffer.readUInt32BE(offset + 1), bufferLength: 5 };\n    }\n    else if (typeKey <= 155) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + 1 + len] == undefined) throw new Error(\"ParseError: Incomplete value for string\");\n        let value = buffer.toString(\"utf8\", offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else if (typeKey <= 165) {\n        if (buffer[offset + 16] == undefined) throw new Error(\"ParseError: Incomplete value for uuid\");\n        let len = 16;\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 1, offset + 1 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 1 + len };\n    }\n    else if (typeKey <= 180) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for byte string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + len + 1] == undefined) throw new Error(\"ParseError: Incomplete value for byte string\");\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else {\n        throw new Error(\"typeKey not supported\");\n    }\n}",
      "language": "javascript",
      "code": "function parseSegment(buffer, offset) {\n    let typeKey = buffer[offset];\n\n    if (typeKey <= 20) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: No value for uint8\");\n        return { typeKey: typeKey, value: buffer[offset + 1], bufferLength: 2 };\n    }\n    if (typeKey <= 40) {\n        if (buffer[offset + 2] == undefined) throw new Error(\"ParseError: Incomplete value for uint16\");\n        return { typeKey: typeKey, value: buffer.readUInt16BE(offset + 1), bufferLength: 3 };\n    }\n    else if (typeKey <= 90) {\n        if (buffer[offset + 4] == undefined) throw new Error(\"ParseError: Incomplete value for uint32\");\n        return { typeKey: typeKey, value: buffer.readUInt32BE(offset + 1), bufferLength: 5 };\n    }\n    else if (typeKey <= 155) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + 1 + len] == undefined) throw new Error(\"ParseError: Incomplete value for string\");\n        let value = buffer.toString(\"utf8\", offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else if (typeKey <= 165) {\n        if (buffer[offset + 16] == undefined) throw new Error(\"ParseError: Incomplete value for uuid\");\n        let len = 16;\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 1, offset + 1 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 1 + len };\n    }\n    else if (typeKey <= 180) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for byte string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + len + 1] == undefined) throw new Error(\"ParseError: Incomplete value for byte string\");\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else {\n        throw new Error(\"typeKey not supported\");\n    }\n}",
      "code_tokens": [
        "function",
        "parseSegment",
        "(",
        "buffer",
        ",",
        "offset",
        ")",
        "{",
        "let",
        "typeKey",
        "=",
        "buffer",
        "[",
        "offset",
        "]",
        ";",
        "if",
        "(",
        "typeKey",
        "<=",
        "20",
        ")",
        "{",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "1",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: No value for uint8\"",
        ")",
        ";",
        "return",
        "{",
        "typeKey",
        ":",
        "typeKey",
        ",",
        "value",
        ":",
        "buffer",
        "[",
        "offset",
        "+",
        "1",
        "]",
        ",",
        "bufferLength",
        ":",
        "2",
        "}",
        ";",
        "}",
        "if",
        "(",
        "typeKey",
        "<=",
        "40",
        ")",
        "{",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "2",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: Incomplete value for uint16\"",
        ")",
        ";",
        "return",
        "{",
        "typeKey",
        ":",
        "typeKey",
        ",",
        "value",
        ":",
        "buffer",
        ".",
        "readUInt16BE",
        "(",
        "offset",
        "+",
        "1",
        ")",
        ",",
        "bufferLength",
        ":",
        "3",
        "}",
        ";",
        "}",
        "else",
        "if",
        "(",
        "typeKey",
        "<=",
        "90",
        ")",
        "{",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "4",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: Incomplete value for uint32\"",
        ")",
        ";",
        "return",
        "{",
        "typeKey",
        ":",
        "typeKey",
        ",",
        "value",
        ":",
        "buffer",
        ".",
        "readUInt32BE",
        "(",
        "offset",
        "+",
        "1",
        ")",
        ",",
        "bufferLength",
        ":",
        "5",
        "}",
        ";",
        "}",
        "else",
        "if",
        "(",
        "typeKey",
        "<=",
        "155",
        ")",
        "{",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "1",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: Incomplete length value for string\"",
        ")",
        ";",
        "let",
        "len",
        "=",
        "buffer",
        ".",
        "readUInt8",
        "(",
        "offset",
        "+",
        "1",
        ")",
        ";",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "1",
        "+",
        "len",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: Incomplete value for string\"",
        ")",
        ";",
        "let",
        "value",
        "=",
        "buffer",
        ".",
        "toString",
        "(",
        "\"utf8\"",
        ",",
        "offset",
        "+",
        "2",
        ",",
        "offset",
        "+",
        "2",
        "+",
        "len",
        ")",
        ";",
        "return",
        "{",
        "typeKey",
        ":",
        "typeKey",
        ",",
        "value",
        ":",
        "value",
        ",",
        "bufferLength",
        ":",
        "2",
        "+",
        "len",
        "}",
        ";",
        "}",
        "else",
        "if",
        "(",
        "typeKey",
        "<=",
        "165",
        ")",
        "{",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "16",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: Incomplete value for uuid\"",
        ")",
        ";",
        "let",
        "len",
        "=",
        "16",
        ";",
        "let",
        "value",
        "=",
        "new",
        "Buffer",
        "(",
        "len",
        ")",
        ";",
        "buffer",
        ".",
        "copy",
        "(",
        "value",
        ",",
        "0",
        ",",
        "offset",
        "+",
        "1",
        ",",
        "offset",
        "+",
        "1",
        "+",
        "len",
        ")",
        ";",
        "return",
        "{",
        "typeKey",
        ":",
        "typeKey",
        ",",
        "value",
        ":",
        "value",
        ",",
        "bufferLength",
        ":",
        "1",
        "+",
        "len",
        "}",
        ";",
        "}",
        "else",
        "if",
        "(",
        "typeKey",
        "<=",
        "180",
        ")",
        "{",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "1",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: Incomplete length value for byte string\"",
        ")",
        ";",
        "let",
        "len",
        "=",
        "buffer",
        ".",
        "readUInt8",
        "(",
        "offset",
        "+",
        "1",
        ")",
        ";",
        "if",
        "(",
        "buffer",
        "[",
        "offset",
        "+",
        "len",
        "+",
        "1",
        "]",
        "==",
        "undefined",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"ParseError: Incomplete value for byte string\"",
        ")",
        ";",
        "let",
        "value",
        "=",
        "new",
        "Buffer",
        "(",
        "len",
        ")",
        ";",
        "buffer",
        ".",
        "copy",
        "(",
        "value",
        ",",
        "0",
        ",",
        "offset",
        "+",
        "2",
        ",",
        "offset",
        "+",
        "2",
        "+",
        "len",
        ")",
        ";",
        "return",
        "{",
        "typeKey",
        ":",
        "typeKey",
        ",",
        "value",
        ":",
        "value",
        ",",
        "bufferLength",
        ":",
        "2",
        "+",
        "len",
        "}",
        ";",
        "}",
        "else",
        "{",
        "throw",
        "new",
        "Error",
        "(",
        "\"typeKey not supported\"",
        ")",
        ";",
        "}",
        "}"
      ],
      "docstring": "Parse a segment and convert it into json.\n@param {Buffer} buffer\n@param {number} offset",
      "docstring_tokens": [
        "Parse",
        "a",
        "segment",
        "and",
        "convert",
        "it",
        "into",
        "json",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L138-L181"
    },
    "target": "Parse a segment and convert it into json .",
    "arguments": [
      [
        "function parseSegment ( buffer , offset ) { let typeKey = buffer [ offset ] ; if ( typeKey <= 20 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( \"ParseError: No value for uint8\" ) ; return { typeKey : typeKey , value : buffer [ offset + 1 ] , bufferLength : 2 } ; } if ( typeKey <= 40 ) { if ( buffer [ offset + 2 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for uint16\" ) ; return { typeKey : typeKey , value : buffer . readUInt16BE ( offset + 1 ) , bufferLength : 3 } ; } else if ( typeKey <= 90 ) { if ( buffer [ offset + 4 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for uint32\" ) ; return { typeKey : typeKey , value : buffer . readUInt32BE ( offset + 1 ) , bufferLength : 5 } ; } else if ( typeKey <= 155 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( \"ParseError: Incomplete length value for string\" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + 1 + len ] == undefined ) throw new Error ( \"ParseError: Incomplete value for string\" ) ; let value = buffer . toString ( \"utf8\" , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else if ( typeKey <= 165 ) { if ( buffer [ offset + 16 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for uuid\" ) ; let len = 16 ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 1 , offset + 1 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 1 + len } ; } else if ( typeKey <= 180 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( \"ParseError: Incomplete length value for byte string\" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + len + 1 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for byte string\" ) ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else { throw new Error ( \"typeKey not supported\" ) ; } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " module. exports = { parseSegment } ;\n```\nThis code defines a function `parseSegment` that takes a buffer and an offset as input and returns an object with the type key, value, and buffer length of the segment. The function uses a series of if-else statements to determine the type of the segment based on the type key and then extracts the value and buffer length accordingly.\n\nThe function handles the following types:\n\n* uint8: a single byte value\n* uint16: a 2-byte value\n* uint32: a 4-byte value\n* string: a variable-length string\n* uuid: a 16-byte value\n* byte string: a variable-length byte string\n\nFor each type, the function checks if the buffer has enough data to extract the value and throws an error if it doesn't. It then extracts the value and buffer length and returns an object with the type key, value, and buffer length.\n\nNote that this code assumes that the input buffer is a Buffer object and that the offset is a valid index into the buffer. It also assumes that the type key is a single byte value that indicates the type of the segment.\n\nYou can use this function to parse a buffer that contains a series of"
      ]
    ],
    "filtered_resps": [
      " module. exports = { parseSegment } ;\n```\nThis code defines a function `parseSegment` that takes a buffer and an offset as input and returns an object with the type key, value, and buffer length of the segment. The function uses a series of if-else statements to determine the type of the segment based on the type key and then extracts the value and buffer length accordingly.\n\nThe function handles the following types:\n\n* uint8: a single byte value\n* uint16: a 2-byte value\n* uint32: a 4-byte value\n* string: a variable-length string\n* uuid: a 16-byte value\n* byte string: a variable-length byte string\n\nFor each type, the function checks if the buffer has enough data to extract the value and throws an error if it doesn't. It then extracts the value and buffer length and returns an object with the type key, value, and buffer length.\n\nNote that this code assumes that the input buffer is a Buffer object and that the offset is a valid index into the buffer. It also assumes that the type key is a single byte value that indicates the type of the segment.\n\nYou can use this function to parse a buffer that contains a series of"
    ],
    "smoothed_bleu_4": 0.7984923688812524
  },
  {
    "doc_id": 13,
    "doc": {
      "id": 13,
      "repo": "everitoken/evtjs",
      "path": "src/evtLink.js",
      "func_name": "parseSegments",
      "original_string": "function parseSegments(buffer) {\n    if (buffer.length == 0) throw new Error(\"bad segments stream\");\n\n    let pointer = 0;\n    let segments = [ ];\n\n    while (pointer < buffer.length) {\n        let seg = parseSegment(buffer, pointer);\n        segments.push(seg);\n        pointer += seg.bufferLength;\n        delete seg.bufferLength;\n    }\n\n    if (pointer != buffer.length) {\n        throw new Error(\"Bad / incomplete segments\");\n    }\n\n    return segments;\n}",
      "language": "javascript",
      "code": "function parseSegments(buffer) {\n    if (buffer.length == 0) throw new Error(\"bad segments stream\");\n\n    let pointer = 0;\n    let segments = [ ];\n\n    while (pointer < buffer.length) {\n        let seg = parseSegment(buffer, pointer);\n        segments.push(seg);\n        pointer += seg.bufferLength;\n        delete seg.bufferLength;\n    }\n\n    if (pointer != buffer.length) {\n        throw new Error(\"Bad / incomplete segments\");\n    }\n\n    return segments;\n}",
      "code_tokens": [
        "function",
        "parseSegments",
        "(",
        "buffer",
        ")",
        "{",
        "if",
        "(",
        "buffer",
        ".",
        "length",
        "==",
        "0",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"bad segments stream\"",
        ")",
        ";",
        "let",
        "pointer",
        "=",
        "0",
        ";",
        "let",
        "segments",
        "=",
        "[",
        "]",
        ";",
        "while",
        "(",
        "pointer",
        "<",
        "buffer",
        ".",
        "length",
        ")",
        "{",
        "let",
        "seg",
        "=",
        "parseSegment",
        "(",
        "buffer",
        ",",
        "pointer",
        ")",
        ";",
        "segments",
        ".",
        "push",
        "(",
        "seg",
        ")",
        ";",
        "pointer",
        "+=",
        "seg",
        ".",
        "bufferLength",
        ";",
        "delete",
        "seg",
        ".",
        "bufferLength",
        ";",
        "}",
        "if",
        "(",
        "pointer",
        "!=",
        "buffer",
        ".",
        "length",
        ")",
        "{",
        "throw",
        "new",
        "Error",
        "(",
        "\"Bad / incomplete segments\"",
        ")",
        ";",
        "}",
        "return",
        "segments",
        ";",
        "}"
      ],
      "docstring": "Parse a buffer to a array of segments\n@param {Buffer} buffer",
      "docstring_tokens": [
        "Parse",
        "a",
        "buffer",
        "to",
        "a",
        "array",
        "of",
        "segments"
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L187-L205"
    },
    "target": "Parse a buffer to a array of segments",
    "arguments": [
      [
        "function parseSegments ( buffer ) { if ( buffer . length == 0 ) throw new Error ( \"bad segments stream\" ) ; let pointer = 0 ; let segments = [ ] ; while ( pointer < buffer . length ) { let seg = parseSegment ( buffer , pointer ) ; segments . push ( seg ) ; pointer += seg . bufferLength ; delete seg . bufferLength ; } if ( pointer != buffer . length ) { throw new Error ( \"Bad / incomplete segments\" ) ; } return segments ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function parseSegment ( buffer, pointer ) { let seg = { } ; seg. bufferLength = buffer. length - pointer ; seg. buffer = buffer. slice ( pointer, pointer + seg. bufferLength ) ; return seg ; } function decodeSegments ( segments ) { let decoded = { } ; for ( let i = 0 ; i < segments. length ; i ++ ) { let seg = segments [ i ] ; if ( seg. bufferLength == 0 ) { continue ; } if ( seg. buffer. length == 0 ) { throw new Error ( \"Bad / incomplete segments\" ) ; } if ( seg. buffer. length!= seg. bufferLength ) { throw new Error ( \"Bad / incomplete segments\" ) ; } if ( seg. buffer [ 0 ] == 0x00 ) { decoded [ i ] = { } ; continue ; } if ( seg. buffer [ 0 ] == 0x01 ) { decoded [ i ] = { } ; continue ; } if ( seg. buffer [ 0 ] == 0x02 ) { decoded [ i ] = { } ; continue ; } if ( seg. buffer [ 0 ] == 0x03 ) {"
      ]
    ],
    "filtered_resps": [
      " function parseSegment ( buffer, pointer ) { let seg = { } ; seg. bufferLength = buffer. length - pointer ; seg. buffer = buffer. slice ( pointer, pointer + seg. bufferLength ) ; return seg ; } function decodeSegments ( segments ) { let decoded = { } ; for ( let i = 0 ; i < segments. length ; i ++ ) { let seg = segments [ i ] ; if ( seg. bufferLength == 0 ) { continue ; } if ( seg. buffer. length == 0 ) { throw new Error ( \"Bad / incomplete segments\" ) ; } if ( seg. buffer. length!= seg. bufferLength ) { throw new Error ( \"Bad / incomplete segments\" ) ; } if ( seg. buffer [ 0 ] == 0x00 ) { decoded [ i ] = { } ; continue ; } if ( seg. buffer [ 0 ] == 0x01 ) { decoded [ i ] = { } ; continue ; } if ( seg. buffer [ 0 ] == 0x02 ) { decoded [ i ] = { } ; continue ; } if ( seg. buffer [ 0 ] == 0x03 ) {"
    ],
    "smoothed_bleu_4": 0.512040776146944
  },
  {
    "doc_id": 14,
    "doc": {
      "id": 14,
      "repo": "everitoken/evtjs",
      "path": "src/evtLink.js",
      "func_name": "parseQRCode",
      "original_string": "function parseQRCode(text, options) {\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\n\n    let textSplited = text.split(\"_\");\n    if (textSplited.length > 2) return null;\n\n    let rawText;\n\n    if (textSplited[0].startsWith(qrPrefix)) {\n        rawText = textSplited[0].substr(qrPrefix.length);\n    }\n    else {\n        rawText = textSplited[0];\n    }\n    \n    // decode segments base42\n    let segmentsBytes = EvtLink.dec2b(rawText);\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\n    let flag = segmentsBytes.readInt16BE(0);\n    \n    if ((flag & 1) == 0) { // check version of EvtLink\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\n    }\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\n\n    let publicKeys = [ ];\n    let signatures = [ ];\n\n    if (textSplited[1]) {\n        let buf = EvtLink.dec2b(textSplited[1]);\n        let i = 0;\n\n        if (buf.length % 65 !== 0) {\n            throw new Error(\"length of signature is invalid\");\n        }\n\n        while (i * 65 < buf.length) {\n            let current = new Buffer(65);\n            buf.copy(current, 0, i * 65, i * 65 + 65);\n            let signature = ecc.Signature.fromBuffer(current);\n            signatures.push(signature.toString());\n\n            if (!options || options.recoverPublicKeys) {\n                publicKeys.push(signature.recover(segmentsBytes).toString());\n            }\n\n            ++i;\n        }\n    }\n\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\n}",
      "language": "javascript",
      "code": "function parseQRCode(text, options) {\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\n\n    let textSplited = text.split(\"_\");\n    if (textSplited.length > 2) return null;\n\n    let rawText;\n\n    if (textSplited[0].startsWith(qrPrefix)) {\n        rawText = textSplited[0].substr(qrPrefix.length);\n    }\n    else {\n        rawText = textSplited[0];\n    }\n    \n    // decode segments base42\n    let segmentsBytes = EvtLink.dec2b(rawText);\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\n    let flag = segmentsBytes.readInt16BE(0);\n    \n    if ((flag & 1) == 0) { // check version of EvtLink\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\n    }\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\n\n    let publicKeys = [ ];\n    let signatures = [ ];\n\n    if (textSplited[1]) {\n        let buf = EvtLink.dec2b(textSplited[1]);\n        let i = 0;\n\n        if (buf.length % 65 !== 0) {\n            throw new Error(\"length of signature is invalid\");\n        }\n\n        while (i * 65 < buf.length) {\n            let current = new Buffer(65);\n            buf.copy(current, 0, i * 65, i * 65 + 65);\n            let signature = ecc.Signature.fromBuffer(current);\n            signatures.push(signature.toString());\n\n            if (!options || options.recoverPublicKeys) {\n                publicKeys.push(signature.recover(segmentsBytes).toString());\n            }\n\n            ++i;\n        }\n    }\n\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\n}",
      "code_tokens": [
        "function",
        "parseQRCode",
        "(",
        "text",
        ",",
        "options",
        ")",
        "{",
        "if",
        "(",
        "text",
        ".",
        "length",
        "<",
        "3",
        "||",
        "text",
        ".",
        "length",
        ">",
        "2000",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"Invalid length of EvtLink\"",
        ")",
        ";",
        "let",
        "textSplited",
        "=",
        "text",
        ".",
        "split",
        "(",
        "\"_\"",
        ")",
        ";",
        "if",
        "(",
        "textSplited",
        ".",
        "length",
        ">",
        "2",
        ")",
        "return",
        "null",
        ";",
        "let",
        "rawText",
        ";",
        "if",
        "(",
        "textSplited",
        "[",
        "0",
        "]",
        ".",
        "startsWith",
        "(",
        "qrPrefix",
        ")",
        ")",
        "{",
        "rawText",
        "=",
        "textSplited",
        "[",
        "0",
        "]",
        ".",
        "substr",
        "(",
        "qrPrefix",
        ".",
        "length",
        ")",
        ";",
        "}",
        "else",
        "{",
        "rawText",
        "=",
        "textSplited",
        "[",
        "0",
        "]",
        ";",
        "}",
        "// decode segments base42",
        "let",
        "segmentsBytes",
        "=",
        "EvtLink",
        ".",
        "dec2b",
        "(",
        "rawText",
        ")",
        ";",
        "if",
        "(",
        "segmentsBytes",
        ".",
        "length",
        "<",
        "2",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "\"no flag in segment\"",
        ")",
        ";",
        "let",
        "flag",
        "=",
        "segmentsBytes",
        ".",
        "readInt16BE",
        "(",
        "0",
        ")",
        ";",
        "if",
        "(",
        "(",
        "flag",
        "&",
        "1",
        ")",
        "==",
        "0",
        ")",
        "{",
        "// check version of EvtLink",
        "throw",
        "new",
        "Error",
        "(",
        "\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\"",
        ")",
        ";",
        "}",
        "let",
        "segmentsBytesRaw",
        "=",
        "new",
        "Buffer",
        "(",
        "segmentsBytes",
        ".",
        "length",
        "-",
        "2",
        ")",
        ";",
        "segmentsBytes",
        ".",
        "copy",
        "(",
        "segmentsBytesRaw",
        ",",
        "0",
        ",",
        "2",
        ",",
        "segmentsBytes",
        ".",
        "length",
        ")",
        ";",
        "let",
        "publicKeys",
        "=",
        "[",
        "]",
        ";",
        "let",
        "signatures",
        "=",
        "[",
        "]",
        ";",
        "if",
        "(",
        "textSplited",
        "[",
        "1",
        "]",
        ")",
        "{",
        "let",
        "buf",
        "=",
        "EvtLink",
        ".",
        "dec2b",
        "(",
        "textSplited",
        "[",
        "1",
        "]",
        ")",
        ";",
        "let",
        "i",
        "=",
        "0",
        ";",
        "if",
        "(",
        "buf",
        ".",
        "length",
        "%",
        "65",
        "!==",
        "0",
        ")",
        "{",
        "throw",
        "new",
        "Error",
        "(",
        "\"length of signature is invalid\"",
        ")",
        ";",
        "}",
        "while",
        "(",
        "i",
        "*",
        "65",
        "<",
        "buf",
        ".",
        "length",
        ")",
        "{",
        "let",
        "current",
        "=",
        "new",
        "Buffer",
        "(",
        "65",
        ")",
        ";",
        "buf",
        ".",
        "copy",
        "(",
        "current",
        ",",
        "0",
        ",",
        "i",
        "*",
        "65",
        ",",
        "i",
        "*",
        "65",
        "+",
        "65",
        ")",
        ";",
        "let",
        "signature",
        "=",
        "ecc",
        ".",
        "Signature",
        ".",
        "fromBuffer",
        "(",
        "current",
        ")",
        ";",
        "signatures",
        ".",
        "push",
        "(",
        "signature",
        ".",
        "toString",
        "(",
        ")",
        ")",
        ";",
        "if",
        "(",
        "!",
        "options",
        "||",
        "options",
        ".",
        "recoverPublicKeys",
        ")",
        "{",
        "publicKeys",
        ".",
        "push",
        "(",
        "signature",
        ".",
        "recover",
        "(",
        "segmentsBytes",
        ")",
        ".",
        "toString",
        "(",
        ")",
        ")",
        ";",
        "}",
        "++",
        "i",
        ";",
        "}",
        "}",
        "return",
        "{",
        "flag",
        ",",
        "segments",
        ":",
        "parseSegments",
        "(",
        "segmentsBytesRaw",
        ")",
        ",",
        "publicKeys",
        ",",
        "signatures",
        "}",
        ";",
        "}"
      ],
      "docstring": "Parse a everiToken's QRCode Text\n@param {string} text",
      "docstring_tokens": [
        "Parse",
        "a",
        "everiToken",
        "s",
        "QRCode",
        "Text"
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L211-L263"
    },
    "target": "Parse a everiToken s QRCode Text",
    "arguments": [
      [
        "function parseQRCode ( text , options ) { if ( text . length < 3 || text . length > 2000 ) throw new Error ( \"Invalid length of EvtLink\" ) ; let textSplited = text . split ( \"_\" ) ; if ( textSplited . length > 2 ) return null ; let rawText ; if ( textSplited [ 0 ] . startsWith ( qrPrefix ) ) { rawText = textSplited [ 0 ] . substr ( qrPrefix . length ) ; } else { rawText = textSplited [ 0 ] ; } // decode segments base42 let segmentsBytes = EvtLink . dec2b ( rawText ) ; if ( segmentsBytes . length < 2 ) throw new Error ( \"no flag in segment\" ) ; let flag = segmentsBytes . readInt16BE ( 0 ) ; if ( ( flag & 1 ) == 0 ) { // check version of EvtLink throw new Error ( \"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\" ) ; } let segmentsBytesRaw = new Buffer ( segmentsBytes . length - 2 ) ; segmentsBytes . copy ( segmentsBytesRaw , 0 , 2 , segmentsBytes . length ) ; let publicKeys = [ ] ; let signatures = [ ] ; if ( textSplited [ 1 ] ) { let buf = EvtLink . dec2b ( textSplited [ 1 ] ) ; let i = 0 ; if ( buf . length % 65 !== 0 ) { throw new Error ( \"length of signature is invalid\" ) ; } while ( i * 65 < buf . length ) { let current = new Buffer ( 65 ) ; buf . copy ( current , 0 , i * 65 , i * 65 + 65 ) ; let signature = ecc . Signature . fromBuffer ( current ) ; signatures . push ( signature . toString ( ) ) ; if ( ! options || options . recoverPublicKeys ) { publicKeys . push ( signature . recover ( segmentsBytes ) . toString ( ) ) ; } ++ i ; } } return { flag , segments : parseSegments ( segmentsBytesRaw ) , publicKeys , signatures } ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function parseSegments ( segmentsBytes ) { let segments = [ ] ; let i = 0 ; while ( i * 65 < segmentsBytes. length ) { let current = new Buffer ( 65 ) ; segmentsBytes. copy ( current, 0, i * 65, i * 65 + 65 ) ; let segment = ecc. Segment. fromBuffer ( current ) ; segments. push ( segment. toString ( ) ) ; ++ i ; } return segments ; } function EvtLink ( flag, segments, publicKeys, signatures ) { this. flag = flag ; this. segments = segments ; this. publicKeys = publicKeys ; this. signatures = signatures ; } EvtLink. dec2b = function ( text ) { let result = new Buffer ( 0 ) ; for ( let i = 0 ; i < text. length ; ++ i ) { let c = text. charCodeAt ( i ) ; if ( c >= 48 && c <= 57 ) { result. writeUInt8 ( c - 48, result. length ) ; } else if ( c >= 65 && c <= 90 ) { result. writeUInt8 ( c - 55, result."
      ]
    ],
    "filtered_resps": [
      " function parseSegments ( segmentsBytes ) { let segments = [ ] ; let i = 0 ; while ( i * 65 < segmentsBytes. length ) { let current = new Buffer ( 65 ) ; segmentsBytes. copy ( current, 0, i * 65, i * 65 + 65 ) ; let segment = ecc. Segment. fromBuffer ( current ) ; segments. push ( segment. toString ( ) ) ; ++ i ; } return segments ; } function EvtLink ( flag, segments, publicKeys, signatures ) { this. flag = flag ; this. segments = segments ; this. publicKeys = publicKeys ; this. signatures = signatures ; } EvtLink. dec2b = function ( text ) { let result = new Buffer ( 0 ) ; for ( let i = 0 ; i < text. length ; ++ i ) { let c = text. charCodeAt ( i ) ; if ( c >= 48 && c <= 57 ) { result. writeUInt8 ( c - 48, result. length ) ; } else if ( c >= 65 && c <= 90 ) { result. writeUInt8 ( c - 55, result."
    ],
    "smoothed_bleu_4": 0.44793142464494146
  },
  {
    "doc_id": 15,
    "doc": {
      "id": 15,
      "repo": "everitoken/evtjs",
      "path": "src/evtLink.js",
      "func_name": "__calcKeyProvider",
      "original_string": "async function __calcKeyProvider(keyProvider) {\n    if (!keyProvider) { return []; }\n\n    // if keyProvider is function\n    if (keyProvider.apply && keyProvider.call) {\n        keyProvider = keyProvider();\n    }\n\n    // resolve for Promise\n    keyProvider = await Promise.resolve(keyProvider);\n\n    if (!Array.isArray(keyProvider)) {\n        keyProvider = [ keyProvider ];\n    }\n\n    for (let key of keyProvider) {\n        if (!EvtKey.isValidPrivateKey(key)) {\n            throw new Error(\"Invalid private key\");\n        }\n    }\n\n    return keyProvider;\n}",
      "language": "javascript",
      "code": "async function __calcKeyProvider(keyProvider) {\n    if (!keyProvider) { return []; }\n\n    // if keyProvider is function\n    if (keyProvider.apply && keyProvider.call) {\n        keyProvider = keyProvider();\n    }\n\n    // resolve for Promise\n    keyProvider = await Promise.resolve(keyProvider);\n\n    if (!Array.isArray(keyProvider)) {\n        keyProvider = [ keyProvider ];\n    }\n\n    for (let key of keyProvider) {\n        if (!EvtKey.isValidPrivateKey(key)) {\n            throw new Error(\"Invalid private key\");\n        }\n    }\n\n    return keyProvider;\n}",
      "code_tokens": [
        "async",
        "function",
        "__calcKeyProvider",
        "(",
        "keyProvider",
        ")",
        "{",
        "if",
        "(",
        "!",
        "keyProvider",
        ")",
        "{",
        "return",
        "[",
        "]",
        ";",
        "}",
        "// if keyProvider is function",
        "if",
        "(",
        "keyProvider",
        ".",
        "apply",
        "&&",
        "keyProvider",
        ".",
        "call",
        ")",
        "{",
        "keyProvider",
        "=",
        "keyProvider",
        "(",
        ")",
        ";",
        "}",
        "// resolve for Promise",
        "keyProvider",
        "=",
        "await",
        "Promise",
        ".",
        "resolve",
        "(",
        "keyProvider",
        ")",
        ";",
        "if",
        "(",
        "!",
        "Array",
        ".",
        "isArray",
        "(",
        "keyProvider",
        ")",
        ")",
        "{",
        "keyProvider",
        "=",
        "[",
        "keyProvider",
        "]",
        ";",
        "}",
        "for",
        "(",
        "let",
        "key",
        "of",
        "keyProvider",
        ")",
        "{",
        "if",
        "(",
        "!",
        "EvtKey",
        ".",
        "isValidPrivateKey",
        "(",
        "key",
        ")",
        ")",
        "{",
        "throw",
        "new",
        "Error",
        "(",
        "\"Invalid private key\"",
        ")",
        ";",
        "}",
        "}",
        "return",
        "keyProvider",
        ";",
        "}"
      ],
      "docstring": "Calculate the value of keyProvider\n@param {string | string[] | function} keyProvider\n@returns {string[]}",
      "docstring_tokens": [
        "Calculate",
        "the",
        "value",
        "of",
        "keyProvider"
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L270-L292"
    },
    "target": "Calculate the value of keyProvider",
    "arguments": [
      [
        "async function __calcKeyProvider ( keyProvider ) { if ( ! keyProvider ) { return [ ] ; } // if keyProvider is function if ( keyProvider . apply && keyProvider . call ) { keyProvider = keyProvider ( ) ; } // resolve for Promise keyProvider = await Promise . resolve ( keyProvider ) ; if ( ! Array . isArray ( keyProvider ) ) { keyProvider = [ keyProvider ] ; } for ( let key of keyProvider ) { if ( ! EvtKey . isValidPrivateKey ( key ) ) { throw new Error ( \"Invalid private key\" ) ; } } return keyProvider ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export { __calcKeyProvider as calcKeyProvider } ;\n```\n\nThis code defines a function `calcKeyProvider` that takes a `keyProvider` argument and returns an array of valid private keys. The function first checks if `keyProvider` is falsy, in which case it returns an empty array. If `keyProvider` is a function, it calls the function to get the actual key provider. If `keyProvider` is a Promise, it resolves the Promise to get the actual key provider. If `keyProvider` is not an array, it wraps it in an array. Finally, it checks each key in the array to ensure it is a valid private key using the `EvtKey.isValidPrivateKey` method. If any key is invalid, it throws an error. If all keys are valid, it returns the array of keys.\n\nNote that this code assumes that `EvtKey.isValidPrivateKey` is a function that takes a private key as an argument and returns a boolean indicating whether the key is valid. The implementation of this function is not shown in this code snippet. \n\nAlso, this code does not handle the case where `keyProvider` is an object with a `then` method, which would indicate that it is a"
      ]
    ],
    "filtered_resps": [
      " export { __calcKeyProvider as calcKeyProvider } ;\n```\n\nThis code defines a function `calcKeyProvider` that takes a `keyProvider` argument and returns an array of valid private keys. The function first checks if `keyProvider` is falsy, in which case it returns an empty array. If `keyProvider` is a function, it calls the function to get the actual key provider. If `keyProvider` is a Promise, it resolves the Promise to get the actual key provider. If `keyProvider` is not an array, it wraps it in an array. Finally, it checks each key in the array to ensure it is a valid private key using the `EvtKey.isValidPrivateKey` method. If any key is invalid, it throws an error. If all keys are valid, it returns the array of keys.\n\nNote that this code assumes that `EvtKey.isValidPrivateKey` is a function that takes a private key as an argument and returns a boolean indicating whether the key is valid. The implementation of this function is not shown in this code snippet. \n\nAlso, this code does not handle the case where `keyProvider` is an object with a `then` method, which would indicate that it is a"
    ],
    "smoothed_bleu_4": 0.5594398287293577
  },
  {
    "doc_id": 16,
    "doc": {
      "id": 16,
      "repo": "everitoken/evtjs",
      "path": "src/ecc/key_utils.js",
      "func_name": "random32ByteBuffer",
      "original_string": "function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\n\n    if(safe) {\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\n    }\n\n    // if(entropyCount > 0) {\n    //     console.log(`Additional private key entropy: ${entropyCount} events`)\n    // }\n\n    const hash_array = [];\n    hash_array.push(randomBytes(32));\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\n    hash_array.push(externalEntropyArray);\n    hash_array.push(browserEntropy());\n    return hash.sha256(Buffer.concat(hash_array));\n}",
      "language": "javascript",
      "code": "function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\n\n    if(safe) {\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\n    }\n\n    // if(entropyCount > 0) {\n    //     console.log(`Additional private key entropy: ${entropyCount} events`)\n    // }\n\n    const hash_array = [];\n    hash_array.push(randomBytes(32));\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\n    hash_array.push(externalEntropyArray);\n    hash_array.push(browserEntropy());\n    return hash.sha256(Buffer.concat(hash_array));\n}",
      "code_tokens": [
        "function",
        "random32ByteBuffer",
        "(",
        "{",
        "cpuEntropyBits",
        "=",
        "0",
        ",",
        "safe",
        "=",
        "true",
        "}",
        "=",
        "{",
        "}",
        ")",
        "{",
        "assert",
        ".",
        "equal",
        "(",
        "typeof",
        "cpuEntropyBits",
        ",",
        "\"number\"",
        ",",
        "\"cpuEntropyBits\"",
        ")",
        ";",
        "assert",
        ".",
        "equal",
        "(",
        "typeof",
        "safe",
        ",",
        "\"boolean\"",
        ",",
        "\"boolean\"",
        ")",
        ";",
        "if",
        "(",
        "safe",
        ")",
        "{",
        "assert",
        "(",
        "entropyCount",
        ">=",
        "128",
        ",",
        "\"Call initialize() to add entropy (current: \"",
        "+",
        "entropyCount",
        "+",
        "\")\"",
        ")",
        ";",
        "}",
        "// if(entropyCount > 0) {",
        "//     console.log(`Additional private key entropy: ${entropyCount} events`)",
        "// }",
        "const",
        "hash_array",
        "=",
        "[",
        "]",
        ";",
        "hash_array",
        ".",
        "push",
        "(",
        "randomBytes",
        "(",
        "32",
        ")",
        ")",
        ";",
        "hash_array",
        ".",
        "push",
        "(",
        "Buffer",
        ".",
        "from",
        "(",
        "cpuEntropy",
        "(",
        "cpuEntropyBits",
        ")",
        ")",
        ")",
        ";",
        "hash_array",
        ".",
        "push",
        "(",
        "externalEntropyArray",
        ")",
        ";",
        "hash_array",
        ".",
        "push",
        "(",
        "browserEntropy",
        "(",
        ")",
        ")",
        ";",
        "return",
        "hash",
        ".",
        "sha256",
        "(",
        "Buffer",
        ".",
        "concat",
        "(",
        "hash_array",
        ")",
        ")",
        ";",
        "}"
      ],
      "docstring": "Additional forms of entropy are used.  A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.\n\n@arg {number} [cpuEntropyBits = 0] generate entropy on the fly.  This is\nnot required, entropy can be added in advanced via addEntropy or initialize().\n\n@arg {boolean} [safe = true] false for testing, otherwise this will be\ntrue to ensure initialize() was called.\n\n@return a random buffer obtained from the secure random number generator.  Additional entropy is used.",
      "docstring_tokens": [
        "Additional",
        "forms",
        "of",
        "entropy",
        "are",
        "used",
        ".",
        "A",
        "week",
        "random",
        "number",
        "generator",
        "can",
        "run",
        "out",
        "of",
        "entropy",
        ".",
        "This",
        "should",
        "ensure",
        "even",
        "the",
        "worst",
        "random",
        "number",
        "implementation",
        "will",
        "be",
        "reasonably",
        "safe",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_utils.js#L32-L50"
    },
    "target": "Additional forms of entropy are used . A week random number generator can run out of entropy . This should ensure even the worst random number implementation will be reasonably safe .",
    "arguments": [
      [
        "function random32ByteBuffer ( { cpuEntropyBits = 0 , safe = true } = { } ) { assert . equal ( typeof cpuEntropyBits , \"number\" , \"cpuEntropyBits\" ) ; assert . equal ( typeof safe , \"boolean\" , \"boolean\" ) ; if ( safe ) { assert ( entropyCount >= 128 , \"Call initialize() to add entropy (current: \" + entropyCount + \")\" ) ; } // if(entropyCount > 0) { // console.log(`Additional private key entropy: ${entropyCount} events`) // } const hash_array = [ ] ; hash_array . push ( randomBytes ( 32 ) ) ; hash_array . push ( Buffer . from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array . push ( externalEntropyArray ) ; hash_array . push ( browserEntropy ( ) ) ; return hash . sha256 ( Buffer . concat ( hash_array ) ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function random32Buffer ( { cpuEntropyBits = 0, safe = true } = { } ) { assert. equal ( typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\" ) ; assert. equal ( typeof safe, \"boolean\", \"boolean\" ) ; if ( safe ) { assert ( entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\" ) ; } // if(entropyCount > 0) { // console.log(`Additional private key entropy: ${entropyCount} events`) // } const hash_array = [ ] ; hash_array. push ( randomBytes ( 32 ) ) ; hash_array. push ( Buffer. from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array. push ( externalEntropyArray ) ; hash_array. push ( browserEntropy ( ) ) ; return Buffer. from ( hash. sha256 ( Buffer. concat ( hash_array ) ) ) ; } function random32 ( { cpuEntropyBits = 0, safe = true } = { } ) { assert. equal ( typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\" ) ; assert. equal ( typeof safe, \"boolean\","
      ]
    ],
    "filtered_resps": [
      " function random32Buffer ( { cpuEntropyBits = 0, safe = true } = { } ) { assert. equal ( typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\" ) ; assert. equal ( typeof safe, \"boolean\", \"boolean\" ) ; if ( safe ) { assert ( entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\" ) ; } // if(entropyCount > 0) { // console.log(`Additional private key entropy: ${entropyCount} events`) // } const hash_array = [ ] ; hash_array. push ( randomBytes ( 32 ) ) ; hash_array. push ( Buffer. from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array. push ( externalEntropyArray ) ; hash_array. push ( browserEntropy ( ) ) ; return Buffer. from ( hash. sha256 ( Buffer. concat ( hash_array ) ) ) ; } function random32 ( { cpuEntropyBits = 0, safe = true } = { } ) { assert. equal ( typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\" ) ; assert. equal ( typeof safe, \"boolean\","
    ],
    "smoothed_bleu_4": 0.7394073300773624
  },
  {
    "doc_id": 17,
    "doc": {
      "id": 17,
      "repo": "everitoken/evtjs",
      "path": "src/ecc/key_utils.js",
      "func_name": "addEntropy",
      "original_string": "function addEntropy(...ints) {\n    assert.equal(externalEntropyArray.length, 101, \"externalEntropyArray\");\n\n    entropyCount += ints.length;\n    for(const i of ints) {\n        const pos = entropyPos++ % 101;\n        const i2 = externalEntropyArray[pos] += i;\n        if(i2 > 9007199254740991)\n            externalEntropyArray[pos] = 0;\n    }\n}",
      "language": "javascript",
      "code": "function addEntropy(...ints) {\n    assert.equal(externalEntropyArray.length, 101, \"externalEntropyArray\");\n\n    entropyCount += ints.length;\n    for(const i of ints) {\n        const pos = entropyPos++ % 101;\n        const i2 = externalEntropyArray[pos] += i;\n        if(i2 > 9007199254740991)\n            externalEntropyArray[pos] = 0;\n    }\n}",
      "code_tokens": [
        "function",
        "addEntropy",
        "(",
        "...",
        "ints",
        ")",
        "{",
        "assert",
        ".",
        "equal",
        "(",
        "externalEntropyArray",
        ".",
        "length",
        ",",
        "101",
        ",",
        "\"externalEntropyArray\"",
        ")",
        ";",
        "entropyCount",
        "+=",
        "ints",
        ".",
        "length",
        ";",
        "for",
        "(",
        "const",
        "i",
        "of",
        "ints",
        ")",
        "{",
        "const",
        "pos",
        "=",
        "entropyPos",
        "++",
        "%",
        "101",
        ";",
        "const",
        "i2",
        "=",
        "externalEntropyArray",
        "[",
        "pos",
        "]",
        "+=",
        "i",
        ";",
        "if",
        "(",
        "i2",
        ">",
        "9007199254740991",
        ")",
        "externalEntropyArray",
        "[",
        "pos",
        "]",
        "=",
        "0",
        ";",
        "}",
        "}"
      ],
      "docstring": "Adds entropy.  This may be called many times while the amount of data saved\nis accumulatively reduced to 101 integers.  Data is retained in RAM for the\nlife of this module.\n\n@example React <code>\ncomponentDidMount() {\nthis.refs.MyComponent.addEventListener(\"mousemove\", this.onEntropyEvent, {capture: false, passive: true})\n}\ncomponentWillUnmount() {\nthis.refs.MyComponent.removeEventListener(\"mousemove\", this.onEntropyEvent);\n}\nonEntropyEvent = (e) => {\nif(e.type === 'mousemove')\nkey_utils.addEntropy(e.pageX, e.pageY, e.screenX, e.screenY)\nelse\nconsole.log('onEntropyEvent Unknown', e.type, e)\n}\n</code>",
      "docstring_tokens": [
        "Adds",
        "entropy",
        ".",
        "This",
        "may",
        "be",
        "called",
        "many",
        "times",
        "while",
        "the",
        "amount",
        "of",
        "data",
        "saved",
        "is",
        "accumulatively",
        "reduced",
        "to",
        "101",
        "integers",
        ".",
        "Data",
        "is",
        "retained",
        "in",
        "RAM",
        "for",
        "the",
        "life",
        "of",
        "this",
        "module",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_utils.js#L72-L82"
    },
    "target": "Adds entropy . This may be called many times while the amount of data saved is accumulatively reduced to 101 integers . Data is retained in RAM for the life of this module .",
    "arguments": [
      [
        "function addEntropy ( ... ints ) { assert . equal ( externalEntropyArray . length , 101 , \"externalEntropyArray\" ) ; entropyCount += ints . length ; for ( const i of ints ) { const pos = entropyPos ++ % 101 ; const i2 = externalEntropyArray [ pos ] += i ; if ( i2 > 9007199254740991 ) externalEntropyArray [ pos ] = 0 ; } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ```\n  - ``` const   externalEntropyArray   =   new   Uint32Array ( 101 ) ; let   entropyCount   =   0 ; let   entropyPos   =   0 ; function   addEntropy (... ints )   {   assert. equal ( externalEntropyArray. length,   101,   \"externalEntropyArray\" ) ;   entropyCount   +=   ints. length ;   for   ( const   i   of   ints )   {   const   pos   =   entropyPos ++   %   101 ;   const   i2   =   externalEntropyArray [ pos ]   +=   i ;   if   ( i2   >   9007199254740991 )   externalEntropyArray [ pos ]   =   0 ;   }   } ```\n  - ``` const   externalEntropyArray   =   new   Uint32Array ( 101 ) ; let   entropyCount   =   0 ; let   entropyPos   =   0 ; function   addEntropy (... ints )   {   assert. equal ( externalEntropyArray. length,   101,   \"externalEntropyArray\" ) ;   entropyCount   +=   ints"
      ]
    ],
    "filtered_resps": [
      " ```\n  - ``` const   externalEntropyArray   =   new   Uint32Array ( 101 ) ; let   entropyCount   =   0 ; let   entropyPos   =   0 ; function   addEntropy (... ints )   {   assert. equal ( externalEntropyArray. length,   101,   \"externalEntropyArray\" ) ;   entropyCount   +=   ints. length ;   for   ( const   i   of   ints )   {   const   pos   =   entropyPos ++   %   101 ;   const   i2   =   externalEntropyArray [ pos ]   +=   i ;   if   ( i2   >   9007199254740991 )   externalEntropyArray [ pos ]   =   0 ;   }   } ```\n  - ``` const   externalEntropyArray   =   new   Uint32Array ( 101 ) ; let   entropyCount   =   0 ; let   entropyPos   =   0 ; function   addEntropy (... ints )   {   assert. equal ( externalEntropyArray. length,   101,   \"externalEntropyArray\" ) ;   entropyCount   +=   ints"
    ],
    "smoothed_bleu_4": 1.0212773436572402
  },
  {
    "doc_id": 18,
    "doc": {
      "id": 18,
      "repo": "everitoken/evtjs",
      "path": "src/ecc/key_utils.js",
      "func_name": "cpuEntropy",
      "original_string": "function cpuEntropy(cpuEntropyBits = 128) {\n    let collected = [];\n    let lastCount = null;\n    let lowEntropySamples = 0;\n    while(collected.length < cpuEntropyBits) {\n        const count = floatingPointCount();\n        if(lastCount != null) {\n            const delta = count - lastCount;\n            if(Math.abs(delta) < 1) {\n                lowEntropySamples++;\n                continue;\n            }\n            // how many bits of entropy were in this sample\n            const bits = Math.floor(log2(Math.abs(delta)) + 1);\n            if(bits < 4) {\n                if(bits < 2) {\n                    lowEntropySamples++;\n                }\n                continue;\n            }\n            collected.push(delta);\n        }\n        lastCount = count;\n    }\n    if(lowEntropySamples > 10) {\n        const pct = Number(lowEntropySamples / cpuEntropyBits * 100).toFixed(2);\n        // Is this algorithm getting inefficient?\n        console.warn(`WARN: ${pct}% low CPU entropy re-sampled`);\n    }\n    return collected;\n}",
      "language": "javascript",
      "code": "function cpuEntropy(cpuEntropyBits = 128) {\n    let collected = [];\n    let lastCount = null;\n    let lowEntropySamples = 0;\n    while(collected.length < cpuEntropyBits) {\n        const count = floatingPointCount();\n        if(lastCount != null) {\n            const delta = count - lastCount;\n            if(Math.abs(delta) < 1) {\n                lowEntropySamples++;\n                continue;\n            }\n            // how many bits of entropy were in this sample\n            const bits = Math.floor(log2(Math.abs(delta)) + 1);\n            if(bits < 4) {\n                if(bits < 2) {\n                    lowEntropySamples++;\n                }\n                continue;\n            }\n            collected.push(delta);\n        }\n        lastCount = count;\n    }\n    if(lowEntropySamples > 10) {\n        const pct = Number(lowEntropySamples / cpuEntropyBits * 100).toFixed(2);\n        // Is this algorithm getting inefficient?\n        console.warn(`WARN: ${pct}% low CPU entropy re-sampled`);\n    }\n    return collected;\n}",
      "code_tokens": [
        "function",
        "cpuEntropy",
        "(",
        "cpuEntropyBits",
        "=",
        "128",
        ")",
        "{",
        "let",
        "collected",
        "=",
        "[",
        "]",
        ";",
        "let",
        "lastCount",
        "=",
        "null",
        ";",
        "let",
        "lowEntropySamples",
        "=",
        "0",
        ";",
        "while",
        "(",
        "collected",
        ".",
        "length",
        "<",
        "cpuEntropyBits",
        ")",
        "{",
        "const",
        "count",
        "=",
        "floatingPointCount",
        "(",
        ")",
        ";",
        "if",
        "(",
        "lastCount",
        "!=",
        "null",
        ")",
        "{",
        "const",
        "delta",
        "=",
        "count",
        "-",
        "lastCount",
        ";",
        "if",
        "(",
        "Math",
        ".",
        "abs",
        "(",
        "delta",
        ")",
        "<",
        "1",
        ")",
        "{",
        "lowEntropySamples",
        "++",
        ";",
        "continue",
        ";",
        "}",
        "// how many bits of entropy were in this sample",
        "const",
        "bits",
        "=",
        "Math",
        ".",
        "floor",
        "(",
        "log2",
        "(",
        "Math",
        ".",
        "abs",
        "(",
        "delta",
        ")",
        ")",
        "+",
        "1",
        ")",
        ";",
        "if",
        "(",
        "bits",
        "<",
        "4",
        ")",
        "{",
        "if",
        "(",
        "bits",
        "<",
        "2",
        ")",
        "{",
        "lowEntropySamples",
        "++",
        ";",
        "}",
        "continue",
        ";",
        "}",
        "collected",
        ".",
        "push",
        "(",
        "delta",
        ")",
        ";",
        "}",
        "lastCount",
        "=",
        "count",
        ";",
        "}",
        "if",
        "(",
        "lowEntropySamples",
        ">",
        "10",
        ")",
        "{",
        "const",
        "pct",
        "=",
        "Number",
        "(",
        "lowEntropySamples",
        "/",
        "cpuEntropyBits",
        "*",
        "100",
        ")",
        ".",
        "toFixed",
        "(",
        "2",
        ")",
        ";",
        "// Is this algorithm getting inefficient?",
        "console",
        ".",
        "warn",
        "(",
        "`",
        "${",
        "pct",
        "}",
        "`",
        ")",
        ";",
        "}",
        "return",
        "collected",
        ";",
        "}"
      ],
      "docstring": "This runs in just under 1 second and ensures a minimum of cpuEntropyBits\nbits of entropy are gathered.\n\nBased on more-entropy. @see https://github.com/keybase/more-entropy/blob/master/src/generator.iced\n\n@arg {number} [cpuEntropyBits = 128]\n@return {array} counts gathered by measuring variations in the CPU speed during floating point operations.",
      "docstring_tokens": [
        "This",
        "runs",
        "in",
        "just",
        "under",
        "1",
        "second",
        "and",
        "ensures",
        "a",
        "minimum",
        "of",
        "cpuEntropyBits",
        "bits",
        "of",
        "entropy",
        "are",
        "gathered",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_utils.js#L93-L123"
    },
    "target": "This runs in just under 1 second and ensures a minimum of cpuEntropyBits bits of entropy are gathered .",
    "arguments": [
      [
        "function cpuEntropy ( cpuEntropyBits = 128 ) { let collected = [ ] ; let lastCount = null ; let lowEntropySamples = 0 ; while ( collected . length < cpuEntropyBits ) { const count = floatingPointCount ( ) ; if ( lastCount != null ) { const delta = count - lastCount ; if ( Math . abs ( delta ) < 1 ) { lowEntropySamples ++ ; continue ; } // how many bits of entropy were in this sample const bits = Math . floor ( log2 ( Math . abs ( delta ) ) + 1 ) ; if ( bits < 4 ) { if ( bits < 2 ) { lowEntropySamples ++ ; } continue ; } collected . push ( delta ) ; } lastCount = count ; } if ( lowEntropySamples > 10 ) { const pct = Number ( lowEntropySamples / cpuEntropyBits * 100 ) . toFixed ( 2 ) ; // Is this algorithm getting inefficient? console . warn ( ` ${ pct } ` ) ; } return collected ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function floatingPointCount ( ) { const sample = Math. random ( ) * 2 - 1 ; let count = 0 ; while ( sample!= 0 ) { sample *= sample ; count ++ ; } return count ; } function log2 ( x ) { return Math. log ( x ) / Math. log ( 2 ) ; } ``` This code uses the floating-point representation of numbers to generate a sequence of random numbers, which are then used to estimate the entropy of the system. The `cpuEntropy` function takes an optional argument `cpuEntropyBits`, which specifies the number of bits of entropy to collect. The function returns an array of numbers, where each number represents the number of bits of entropy in a single sample. The `floatingPointCount` function generates a random floating-point number between -1 and 1, and then repeatedly multiplies it by itself until it reaches zero. The number of multiplications required to reach zero is used as a measure of the number of bits of entropy in the sample. The `log2` function is used to calculate the base-2 logarithm of a number. The code also includes a warning message if the algorithm appears to be getting inefficient, as measured by the percentage"
      ]
    ],
    "filtered_resps": [
      " function floatingPointCount ( ) { const sample = Math. random ( ) * 2 - 1 ; let count = 0 ; while ( sample!= 0 ) { sample *= sample ; count ++ ; } return count ; } function log2 ( x ) { return Math. log ( x ) / Math. log ( 2 ) ; } ``` This code uses the floating-point representation of numbers to generate a sequence of random numbers, which are then used to estimate the entropy of the system. The `cpuEntropy` function takes an optional argument `cpuEntropyBits`, which specifies the number of bits of entropy to collect. The function returns an array of numbers, where each number represents the number of bits of entropy in a single sample. The `floatingPointCount` function generates a random floating-point number between -1 and 1, and then repeatedly multiplies it by itself until it reaches zero. The number of multiplications required to reach zero is used as a measure of the number of bits of entropy in the sample. The `log2` function is used to calculate the base-2 logarithm of a number. The code also includes a warning message if the algorithm appears to be getting inefficient, as measured by the percentage"
    ],
    "smoothed_bleu_4": 1.2175415438733521
  },
  {
    "doc_id": 19,
    "doc": {
      "id": 19,
      "repo": "everitoken/evtjs",
      "path": "src/ecc/aes.js",
      "func_name": "cryptoJsDecrypt",
      "original_string": "function cryptoJsDecrypt(message, key, iv) {\n    assert(message, \"Missing cipher text\");\n    message = toBinaryBuffer(message);\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n    // decipher.setAutoPadding(true)\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\n    return message;\n}",
      "language": "javascript",
      "code": "function cryptoJsDecrypt(message, key, iv) {\n    assert(message, \"Missing cipher text\");\n    message = toBinaryBuffer(message);\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n    // decipher.setAutoPadding(true)\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\n    return message;\n}",
      "code_tokens": [
        "function",
        "cryptoJsDecrypt",
        "(",
        "message",
        ",",
        "key",
        ",",
        "iv",
        ")",
        "{",
        "assert",
        "(",
        "message",
        ",",
        "\"Missing cipher text\"",
        ")",
        ";",
        "message",
        "=",
        "toBinaryBuffer",
        "(",
        "message",
        ")",
        ";",
        "const",
        "decipher",
        "=",
        "crypto",
        ".",
        "createDecipheriv",
        "(",
        "\"aes-256-cbc\"",
        ",",
        "key",
        ",",
        "iv",
        ")",
        ";",
        "// decipher.setAutoPadding(true)",
        "message",
        "=",
        "Buffer",
        ".",
        "concat",
        "(",
        "[",
        "decipher",
        ".",
        "update",
        "(",
        "message",
        ")",
        ",",
        "decipher",
        ".",
        "final",
        "(",
        ")",
        "]",
        ")",
        ";",
        "return",
        "message",
        ";",
        "}"
      ],
      "docstring": "This method does not use a checksum, the returned data must be validated some other way.\n\n@arg {string|Buffer} message - ciphertext binary format\n@arg {string<utf8>|Buffer} key - 256bit\n@arg {string<utf8>|Buffer} iv - 128bit\n\n@return {Buffer}",
      "docstring_tokens": [
        "This",
        "method",
        "does",
        "not",
        "use",
        "a",
        "checksum",
        "the",
        "returned",
        "data",
        "must",
        "be",
        "validated",
        "some",
        "other",
        "way",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/aes.js#L122-L129"
    },
    "target": "This method does not use a checksum the returned data must be validated some other way .",
    "arguments": [
      [
        "function cryptoJsDecrypt ( message , key , iv ) { assert ( message , \"Missing cipher text\" ) ; message = toBinaryBuffer ( message ) ; const decipher = crypto . createDecipheriv ( \"aes-256-cbc\" , key , iv ) ; // decipher.setAutoPadding(true) message = Buffer . concat ( [ decipher . update ( message ) , decipher . final ( ) ] ) ; return message ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function cryptoJsEncrypt ( message, key, iv ) { assert ( message, \"Missing cipher text\" ) ; message = toBinaryBuffer ( message ) ; const cipher = crypto. createCipheriv ( \"aes-256-cbc\", key, iv ) ; // cipher.setAutoPadding(true) message = Buffer. concat ( [ cipher. update ( message ), cipher. final ( ) ] ) ; return message ; } function toBinaryBuffer ( str ) { return Buffer. from ( str, \"utf8\" ) ; } function toHex ( buffer ) { return buffer. toString ( \"hex\" ) ; } function toBase64 ( buffer ) { return buffer. toString ( \"base64\" ) ; } function fromHex ( hex ) { return Buffer. from ( hex, \"hex\" ) ; } function fromBase64 ( base64 ) { return Buffer. from ( base64, \"base64\" ) ; } function assert ( value, message ) { if (! value ) { throw new Error ( message ) ; } } module. exports = { cryptoJsEncrypt, cryptoJsDecrypt } ; ``` This code defines two functions, `cryptoJsEncrypt` and `cryptoJsDecrypt`, which implement the encryption and"
      ]
    ],
    "filtered_resps": [
      " function cryptoJsEncrypt ( message, key, iv ) { assert ( message, \"Missing cipher text\" ) ; message = toBinaryBuffer ( message ) ; const cipher = crypto. createCipheriv ( \"aes-256-cbc\", key, iv ) ; // cipher.setAutoPadding(true) message = Buffer. concat ( [ cipher. update ( message ), cipher. final ( ) ] ) ; return message ; } function toBinaryBuffer ( str ) { return Buffer. from ( str, \"utf8\" ) ; } function toHex ( buffer ) { return buffer. toString ( \"hex\" ) ; } function toBase64 ( buffer ) { return buffer. toString ( \"base64\" ) ; } function fromHex ( hex ) { return Buffer. from ( hex, \"hex\" ) ; } function fromBase64 ( base64 ) { return Buffer. from ( base64, \"base64\" ) ; } function assert ( value, message ) { if (! value ) { throw new Error ( message ) ; } } module. exports = { cryptoJsEncrypt, cryptoJsDecrypt } ; ``` This code defines two functions, `cryptoJsEncrypt` and `cryptoJsDecrypt`, which implement the encryption and"
    ],
    "smoothed_bleu_4": 0.5791343383123296
  },
  {
    "doc_id": 20,
    "doc": {
      "id": 20,
      "repo": "everitoken/evtjs",
      "path": "src/ecc/key_private.js",
      "func_name": "initialize",
      "original_string": "function initialize() {\n    if(initialized) {\n        return;\n    }\n\n    unitTest();\n    keyUtils.addEntropy(...keyUtils.cpuEntropy());\n    assert(keyUtils.entropyCount() >= 128, \"insufficient entropy\");\n\n    initialized = true;\n}",
      "language": "javascript",
      "code": "function initialize() {\n    if(initialized) {\n        return;\n    }\n\n    unitTest();\n    keyUtils.addEntropy(...keyUtils.cpuEntropy());\n    assert(keyUtils.entropyCount() >= 128, \"insufficient entropy\");\n\n    initialized = true;\n}",
      "code_tokens": [
        "function",
        "initialize",
        "(",
        ")",
        "{",
        "if",
        "(",
        "initialized",
        ")",
        "{",
        "return",
        ";",
        "}",
        "unitTest",
        "(",
        ")",
        ";",
        "keyUtils",
        ".",
        "addEntropy",
        "(",
        "...",
        "keyUtils",
        ".",
        "cpuEntropy",
        "(",
        ")",
        ")",
        ";",
        "assert",
        "(",
        "keyUtils",
        ".",
        "entropyCount",
        "(",
        ")",
        ">=",
        "128",
        ",",
        "\"insufficient entropy\"",
        ")",
        ";",
        "initialized",
        "=",
        "true",
        ";",
        "}"
      ],
      "docstring": "Run self-checking code and gather CPU entropy.\n\nInitialization happens once even if called multiple times.\n\n@return {Promise}",
      "docstring_tokens": [
        "Run",
        "self",
        "-",
        "checking",
        "code",
        "and",
        "gather",
        "CPU",
        "entropy",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_private.js#L266-L276"
    },
    "target": "Run self - checking code and gather CPU entropy .",
    "arguments": [
      [
        "function initialize ( ) { if ( initialized ) { return ; } unitTest ( ) ; keyUtils . addEntropy ( ... keyUtils . cpuEntropy ( ) ) ; assert ( keyUtils . entropyCount ( ) >= 128 , \"insufficient entropy\" ) ; initialized = true ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ( function ( ) { initialize ( ) ; } ) ( ) ;\n```\nThis code defines a function `initialize` that checks if the `initialized` flag is set. If it is, the function returns immediately. Otherwise, it calls the `unitTest` function, adds entropy to the key utility using the `cpuEntropy` method, and asserts that the entropy count is at least 128. Finally, it sets the `initialized` flag to `true`.\n\nThe code then defines an immediately invoked function expression (IIFE) that calls the `initialize` function. This ensures that the `initialize` function is called only once, when the code is executed.\n\nNote that this code assumes that the `keyUtils` object and the `unitTest` function are defined elsewhere in the codebase. The `keyUtils` object is expected to have methods `addEntropy`, `cpuEntropy`, and `entropyCount`, and the `unitTest` function is expected to perform some kind of initialization or testing. The `initialized` flag is used to prevent the `initialize` function from being called multiple times.\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n``"
      ]
    ],
    "filtered_resps": [
      " ( function ( ) { initialize ( ) ; } ) ( ) ;\n```\nThis code defines a function `initialize` that checks if the `initialized` flag is set. If it is, the function returns immediately. Otherwise, it calls the `unitTest` function, adds entropy to the key utility using the `cpuEntropy` method, and asserts that the entropy count is at least 128. Finally, it sets the `initialized` flag to `true`.\n\nThe code then defines an immediately invoked function expression (IIFE) that calls the `initialize` function. This ensures that the `initialize` function is called only once, when the code is executed.\n\nNote that this code assumes that the `keyUtils` object and the `unitTest` function are defined elsewhere in the codebase. The `keyUtils` object is expected to have methods `addEntropy`, `cpuEntropy`, and `entropyCount`, and the `unitTest` function is expected to perform some kind of initialization or testing. The `initialized` flag is used to prevent the `initialize` function from being called multiple times.\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n``"
    ],
    "smoothed_bleu_4": 0.5518911116931753
  },
  {
    "doc_id": 21,
    "doc": {
      "id": 21,
      "repo": "everitoken/evtjs",
      "path": "src/bigi/lib/bigi.js",
      "func_name": "montConvert",
      "original_string": "function montConvert(x) {\n  var r = new BigInteger()\n  x.abs()\n    .dlShiftTo(this.m.t, r)\n  r.divRemTo(this.m, null, r)\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)\n  return r\n}",
      "language": "javascript",
      "code": "function montConvert(x) {\n  var r = new BigInteger()\n  x.abs()\n    .dlShiftTo(this.m.t, r)\n  r.divRemTo(this.m, null, r)\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)\n  return r\n}",
      "code_tokens": [
        "function",
        "montConvert",
        "(",
        "x",
        ")",
        "{",
        "var",
        "r",
        "=",
        "new",
        "BigInteger",
        "(",
        ")",
        "x",
        ".",
        "abs",
        "(",
        ")",
        ".",
        "dlShiftTo",
        "(",
        "this",
        ".",
        "m",
        ".",
        "t",
        ",",
        "r",
        ")",
        "r",
        ".",
        "divRemTo",
        "(",
        "this",
        ".",
        "m",
        ",",
        "null",
        ",",
        "r",
        ")",
        "if",
        "(",
        "x",
        ".",
        "s",
        "<",
        "0",
        "&&",
        "r",
        ".",
        "compareTo",
        "(",
        "BigInteger",
        ".",
        "ZERO",
        ")",
        ">",
        "0",
        ")",
        "this",
        ".",
        "m",
        ".",
        "subTo",
        "(",
        "r",
        ",",
        "r",
        ")",
        "return",
        "r",
        "}"
      ],
      "docstring": "xR mod m",
      "docstring_tokens": [
        "xR",
        "mod",
        "m"
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/bigi/lib/bigi.js#L545-L552"
    },
    "target": "xR mod m",
    "arguments": [
      [
        "function montConvert ( x ) { var r = new BigInteger ( ) x . abs ( ) . dlShiftTo ( this . m . t , r ) r . divRemTo ( this . m , null , r ) if ( x . s < 0 && r . compareTo ( BigInteger . ZERO ) > 0 ) this . m . subTo ( r , r ) return r }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function montMultiply ( x, y ) { var r = new BigInteger ( ) x. dlShiftTo ( this. m. t, r ) y. dlShiftTo ( this. m. t, r ) r. mulTo ( this. m, r ) return r } function montSquare ( x ) { var r = new BigInteger ( ) x. dlShiftTo ( this. m. t, r ) r. mulTo ( this. m, r ) return r } function montInvert ( x ) { var r = new BigInteger ( ) x. abs ( ). dlShiftTo ( this. m. t, r ) r. modInverseTo ( this. m, r ) if ( x. s < 0 && r. compareTo ( BigInteger. ZERO ) < 0 ) this. m. subTo ( r, r ) return r } function montMultiplyTo ( x, y, r ) { x. dlShiftTo ( this. m. t, r ) y. dlShiftTo ( this. m. t, r ) r. mulTo ( this. m, r ) } function montSquareTo ( x, r ) { x. dlShiftTo ( this."
      ]
    ],
    "filtered_resps": [
      " function montMultiply ( x, y ) { var r = new BigInteger ( ) x. dlShiftTo ( this. m. t, r ) y. dlShiftTo ( this. m. t, r ) r. mulTo ( this. m, r ) return r } function montSquare ( x ) { var r = new BigInteger ( ) x. dlShiftTo ( this. m. t, r ) r. mulTo ( this. m, r ) return r } function montInvert ( x ) { var r = new BigInteger ( ) x. abs ( ). dlShiftTo ( this. m. t, r ) r. modInverseTo ( this. m, r ) if ( x. s < 0 && r. compareTo ( BigInteger. ZERO ) < 0 ) this. m. subTo ( r, r ) return r } function montMultiplyTo ( x, y, r ) { x. dlShiftTo ( this. m. t, r ) y. dlShiftTo ( this. m. t, r ) r. mulTo ( this. m, r ) } function montSquareTo ( x, r ) { x. dlShiftTo ( this."
    ],
    "smoothed_bleu_4": 0.45403273327598953
  },
  {
    "doc_id": 22,
    "doc": {
      "id": 22,
      "repo": "everitoken/evtjs",
      "path": "src/ecc/signature.js",
      "func_name": "verify",
      "original_string": "function verify(data, pubkey, encoding = \"utf8\") {\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, encoding);\n        }\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\n        data = hash.sha256(data);\n        return verifyHash(data, pubkey);\n    }",
      "language": "javascript",
      "code": "function verify(data, pubkey, encoding = \"utf8\") {\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, encoding);\n        }\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\n        data = hash.sha256(data);\n        return verifyHash(data, pubkey);\n    }",
      "code_tokens": [
        "function",
        "verify",
        "(",
        "data",
        ",",
        "pubkey",
        ",",
        "encoding",
        "=",
        "\"utf8\"",
        ")",
        "{",
        "if",
        "(",
        "typeof",
        "data",
        "===",
        "\"string\"",
        ")",
        "{",
        "data",
        "=",
        "Buffer",
        ".",
        "from",
        "(",
        "data",
        ",",
        "encoding",
        ")",
        ";",
        "}",
        "assert",
        "(",
        "Buffer",
        ".",
        "isBuffer",
        "(",
        "data",
        ")",
        ",",
        "\"data is a required String or Buffer\"",
        ")",
        ";",
        "data",
        "=",
        "hash",
        ".",
        "sha256",
        "(",
        "data",
        ")",
        ";",
        "return",
        "verifyHash",
        "(",
        "data",
        ",",
        "pubkey",
        ")",
        ";",
        "}"
      ],
      "docstring": "Verify signed data.\n\n@arg {String|Buffer} data - full data\n@arg {pubkey|PublicKey} pubkey - EOSKey..\n@arg {String} [encoding = 'utf8'] - data encoding (if data is a string)\n\n@return {boolean}",
      "docstring_tokens": [
        "Verify",
        "signed",
        "data",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/signature.js#L33-L40"
    },
    "target": "Verify signed data .",
    "arguments": [
      [
        "function verify ( data , pubkey , encoding = \"utf8\" ) { if ( typeof data === \"string\" ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . isBuffer ( data ) , \"data is a required String or Buffer\" ) ; data = hash . sha256 ( data ) ; return verifyHash ( data , pubkey ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function verifyHash ( data, pubkey ) { assert ( Buffer. isBuffer ( data ), \"data is a required Buffer\" ) ; assert ( Buffer. isBuffer ( pubkey ), \"pubkey is a required Buffer\" ) ; var hash = crypto. createHash ( \"sha256\" ) ; hash. update ( pubkey ) ; var expected = hash. digest ( \"hex\" ) ; var actual = data. toString ( \"hex\" ) ; return actual === expected ; } module. exports = { verify, verifyHash } ; ```\n  3. In the `verify` function, we first check if the `data` parameter is a string. If it is, we convert it to a Buffer using the `Buffer.from()` method with the specified encoding.\n  4. We then assert that the `data` parameter is a Buffer using the `Buffer.isBuffer()` method. If it's not a Buffer, we throw an error.\n  5. We hash the `data` Buffer using the `hash.sha256()` method and store the result in the `data` variable.\n  6. We call the `verifyHash` function, passing the hashed `data` and the `pubkey` Buffer"
      ]
    ],
    "filtered_resps": [
      " function verifyHash ( data, pubkey ) { assert ( Buffer. isBuffer ( data ), \"data is a required Buffer\" ) ; assert ( Buffer. isBuffer ( pubkey ), \"pubkey is a required Buffer\" ) ; var hash = crypto. createHash ( \"sha256\" ) ; hash. update ( pubkey ) ; var expected = hash. digest ( \"hex\" ) ; var actual = data. toString ( \"hex\" ) ; return actual === expected ; } module. exports = { verify, verifyHash } ; ```\n  3. In the `verify` function, we first check if the `data` parameter is a string. If it is, we convert it to a Buffer using the `Buffer.from()` method with the specified encoding.\n  4. We then assert that the `data` parameter is a Buffer using the `Buffer.isBuffer()` method. If it's not a Buffer, we throw an error.\n  5. We hash the `data` Buffer using the `hash.sha256()` method and store the result in the `data` variable.\n  6. We call the `verifyHash` function, passing the hashed `data` and the `pubkey` Buffer"
    ],
    "smoothed_bleu_4": 0.6407752746273694
  },
  {
    "doc_id": 23,
    "doc": {
      "id": 23,
      "repo": "everitoken/evtjs",
      "path": "src/ecc/signature.js",
      "func_name": "recover",
      "original_string": "function recover(data, encoding = \"utf8\") {\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, encoding);\n        }\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\n        data = hash.sha256(data);\n\n        return recoverHash(data);\n    }",
      "language": "javascript",
      "code": "function recover(data, encoding = \"utf8\") {\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, encoding);\n        }\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\n        data = hash.sha256(data);\n\n        return recoverHash(data);\n    }",
      "code_tokens": [
        "function",
        "recover",
        "(",
        "data",
        ",",
        "encoding",
        "=",
        "\"utf8\"",
        ")",
        "{",
        "if",
        "(",
        "typeof",
        "data",
        "===",
        "\"string\"",
        ")",
        "{",
        "data",
        "=",
        "Buffer",
        ".",
        "from",
        "(",
        "data",
        ",",
        "encoding",
        ")",
        ";",
        "}",
        "assert",
        "(",
        "Buffer",
        ".",
        "isBuffer",
        "(",
        "data",
        ")",
        ",",
        "\"data is a required String or Buffer\"",
        ")",
        ";",
        "data",
        "=",
        "hash",
        ".",
        "sha256",
        "(",
        "data",
        ")",
        ";",
        "return",
        "recoverHash",
        "(",
        "data",
        ")",
        ";",
        "}"
      ],
      "docstring": "Recover the public key used to create this signature using full data.\n\n@arg {String|Buffer} data - full data\n@arg {String} [encoding = 'utf8'] - data encoding (if string)\n\n@return {PublicKey}",
      "docstring_tokens": [
        "Recover",
        "the",
        "public",
        "key",
        "used",
        "to",
        "create",
        "this",
        "signature",
        "using",
        "full",
        "data",
        "."
      ],
      "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1",
      "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/signature.js#L77-L85"
    },
    "target": "Recover the public key used to create this signature using full data .",
    "arguments": [
      [
        "function recover ( data , encoding = \"utf8\" ) { if ( typeof data === \"string\" ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . isBuffer ( data ) , \"data is a required String or Buffer\" ) ; data = hash . sha256 ( data ) ; return recoverHash ( data ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " exports. recover = recover ; exports. recoverHash = recoverHash ; exports. recoverHashSync = recoverHashSync ; exports. recoverSync = recoverSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports."
      ]
    ],
    "filtered_resps": [
      " exports. recover = recover ; exports. recoverHash = recoverHash ; exports. recoverHashSync = recoverHashSync ; exports. recoverSync = recoverSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports. hashSync = hashSync ; exports. hash = hash ; exports."
    ],
    "smoothed_bleu_4": 0.5629426211681089
  },
  {
    "doc_id": 24,
    "doc": {
      "id": 24,
      "repo": "zaproxy/zaproxy",
      "path": "src/scripts/templates/targeted/Find HTML comments.js",
      "func_name": "invokeWith",
      "original_string": "function invokeWith(msg) {\n\t// Debugging can be done using println like this\n\tprint('Finding comments in ' + msg.getRequestHeader().getURI().toString()); \n\n\tvar body = msg.getResponseBody().toString()\n\t// Look for html comments\n\tif (body.indexOf('<!--') > 0) {\n\t\tvar o = body.indexOf('<!--');\n\t\twhile (o > 0) {\n\t\t\tvar e = body.indexOf('-->', o);\n\t\t\tprint(\"\\t\" + body.substr(o,e-o+3)) \n\t\t\to = body.indexOf('<!--', e);\n\t\t}\n\t}\n}",
      "language": "javascript",
      "code": "function invokeWith(msg) {\n\t// Debugging can be done using println like this\n\tprint('Finding comments in ' + msg.getRequestHeader().getURI().toString()); \n\n\tvar body = msg.getResponseBody().toString()\n\t// Look for html comments\n\tif (body.indexOf('<!--') > 0) {\n\t\tvar o = body.indexOf('<!--');\n\t\twhile (o > 0) {\n\t\t\tvar e = body.indexOf('-->', o);\n\t\t\tprint(\"\\t\" + body.substr(o,e-o+3)) \n\t\t\to = body.indexOf('<!--', e);\n\t\t}\n\t}\n}",
      "code_tokens": [
        "function",
        "invokeWith",
        "(",
        "msg",
        ")",
        "{",
        "// Debugging can be done using println like this",
        "print",
        "(",
        "'Finding comments in '",
        "+",
        "msg",
        ".",
        "getRequestHeader",
        "(",
        ")",
        ".",
        "getURI",
        "(",
        ")",
        ".",
        "toString",
        "(",
        ")",
        ")",
        ";",
        "var",
        "body",
        "=",
        "msg",
        ".",
        "getResponseBody",
        "(",
        ")",
        ".",
        "toString",
        "(",
        ")",
        "// Look for html comments",
        "if",
        "(",
        "body",
        ".",
        "indexOf",
        "(",
        "'<!--'",
        ")",
        ">",
        "0",
        ")",
        "{",
        "var",
        "o",
        "=",
        "body",
        ".",
        "indexOf",
        "(",
        "'<!--'",
        ")",
        ";",
        "while",
        "(",
        "o",
        ">",
        "0",
        ")",
        "{",
        "var",
        "e",
        "=",
        "body",
        ".",
        "indexOf",
        "(",
        "'-->'",
        ",",
        "o",
        ")",
        ";",
        "print",
        "(",
        "\"\\t\"",
        "+",
        "body",
        ".",
        "substr",
        "(",
        "o",
        ",",
        "e",
        "-",
        "o",
        "+",
        "3",
        ")",
        ")",
        "o",
        "=",
        "body",
        ".",
        "indexOf",
        "(",
        "'<!--'",
        ",",
        "e",
        ")",
        ";",
        "}",
        "}",
        "}"
      ],
      "docstring": "Targeted scripts can only be invoked by you, the user, eg via a right-click option on the Sites or History tabs",
      "docstring_tokens": [
        "Targeted",
        "scripts",
        "can",
        "only",
        "be",
        "invoked",
        "by",
        "you",
        "the",
        "user",
        "eg",
        "via",
        "a",
        "right",
        "-",
        "click",
        "option",
        "on",
        "the",
        "Sites",
        "or",
        "History",
        "tabs"
      ],
      "sha": "688486b806508970d048228059045c9f5b6725d0",
      "url": "https://github.com/zaproxy/zaproxy/blob/688486b806508970d048228059045c9f5b6725d0/src/scripts/templates/targeted/Find HTML comments.js#L3-L17"
    },
    "target": "Targeted scripts can only be invoked by you the user eg via a right - click option on the Sites or History tabs",
    "arguments": [
      [
        "function invokeWith ( msg ) { // Debugging can be done using println like this print ( 'Finding comments in ' + msg . getRequestHeader ( ) . getURI ( ) . toString ( ) ) ; var body = msg . getResponseBody ( ) . toString ( ) // Look for html comments if ( body . indexOf ( '<!--' ) > 0 ) { var o = body . indexOf ( '<!--' ) ; while ( o > 0 ) { var e = body . indexOf ( '-->' , o ) ; print ( \"\\t\" + body . substr ( o , e - o + 3 ) ) o = body . indexOf ( '<!--' , e ) ; } } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " } ``` This code snippet is written in JavaScript and appears to be part of a larger program that handles HTTP requests and responses. It defines a function `invokeWith` that takes a message object `msg` as an argument. The function prints a message to the console indicating that it is searching for comments in the request URI. It then extracts the response body from the message object and converts it to a string. The code then checks if the response body contains any HTML comments (denoted by `<!--` and `-->` tags). If it does, it loops through the comments, printing each one to the console. The loop continues until all comments have been found and printed. The `substr` method is used to extract each comment from the response body, and the `indexOf` method is used to find the start and end indices of each comment. The `print` function is used to output the comments to the console. Note that this code is likely part of a larger program that handles HTTP requests and responses, and the `invokeWith` function is probably called in response to a specific event or condition. The context in which this code is deployed is likely a web server or a web application that needs to extract and process comments from HTML responses"
      ]
    ],
    "filtered_resps": [
      " } ``` This code snippet is written in JavaScript and appears to be part of a larger program that handles HTTP requests and responses. It defines a function `invokeWith` that takes a message object `msg` as an argument. The function prints a message to the console indicating that it is searching for comments in the request URI. It then extracts the response body from the message object and converts it to a string. The code then checks if the response body contains any HTML comments (denoted by `<!--` and `-->` tags). If it does, it loops through the comments, printing each one to the console. The loop continues until all comments have been found and printed. The `substr` method is used to extract each comment from the response body, and the `indexOf` method is used to find the start and end indices of each comment. The `print` function is used to output the comments to the console. Note that this code is likely part of a larger program that handles HTTP requests and responses, and the `invokeWith` function is probably called in response to a specific event or condition. The context in which this code is deployed is likely a web server or a web application that needs to extract and process comments from HTML responses"
    ],
    "smoothed_bleu_4": 0.6397581988828135
  },
  {
    "doc_id": 25,
    "doc": {
      "id": 25,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Form/FormGroup.js",
      "func_name": "FormGroup",
      "original_string": "function FormGroup(props) {\n  const { children, className, grouped, inline, unstackable, widths } = props\n\n  const classes = cx(\n    useKeyOnly(grouped, 'grouped'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useWidthProp(widths, null, true),\n    'fields',\n    className,\n  )\n  const rest = getUnhandledProps(FormGroup, props)\n  const ElementType = getElementType(FormGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function FormGroup(props) {\n  const { children, className, grouped, inline, unstackable, widths } = props\n\n  const classes = cx(\n    useKeyOnly(grouped, 'grouped'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useWidthProp(widths, null, true),\n    'fields',\n    className,\n  )\n  const rest = getUnhandledProps(FormGroup, props)\n  const ElementType = getElementType(FormGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "FormGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "grouped",
        ",",
        "inline",
        ",",
        "unstackable",
        ",",
        "widths",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "grouped",
        ",",
        "'grouped'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inline",
        ",",
        "'inline'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "unstackable",
        ",",
        "'unstackable'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "widths",
        ",",
        "null",
        ",",
        "true",
        ")",
        ",",
        "'fields'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "FormGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "FormGroup",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A set of fields can appear grouped together.\n@see Form",
      "docstring_tokens": [
        "A",
        "set",
        "of",
        "fields",
        "can",
        "appear",
        "grouped",
        "together",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Form/FormGroup.js#L18-L37"
    },
    "target": "A set of fields can appear grouped together .",
    "arguments": [
      [
        "function FormGroup ( props ) { const { children , className , grouped , inline , unstackable , widths } = props const classes = cx ( useKeyOnly ( grouped , 'grouped' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( unstackable , 'unstackable' ) , useWidthProp ( widths , null , true ) , 'fields' , className , ) const rest = getUnhandledProps ( FormGroup , props ) const ElementType = getElementType ( FormGroup , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " FormGroup. defaultProps = { as : 'div' } export default FormGroup ; ```\n  - ```bash\nnpm install --save-dev @babel/plugin-proposal-class-properties\n```\n  - Create a new file called `babel.config.js` with the following content:\n```javascript\nmodule.exports = {\n  presets: ['@babel/preset-env'],\n  plugins: [\n    '@babel/plugin-proposal-class-properties',\n  ],\n};\n```\n  - Update the `package.json` file to include the following script:\n```json\n\"scripts\": {\n  \"build\": \"babel src --out-dir lib\"\n}\n```\n  - Run the following command to build the code:\n```bash\nnpm run build\n```\n  - The compiled code will be generated in the `lib` directory.\n\nNote: This is a simplified example and you may need to adjust the code to fit your specific use case. Additionally, this example assumes that you are using a modern JavaScript environment and have the necessary dependencies installed. If you are using an older environment or have specific requirements, you may need to modify the code accordingly.<|end_of_text|>"
      ]
    ],
    "filtered_resps": [
      " FormGroup. defaultProps = { as : 'div' } export default FormGroup ; ```\n  - ```bash\nnpm install --save-dev @babel/plugin-proposal-class-properties\n```\n  - Create a new file called `babel.config.js` with the following content:\n```javascript\nmodule.exports = {\n  presets: ['@babel/preset-env'],\n  plugins: [\n    '@babel/plugin-proposal-class-properties',\n  ],\n};\n```\n  - Update the `package.json` file to include the following script:\n```json\n\"scripts\": {\n  \"build\": \"babel src --out-dir lib\"\n}\n```\n  - Run the following command to build the code:\n```bash\nnpm run build\n```\n  - The compiled code will be generated in the `lib` directory.\n\nNote: This is a simplified example and you may need to adjust the code to fit your specific use case. Additionally, this example assumes that you are using a modern JavaScript environment and have the necessary dependencies installed. If you are using an older environment or have specific requirements, you may need to modify the code accordingly.<|end_of_text|>"
    ],
    "smoothed_bleu_4": 0.5196766335420494
  },
  {
    "doc_id": 26,
    "doc": {
      "id": 26,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Loader/Loader.js",
      "func_name": "Loader",
      "original_string": "function Loader(props) {\n  const {\n    active,\n    children,\n    className,\n    content,\n    disabled,\n    indeterminate,\n    inline,\n    inverted,\n    size,\n  } = props\n\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(indeterminate, 'indeterminate'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(children || content, 'text'),\n    useKeyOrValueAndKey(inline, 'inline'),\n    'loader',\n    className,\n  )\n  const rest = getUnhandledProps(Loader, props)\n  const ElementType = getElementType(Loader, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Loader(props) {\n  const {\n    active,\n    children,\n    className,\n    content,\n    disabled,\n    indeterminate,\n    inline,\n    inverted,\n    size,\n  } = props\n\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(indeterminate, 'indeterminate'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(children || content, 'text'),\n    useKeyOrValueAndKey(inline, 'inline'),\n    'loader',\n    className,\n  )\n  const rest = getUnhandledProps(Loader, props)\n  const ElementType = getElementType(Loader, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Loader",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "active",
        ",",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "disabled",
        ",",
        "indeterminate",
        ",",
        "inline",
        ",",
        "inverted",
        ",",
        "size",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "active",
        ",",
        "'active'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "indeterminate",
        ",",
        "'indeterminate'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "children",
        "||",
        "content",
        ",",
        "'text'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "inline",
        ",",
        "'inline'",
        ")",
        ",",
        "'loader'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Loader",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Loader",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A loader alerts a user to wait for an activity to complete.\n@see Dimmer",
      "docstring_tokens": [
        "A",
        "loader",
        "alerts",
        "a",
        "user",
        "to",
        "wait",
        "for",
        "an",
        "activity",
        "to",
        "complete",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Loader/Loader.js#L19-L52"
    },
    "target": "A loader alerts a user to wait for an activity to complete .",
    "arguments": [
      [
        "function Loader ( props ) { const { active , children , className , content , disabled , indeterminate , inline , inverted , size , } = props const classes = cx ( 'ui' , size , useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( indeterminate , 'indeterminate' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( children || content , 'text' ) , useKeyOrValueAndKey ( inline , 'inline' ) , 'loader' , className , ) const rest = getUnhandledProps ( Loader , props ) const ElementType = getElementType ( Loader , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Loader. propTypes = { active : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, content : React. PropTypes. node, disabled : React. PropTypes. bool, indeterminate : React. PropTypes. bool, inline : React. PropTypes. bool, inverted : React. PropTypes. bool, size : React. PropTypes. oneOf ( ['mini', 'tiny','small','medium', 'large', 'huge','massive' ] ), } Loader. defaultProps = { active : false, children : undefined, className : undefined, content : undefined, disabled : false, indeterminate : false, inline : false, inverted : false, size :'medium', } export default Loader ; ``` This code defines a React component called `Loader` that displays a loading animation. It takes various props such as `active`, `children`, `className`, `content`, `disabled`, `indeterminate`, `inline`, `inverted`, and `size`. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props. It also uses the `getUnhandledProps` and `"
      ]
    ],
    "filtered_resps": [
      " Loader. propTypes = { active : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, content : React. PropTypes. node, disabled : React. PropTypes. bool, indeterminate : React. PropTypes. bool, inline : React. PropTypes. bool, inverted : React. PropTypes. bool, size : React. PropTypes. oneOf ( ['mini', 'tiny','small','medium', 'large', 'huge','massive' ] ), } Loader. defaultProps = { active : false, children : undefined, className : undefined, content : undefined, disabled : false, indeterminate : false, inline : false, inverted : false, size :'medium', } export default Loader ; ``` This code defines a React component called `Loader` that displays a loading animation. It takes various props such as `active`, `children`, `className`, `content`, `disabled`, `indeterminate`, `inline`, `inverted`, and `size`. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props. It also uses the `getUnhandledProps` and `"
    ],
    "smoothed_bleu_4": 0.5951669384841906
  },
  {
    "doc_id": 27,
    "doc": {
      "id": 27,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Item/ItemContent.js",
      "func_name": "ItemContent",
      "original_string": "function ItemContent(props) {\n  const { children, className, content, description, extra, header, meta, verticalAlign } = props\n\n  const classes = cx(useVerticalAlignProp(verticalAlign), 'content', className)\n  const rest = getUnhandledProps(ItemContent, props)\n  const ElementType = getElementType(ItemContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {ItemHeader.create(header, { autoGenerateKey: false })}\n      {ItemMeta.create(meta, { autoGenerateKey: false })}\n      {ItemDescription.create(description, { autoGenerateKey: false })}\n      {ItemExtra.create(extra, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function ItemContent(props) {\n  const { children, className, content, description, extra, header, meta, verticalAlign } = props\n\n  const classes = cx(useVerticalAlignProp(verticalAlign), 'content', className)\n  const rest = getUnhandledProps(ItemContent, props)\n  const ElementType = getElementType(ItemContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {ItemHeader.create(header, { autoGenerateKey: false })}\n      {ItemMeta.create(meta, { autoGenerateKey: false })}\n      {ItemDescription.create(description, { autoGenerateKey: false })}\n      {ItemExtra.create(extra, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "ItemContent",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "description",
        ",",
        "extra",
        ",",
        "header",
        ",",
        "meta",
        ",",
        "verticalAlign",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "'content'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "ItemContent",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "ItemContent",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "ItemHeader",
        ".",
        "create",
        "(",
        "header",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "ItemMeta",
        ".",
        "create",
        "(",
        "meta",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "ItemDescription",
        ".",
        "create",
        "(",
        "description",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "ItemExtra",
        ".",
        "create",
        "(",
        "extra",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "content",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "An item can contain content.",
      "docstring_tokens": [
        "An",
        "item",
        "can",
        "contain",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Item/ItemContent.js#L21-L45"
    },
    "target": "An item can contain content .",
    "arguments": [
      [
        "function ItemContent ( props ) { const { children , className , content , description , extra , header , meta , verticalAlign } = props const classes = cx ( useVerticalAlignProp ( verticalAlign ) , 'content' , className ) const rest = getUnhandledProps ( ItemContent , props ) const ElementType = getElementType ( ItemContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ItemHeader . create ( header , { autoGenerateKey : false } ) } { ItemMeta . create ( meta , { autoGenerateKey : false } ) } { ItemDescription . create ( description , { autoGenerateKey : false } ) } { ItemExtra . create ( extra , { autoGenerateKey : false } ) } { content } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ItemContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. node, extra : PropTypes. node, header : PropTypes. node, meta : PropTypes. node, verticalAlign : PropTypes. oneOf ( [ 'top','middle', 'bottom' ] ), } ItemContent. defaultProps = { verticalAlign : 'top', } export default ItemContent ; ```\n\nThis code defines a React component named `ItemContent`. It takes several props, including `children`, `className`, `content`, `description`, `extra`, `header`, `meta`, and `verticalAlign`. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `verticalAlign` prop. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component. The component returns a JSX element with the specified children and props.\n\nThe code also defines the propTypes and defaultProps for the `ItemContent` component. The propTypes specify the expected types for each prop, and the defaultProps specify default values for each prop.\n\nNote that this code assumes that the `ItemHeader`, `ItemMeta`, `Item"
      ]
    ],
    "filtered_resps": [
      " ItemContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. node, extra : PropTypes. node, header : PropTypes. node, meta : PropTypes. node, verticalAlign : PropTypes. oneOf ( [ 'top','middle', 'bottom' ] ), } ItemContent. defaultProps = { verticalAlign : 'top', } export default ItemContent ; ```\n\nThis code defines a React component named `ItemContent`. It takes several props, including `children`, `className`, `content`, `description`, `extra`, `header`, `meta`, and `verticalAlign`. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `verticalAlign` prop. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component. The component returns a JSX element with the specified children and props.\n\nThe code also defines the propTypes and defaultProps for the `ItemContent` component. The propTypes specify the expected types for each prop, and the defaultProps specify default values for each prop.\n\nNote that this code assumes that the `ItemHeader`, `ItemMeta`, `Item"
    ],
    "smoothed_bleu_4": 0.5344493327310615
  },
  {
    "doc_id": 28,
    "doc": {
      "id": 28,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Table/Table.js",
      "func_name": "Table",
      "original_string": "function Table(props) {\n  const {\n    attached,\n    basic,\n    celled,\n    children,\n    className,\n    collapsing,\n    color,\n    columns,\n    compact,\n    definition,\n    fixed,\n    footerRow,\n    headerRow,\n    headerRows,\n    inverted,\n    padded,\n    renderBodyRow,\n    selectable,\n    singleLine,\n    size,\n    sortable,\n    stackable,\n    striped,\n    structured,\n    tableData,\n    textAlign,\n    unstackable,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(celled, 'celled'),\n    useKeyOnly(collapsing, 'collapsing'),\n    useKeyOnly(definition, 'definition'),\n    useKeyOnly(fixed, 'fixed'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(selectable, 'selectable'),\n    useKeyOnly(singleLine, 'single line'),\n    useKeyOnly(sortable, 'sortable'),\n    useKeyOnly(stackable, 'stackable'),\n    useKeyOnly(striped, 'striped'),\n    useKeyOnly(structured, 'structured'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useKeyOrValueAndKey(basic, 'basic'),\n    useKeyOrValueAndKey(compact, 'compact'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column'),\n    'table',\n    className,\n  )\n  const rest = getUnhandledProps(Table, props)\n  const ElementType = getElementType(Table, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const hasHeaderRows = headerRow || headerRows\n  const headerShorthandOptions = { defaultProps: { cellAs: 'th' } }\n  const headerElement = hasHeaderRows && (\n    <TableHeader>\n      {TableRow.create(headerRow, headerShorthandOptions)}\n      {_.map(headerRows, (data) => TableRow.create(data, headerShorthandOptions))}\n    </TableHeader>\n  )\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {headerElement}\n      <TableBody>\n        {renderBodyRow &&\n          _.map(tableData, (data, index) => TableRow.create(renderBodyRow(data, index)))}\n      </TableBody>\n      {footerRow && <TableFooter>{TableRow.create(footerRow)}</TableFooter>}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Table(props) {\n  const {\n    attached,\n    basic,\n    celled,\n    children,\n    className,\n    collapsing,\n    color,\n    columns,\n    compact,\n    definition,\n    fixed,\n    footerRow,\n    headerRow,\n    headerRows,\n    inverted,\n    padded,\n    renderBodyRow,\n    selectable,\n    singleLine,\n    size,\n    sortable,\n    stackable,\n    striped,\n    structured,\n    tableData,\n    textAlign,\n    unstackable,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(celled, 'celled'),\n    useKeyOnly(collapsing, 'collapsing'),\n    useKeyOnly(definition, 'definition'),\n    useKeyOnly(fixed, 'fixed'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(selectable, 'selectable'),\n    useKeyOnly(singleLine, 'single line'),\n    useKeyOnly(sortable, 'sortable'),\n    useKeyOnly(stackable, 'stackable'),\n    useKeyOnly(striped, 'striped'),\n    useKeyOnly(structured, 'structured'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useKeyOrValueAndKey(basic, 'basic'),\n    useKeyOrValueAndKey(compact, 'compact'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column'),\n    'table',\n    className,\n  )\n  const rest = getUnhandledProps(Table, props)\n  const ElementType = getElementType(Table, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const hasHeaderRows = headerRow || headerRows\n  const headerShorthandOptions = { defaultProps: { cellAs: 'th' } }\n  const headerElement = hasHeaderRows && (\n    <TableHeader>\n      {TableRow.create(headerRow, headerShorthandOptions)}\n      {_.map(headerRows, (data) => TableRow.create(data, headerShorthandOptions))}\n    </TableHeader>\n  )\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {headerElement}\n      <TableBody>\n        {renderBodyRow &&\n          _.map(tableData, (data, index) => TableRow.create(renderBodyRow(data, index)))}\n      </TableBody>\n      {footerRow && <TableFooter>{TableRow.create(footerRow)}</TableFooter>}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Table",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "attached",
        ",",
        "basic",
        ",",
        "celled",
        ",",
        "children",
        ",",
        "className",
        ",",
        "collapsing",
        ",",
        "color",
        ",",
        "columns",
        ",",
        "compact",
        ",",
        "definition",
        ",",
        "fixed",
        ",",
        "footerRow",
        ",",
        "headerRow",
        ",",
        "headerRows",
        ",",
        "inverted",
        ",",
        "padded",
        ",",
        "renderBodyRow",
        ",",
        "selectable",
        ",",
        "singleLine",
        ",",
        "size",
        ",",
        "sortable",
        ",",
        "stackable",
        ",",
        "striped",
        ",",
        "structured",
        ",",
        "tableData",
        ",",
        "textAlign",
        ",",
        "unstackable",
        ",",
        "verticalAlign",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "color",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "celled",
        ",",
        "'celled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "collapsing",
        ",",
        "'collapsing'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "definition",
        ",",
        "'definition'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "fixed",
        ",",
        "'fixed'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "selectable",
        ",",
        "'selectable'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "singleLine",
        ",",
        "'single line'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "sortable",
        ",",
        "'sortable'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "stackable",
        ",",
        "'stackable'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "striped",
        ",",
        "'striped'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "structured",
        ",",
        "'structured'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "unstackable",
        ",",
        "'unstackable'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "attached",
        ",",
        "'attached'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "basic",
        ",",
        "'basic'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "compact",
        ",",
        "'compact'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "padded",
        ",",
        "'padded'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "useWidthProp",
        "(",
        "columns",
        ",",
        "'column'",
        ")",
        ",",
        "'table'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Table",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Table",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "const",
        "hasHeaderRows",
        "=",
        "headerRow",
        "||",
        "headerRows",
        "const",
        "headerShorthandOptions",
        "=",
        "{",
        "defaultProps",
        ":",
        "{",
        "cellAs",
        ":",
        "'th'",
        "}",
        "}",
        "const",
        "headerElement",
        "=",
        "hasHeaderRows",
        "&&",
        "(",
        "<",
        "TableHeader",
        ">",
        "\n      ",
        "{",
        "TableRow",
        ".",
        "create",
        "(",
        "headerRow",
        ",",
        "headerShorthandOptions",
        ")",
        "}",
        "\n      ",
        "{",
        "_",
        ".",
        "map",
        "(",
        "headerRows",
        ",",
        "(",
        "data",
        ")",
        "=>",
        "TableRow",
        ".",
        "create",
        "(",
        "data",
        ",",
        "headerShorthandOptions",
        ")",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "TableHeader",
        ">",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "headerElement",
        "}",
        "\n      ",
        "<",
        "TableBody",
        ">",
        "\n        ",
        "{",
        "renderBodyRow",
        "&&",
        "_",
        ".",
        "map",
        "(",
        "tableData",
        ",",
        "(",
        "data",
        ",",
        "index",
        ")",
        "=>",
        "TableRow",
        ".",
        "create",
        "(",
        "renderBodyRow",
        "(",
        "data",
        ",",
        "index",
        ")",
        ")",
        ")",
        "}",
        "\n      ",
        "<",
        "/",
        "TableBody",
        ">",
        "\n      ",
        "{",
        "footerRow",
        "&&",
        "<",
        "TableFooter",
        ">",
        "{",
        "TableRow",
        ".",
        "create",
        "(",
        "footerRow",
        ")",
        "}",
        "<",
        "/",
        "TableFooter",
        ">",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A table displays a collections of data grouped into rows.",
      "docstring_tokens": [
        "A",
        "table",
        "displays",
        "a",
        "collections",
        "of",
        "data",
        "grouped",
        "into",
        "rows",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Table/Table.js#L28-L116"
    },
    "target": "A table displays a collections of data grouped into rows .",
    "arguments": [
      [
        "function Table ( props ) { const { attached , basic , celled , children , className , collapsing , color , columns , compact , definition , fixed , footerRow , headerRow , headerRows , inverted , padded , renderBodyRow , selectable , singleLine , size , sortable , stackable , striped , structured , tableData , textAlign , unstackable , verticalAlign , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( celled , 'celled' ) , useKeyOnly ( collapsing , 'collapsing' ) , useKeyOnly ( definition , 'definition' ) , useKeyOnly ( fixed , 'fixed' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( selectable , 'selectable' ) , useKeyOnly ( singleLine , 'single line' ) , useKeyOnly ( sortable , 'sortable' ) , useKeyOnly ( stackable , 'stackable' ) , useKeyOnly ( striped , 'striped' ) , useKeyOnly ( structured , 'structured' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useKeyOrValueAndKey ( basic , 'basic' ) , useKeyOrValueAndKey ( compact , 'compact' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' ) , 'table' , className , ) const rest = getUnhandledProps ( Table , props ) const ElementType = getElementType ( Table , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const hasHeaderRows = headerRow || headerRows const headerShorthandOptions = { defaultProps : { cellAs : 'th' } } const headerElement = hasHeaderRows && ( < TableHeader > { TableRow . create ( headerRow , headerShorthandOptions ) } { _ . map ( headerRows , ( data ) => TableRow . create ( data , headerShorthandOptions ) ) } < / TableHeader > ) return ( < ElementType { ... rest } className = { classes } > { headerElement } < TableBody > { renderBodyRow && _ . map ( tableData , ( data , index ) => TableRow . create ( renderBodyRow ( data , index ) ) ) } < / TableBody > { footerRow && < TableFooter > { TableRow . create ( footerRow ) } < / TableFooter > } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " } export default Table ; ``` This code defines a React component named `Table` that represents a table in a UI framework. It takes various props to customize its appearance and behavior, such as `attached`, `basic`, `celled`, `children`, `className`, `collapsing`, `color`, `columns`, `compact`, `definition`, `fixed`, `footerRow`, `headerRow`, `headerRows`, `inverted`, `padded`, `renderBodyRow`, `selectable`, `singleLine`, `size`, `sortable`, `stackable`, `striped`, `structured`, `tableData`, `textAlign`, `unstackable`, and `verticalAlign`. The component uses various utility functions from the `@blueprintjs/core` library to handle props, classes, and rendering. It also uses the `cx` function to conditionally apply CSS classes based on the props. The component returns a JSX element that represents the table, including its header, body, and footer rows. The `renderBodyRow` prop is used to customize the rendering of each row in the table body. The component also uses the `TableRow` component to render each row in the table. The `TableHeader`, `"
      ]
    ],
    "filtered_resps": [
      " } export default Table ; ``` This code defines a React component named `Table` that represents a table in a UI framework. It takes various props to customize its appearance and behavior, such as `attached`, `basic`, `celled`, `children`, `className`, `collapsing`, `color`, `columns`, `compact`, `definition`, `fixed`, `footerRow`, `headerRow`, `headerRows`, `inverted`, `padded`, `renderBodyRow`, `selectable`, `singleLine`, `size`, `sortable`, `stackable`, `striped`, `structured`, `tableData`, `textAlign`, `unstackable`, and `verticalAlign`. The component uses various utility functions from the `@blueprintjs/core` library to handle props, classes, and rendering. It also uses the `cx` function to conditionally apply CSS classes based on the props. The component returns a JSX element that represents the table, including its header, body, and footer rows. The `renderBodyRow` prop is used to customize the rendering of each row in the table body. The component also uses the `TableRow` component to render each row in the table. The `TableHeader`, `"
    ],
    "smoothed_bleu_4": 0.8006910999175986
  },
  {
    "doc_id": 29,
    "doc": {
      "id": 29,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Rail/Rail.js",
      "func_name": "Rail",
      "original_string": "function Rail(props) {\n  const {\n    attached,\n    children,\n    className,\n    close,\n    content,\n    dividing,\n    internal,\n    position,\n    size,\n  } = props\n\n  const classes = cx(\n    'ui',\n    position,\n    size,\n    useKeyOnly(attached, 'attached'),\n    useKeyOnly(dividing, 'dividing'),\n    useKeyOnly(internal, 'internal'),\n    useKeyOrValueAndKey(close, 'close'),\n    'rail',\n    className,\n  )\n  const rest = getUnhandledProps(Rail, props)\n  const ElementType = getElementType(Rail, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Rail(props) {\n  const {\n    attached,\n    children,\n    className,\n    close,\n    content,\n    dividing,\n    internal,\n    position,\n    size,\n  } = props\n\n  const classes = cx(\n    'ui',\n    position,\n    size,\n    useKeyOnly(attached, 'attached'),\n    useKeyOnly(dividing, 'dividing'),\n    useKeyOnly(internal, 'internal'),\n    useKeyOrValueAndKey(close, 'close'),\n    'rail',\n    className,\n  )\n  const rest = getUnhandledProps(Rail, props)\n  const ElementType = getElementType(Rail, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Rail",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "attached",
        ",",
        "children",
        ",",
        "className",
        ",",
        "close",
        ",",
        "content",
        ",",
        "dividing",
        ",",
        "internal",
        ",",
        "position",
        ",",
        "size",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "position",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "attached",
        ",",
        "'attached'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "dividing",
        ",",
        "'dividing'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "internal",
        ",",
        "'internal'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "close",
        ",",
        "'close'",
        ")",
        ",",
        "'rail'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Rail",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Rail",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A rail is used to show accompanying content outside the boundaries of the main view of a site.",
      "docstring_tokens": [
        "A",
        "rail",
        "is",
        "used",
        "to",
        "show",
        "accompanying",
        "content",
        "outside",
        "the",
        "boundaries",
        "of",
        "the",
        "main",
        "view",
        "of",
        "a",
        "site",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Rail/Rail.js#L19-L51"
    },
    "target": "A rail is used to show accompanying content outside the boundaries of the main view of a site .",
    "arguments": [
      [
        "function Rail ( props ) { const { attached , children , className , close , content , dividing , internal , position , size , } = props const classes = cx ( 'ui' , position , size , useKeyOnly ( attached , 'attached' ) , useKeyOnly ( dividing , 'dividing' ) , useKeyOnly ( internal , 'internal' ) , useKeyOrValueAndKey ( close , 'close' ) , 'rail' , className , ) const rest = getUnhandledProps ( Rail , props ) const ElementType = getElementType ( Rail , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Rail. defaultProps = { attached : false, children : undefined, className : undefined, close : false, content : undefined, dividing : false, internal : false, position : 'left', size : 'tiny', } Rail. propTypes = { attached : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, close : PropTypes. bool, content : PropTypes. node, dividing : PropTypes. bool, internal : PropTypes. bool, position : PropTypes. oneOf ( [ 'left', 'right' ] ), size : PropTypes. oneOf ( [ 'tiny','small','medium', 'large' ] ), } module. exports = Rail ; } }, { \"path\" : \"/home/user/project/node_modules/react-transition-group/Transition.js\", \"code\" : \"import React from'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Transition(props) {\\n  const {\\n    children,\\n    in,\\n    onEnter,\\n    onEntering,\\n    onEntered,\\n    onExit,\\n    onExiting,\\n    onExited,\\n    timeout,\\n  } = props;\\n\\n  return (\\"
      ]
    ],
    "filtered_resps": [
      " Rail. defaultProps = { attached : false, children : undefined, className : undefined, close : false, content : undefined, dividing : false, internal : false, position : 'left', size : 'tiny', } Rail. propTypes = { attached : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, close : PropTypes. bool, content : PropTypes. node, dividing : PropTypes. bool, internal : PropTypes. bool, position : PropTypes. oneOf ( [ 'left', 'right' ] ), size : PropTypes. oneOf ( [ 'tiny','small','medium', 'large' ] ), } module. exports = Rail ; } }, { \"path\" : \"/home/user/project/node_modules/react-transition-group/Transition.js\", \"code\" : \"import React from'react';\\nimport PropTypes from 'prop-types';\\n\\nfunction Transition(props) {\\n  const {\\n    children,\\n    in,\\n    onEnter,\\n    onEntering,\\n    onEntered,\\n    onExit,\\n    onExiting,\\n    onExited,\\n    timeout,\\n  } = props;\\n\\n  return (\\"
    ],
    "smoothed_bleu_4": 0.5135925502369282
  },
  {
    "doc_id": 30,
    "doc": {
      "id": 30,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Button/ButtonGroup.js",
      "func_name": "ButtonGroup",
      "original_string": "function ButtonGroup(props) {\n  const {\n    attached,\n    basic,\n    buttons,\n    children,\n    className,\n    color,\n    compact,\n    content,\n    floated,\n    fluid,\n    icon,\n    inverted,\n    labeled,\n    negative,\n    positive,\n    primary,\n    secondary,\n    size,\n    toggle,\n    vertical,\n    widths,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(basic, 'basic'),\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(icon, 'icon'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(labeled, 'labeled'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(primary, 'primary'),\n    useKeyOnly(secondary, 'secondary'),\n    useKeyOnly(toggle, 'toggle'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useValueAndKey(floated, 'floated'),\n    useWidthProp(widths),\n    'buttons',\n    className,\n  )\n  const rest = getUnhandledProps(ButtonGroup, props)\n  const ElementType = getElementType(ButtonGroup, props)\n\n  if (_.isNil(buttons)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {childrenUtils.isNil(children) ? content : children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(buttons, button => Button.create(button))}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function ButtonGroup(props) {\n  const {\n    attached,\n    basic,\n    buttons,\n    children,\n    className,\n    color,\n    compact,\n    content,\n    floated,\n    fluid,\n    icon,\n    inverted,\n    labeled,\n    negative,\n    positive,\n    primary,\n    secondary,\n    size,\n    toggle,\n    vertical,\n    widths,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(basic, 'basic'),\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(icon, 'icon'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(labeled, 'labeled'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(primary, 'primary'),\n    useKeyOnly(secondary, 'secondary'),\n    useKeyOnly(toggle, 'toggle'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useValueAndKey(floated, 'floated'),\n    useWidthProp(widths),\n    'buttons',\n    className,\n  )\n  const rest = getUnhandledProps(ButtonGroup, props)\n  const ElementType = getElementType(ButtonGroup, props)\n\n  if (_.isNil(buttons)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {childrenUtils.isNil(children) ? content : children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(buttons, button => Button.create(button))}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "ButtonGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "attached",
        ",",
        "basic",
        ",",
        "buttons",
        ",",
        "children",
        ",",
        "className",
        ",",
        "color",
        ",",
        "compact",
        ",",
        "content",
        ",",
        "floated",
        ",",
        "fluid",
        ",",
        "icon",
        ",",
        "inverted",
        ",",
        "labeled",
        ",",
        "negative",
        ",",
        "positive",
        ",",
        "primary",
        ",",
        "secondary",
        ",",
        "size",
        ",",
        "toggle",
        ",",
        "vertical",
        ",",
        "widths",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "color",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "basic",
        ",",
        "'basic'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "compact",
        ",",
        "'compact'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "fluid",
        ",",
        "'fluid'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "icon",
        ",",
        "'icon'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "labeled",
        ",",
        "'labeled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "negative",
        ",",
        "'negative'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "positive",
        ",",
        "'positive'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "primary",
        ",",
        "'primary'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "secondary",
        ",",
        "'secondary'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "toggle",
        ",",
        "'toggle'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "vertical",
        ",",
        "'vertical'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "attached",
        ",",
        "'attached'",
        ")",
        ",",
        "useValueAndKey",
        "(",
        "floated",
        ",",
        "'floated'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "widths",
        ")",
        ",",
        "'buttons'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "ButtonGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "ButtonGroup",
        ",",
        "props",
        ")",
        "if",
        "(",
        "_",
        ".",
        "isNil",
        "(",
        "buttons",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "_",
        ".",
        "map",
        "(",
        "buttons",
        ",",
        "button",
        "=>",
        "Button",
        ".",
        "create",
        "(",
        "button",
        ")",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "Buttons can be grouped.",
      "docstring_tokens": [
        "Buttons",
        "can",
        "be",
        "grouped",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Button/ButtonGroup.js#L22-L85"
    },
    "target": "Buttons can be grouped .",
    "arguments": [
      [
        "function ButtonGroup ( props ) { const { attached , basic , buttons , children , className , color , compact , content , floated , fluid , icon , inverted , labeled , negative , positive , primary , secondary , size , toggle , vertical , widths , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( basic , 'basic' ) , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( icon , 'icon' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( labeled , 'labeled' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( primary , 'primary' ) , useKeyOnly ( secondary , 'secondary' ) , useKeyOnly ( toggle , 'toggle' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useValueAndKey ( floated , 'floated' ) , useWidthProp ( widths ) , 'buttons' , className , ) const rest = getUnhandledProps ( ButtonGroup , props ) const ElementType = getElementType ( ButtonGroup , props ) if ( _ . isNil ( buttons ) ) { return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( buttons , button => Button . create ( button ) ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default ButtonGroup ; ``` This code defines a React component named `ButtonGroup`. It takes various props, such as `attached`, `basic`, `buttons`, `children`, `className`, `color`, `compact`, `content`, `floated`, `fluid`, `icon`, `inverted`, `labeled`, `negative`, `positive`, `primary`, `secondary`, `size`, `toggle`, `vertical`, and `widths`, and uses them to determine the classes and behavior of the component. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props. It also uses the `getUnhandledProps` and `getElementType` functions from the `react-bootstrap` library to handle props and determine the element type of the component, respectively. If the `buttons` prop is not provided, the component renders the `children` prop or the `content` prop if `children` is not provided. If the `buttons` prop is provided, the component maps over the buttons and creates a `Button` component for each one using the `Button.create` method. The component is exported as the default export of the module. Note that this code assumes that the"
      ]
    ],
    "filtered_resps": [
      " export default ButtonGroup ; ``` This code defines a React component named `ButtonGroup`. It takes various props, such as `attached`, `basic`, `buttons`, `children`, `className`, `color`, `compact`, `content`, `floated`, `fluid`, `icon`, `inverted`, `labeled`, `negative`, `positive`, `primary`, `secondary`, `size`, `toggle`, `vertical`, and `widths`, and uses them to determine the classes and behavior of the component. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props. It also uses the `getUnhandledProps` and `getElementType` functions from the `react-bootstrap` library to handle props and determine the element type of the component, respectively. If the `buttons` prop is not provided, the component renders the `children` prop or the `content` prop if `children` is not provided. If the `buttons` prop is provided, the component maps over the buttons and creates a `Button` component for each one using the `Button.create` method. The component is exported as the default export of the module. Note that this code assumes that the"
    ],
    "smoothed_bleu_4": 0.44833663759284287
  },
  {
    "doc_id": 31,
    "doc": {
      "id": 31,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Grid/GridRow.js",
      "func_name": "GridRow",
      "original_string": "function GridRow(props) {\n  const {\n    centered,\n    children,\n    className,\n    color,\n    columns,\n    divided,\n    only,\n    reversed,\n    stretched,\n    textAlign,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    color,\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(divided, 'divided'),\n    useKeyOnly(stretched, 'stretched'),\n    useMultipleProp(only, 'only'),\n    useMultipleProp(reversed, 'reversed'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column', true),\n    'row',\n    className,\n  )\n  const rest = getUnhandledProps(GridRow, props)\n  const ElementType = getElementType(GridRow, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function GridRow(props) {\n  const {\n    centered,\n    children,\n    className,\n    color,\n    columns,\n    divided,\n    only,\n    reversed,\n    stretched,\n    textAlign,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    color,\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(divided, 'divided'),\n    useKeyOnly(stretched, 'stretched'),\n    useMultipleProp(only, 'only'),\n    useMultipleProp(reversed, 'reversed'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column', true),\n    'row',\n    className,\n  )\n  const rest = getUnhandledProps(GridRow, props)\n  const ElementType = getElementType(GridRow, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "GridRow",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "centered",
        ",",
        "children",
        ",",
        "className",
        ",",
        "color",
        ",",
        "columns",
        ",",
        "divided",
        ",",
        "only",
        ",",
        "reversed",
        ",",
        "stretched",
        ",",
        "textAlign",
        ",",
        "verticalAlign",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "color",
        ",",
        "useKeyOnly",
        "(",
        "centered",
        ",",
        "'centered'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "divided",
        ",",
        "'divided'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "stretched",
        ",",
        "'stretched'",
        ")",
        ",",
        "useMultipleProp",
        "(",
        "only",
        ",",
        "'only'",
        ")",
        ",",
        "useMultipleProp",
        "(",
        "reversed",
        ",",
        "'reversed'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "useWidthProp",
        "(",
        "columns",
        ",",
        "'column'",
        ",",
        "true",
        ")",
        ",",
        "'row'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "GridRow",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "GridRow",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A row sub-component for Grid.",
      "docstring_tokens": [
        "A",
        "row",
        "sub",
        "-",
        "component",
        "for",
        "Grid",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Grid/GridRow.js#L20-L56"
    },
    "target": "A row sub - component for Grid .",
    "arguments": [
      [
        "function GridRow ( props ) { const { centered , children , className , color , columns , divided , only , reversed , stretched , textAlign , verticalAlign , } = props const classes = cx ( color , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( divided , 'divided' ) , useKeyOnly ( stretched , 'stretched' ) , useMultipleProp ( only , 'only' ) , useMultipleProp ( reversed , 'reversed' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' , true ) , 'row' , className , ) const rest = getUnhandledProps ( GridRow , props ) const ElementType = getElementType ( GridRow , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " GridRow. defaultProps = { as : 'div', } GridRow. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), centered : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, color : PropTypes. string, columns : PropTypes. oneOfType ( [ PropTypes. number, PropTypes. string ] ), divided : PropTypes. bool, only : PropTypes. oneOfType ( [ PropTypes. number, PropTypes. string ] ), reversed : PropTypes. bool, stretched : PropTypes. bool, textAlign : PropTypes. string, verticalAlign : PropTypes. string, } GridRow. displayName = 'GridRow' export default GridRow ; ``` This code defines a React component named `GridRow` that represents a row in a grid. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props passed to the component. The component accepts various props, including `centered`, `children`, `className`, `color`, `columns`, `divided`, `only`, `reversed`, `stretched`, `textAlign`, and `verticalAlign`, which are used to customize the appearance and behavior of the row."
      ]
    ],
    "filtered_resps": [
      " GridRow. defaultProps = { as : 'div', } GridRow. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), centered : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, color : PropTypes. string, columns : PropTypes. oneOfType ( [ PropTypes. number, PropTypes. string ] ), divided : PropTypes. bool, only : PropTypes. oneOfType ( [ PropTypes. number, PropTypes. string ] ), reversed : PropTypes. bool, stretched : PropTypes. bool, textAlign : PropTypes. string, verticalAlign : PropTypes. string, } GridRow. displayName = 'GridRow' export default GridRow ; ``` This code defines a React component named `GridRow` that represents a row in a grid. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props passed to the component. The component accepts various props, including `centered`, `children`, `className`, `color`, `columns`, `divided`, `only`, `reversed`, `stretched`, `textAlign`, and `verticalAlign`, which are used to customize the appearance and behavior of the row."
    ],
    "smoothed_bleu_4": 0.799188158323888
  },
  {
    "doc_id": 32,
    "doc": {
      "id": 32,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Form/FormField.js",
      "func_name": "FormField",
      "original_string": "function FormField(props) {\n  const {\n    children,\n    className,\n    content,\n    control,\n    disabled,\n    error,\n    inline,\n    label,\n    required,\n    type,\n    width,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(required, 'required'),\n    useWidthProp(width, 'wide'),\n    'field',\n    className,\n  )\n  const rest = getUnhandledProps(FormField, props)\n  const ElementType = getElementType(FormField, props)\n\n  // ----------------------------------------\n  // No Control\n  // ----------------------------------------\n\n  if (_.isNil(control)) {\n    if (_.isNil(label)) {\n      return (\n        <ElementType {...rest} className={classes}>\n          {childrenUtils.isNil(children) ? content : children}\n        </ElementType>\n      )\n    }\n\n    return (\n      <ElementType {...rest} className={classes}>\n        {createHTMLLabel(label, { autoGenerateKey: false })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Checkbox/Radio Control\n  // ----------------------------------------\n  const controlProps = { ...rest, content, children, disabled, required, type }\n\n  // wrap HTML checkboxes/radios in the label\n  if (control === 'input' && (type === 'checkbox' || type === 'radio')) {\n    return (\n      <ElementType className={classes}>\n        <label>\n          {createElement(control, controlProps)} {label}\n        </label>\n      </ElementType>\n    )\n  }\n\n  // pass label prop to controls that support it\n  if (control === Checkbox || control === Radio) {\n    return (\n      <ElementType className={classes}>\n        {createElement(control, { ...controlProps, label })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Other Control\n  // ----------------------------------------\n\n  return (\n    <ElementType className={classes}>\n      {createHTMLLabel(label, {\n        defaultProps: { htmlFor: _.get(controlProps, 'id') },\n        autoGenerateKey: false,\n      })}\n      {createElement(control, controlProps)}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function FormField(props) {\n  const {\n    children,\n    className,\n    content,\n    control,\n    disabled,\n    error,\n    inline,\n    label,\n    required,\n    type,\n    width,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(required, 'required'),\n    useWidthProp(width, 'wide'),\n    'field',\n    className,\n  )\n  const rest = getUnhandledProps(FormField, props)\n  const ElementType = getElementType(FormField, props)\n\n  // ----------------------------------------\n  // No Control\n  // ----------------------------------------\n\n  if (_.isNil(control)) {\n    if (_.isNil(label)) {\n      return (\n        <ElementType {...rest} className={classes}>\n          {childrenUtils.isNil(children) ? content : children}\n        </ElementType>\n      )\n    }\n\n    return (\n      <ElementType {...rest} className={classes}>\n        {createHTMLLabel(label, { autoGenerateKey: false })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Checkbox/Radio Control\n  // ----------------------------------------\n  const controlProps = { ...rest, content, children, disabled, required, type }\n\n  // wrap HTML checkboxes/radios in the label\n  if (control === 'input' && (type === 'checkbox' || type === 'radio')) {\n    return (\n      <ElementType className={classes}>\n        <label>\n          {createElement(control, controlProps)} {label}\n        </label>\n      </ElementType>\n    )\n  }\n\n  // pass label prop to controls that support it\n  if (control === Checkbox || control === Radio) {\n    return (\n      <ElementType className={classes}>\n        {createElement(control, { ...controlProps, label })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Other Control\n  // ----------------------------------------\n\n  return (\n    <ElementType className={classes}>\n      {createHTMLLabel(label, {\n        defaultProps: { htmlFor: _.get(controlProps, 'id') },\n        autoGenerateKey: false,\n      })}\n      {createElement(control, controlProps)}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "FormField",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "control",
        ",",
        "disabled",
        ",",
        "error",
        ",",
        "inline",
        ",",
        "label",
        ",",
        "required",
        ",",
        "type",
        ",",
        "width",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "error",
        ",",
        "'error'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inline",
        ",",
        "'inline'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "required",
        ",",
        "'required'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "width",
        ",",
        "'wide'",
        ")",
        ",",
        "'field'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "FormField",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "FormField",
        ",",
        "props",
        ")",
        "// ----------------------------------------",
        "// No Control",
        "// ----------------------------------------",
        "if",
        "(",
        "_",
        ".",
        "isNil",
        "(",
        "control",
        ")",
        ")",
        "{",
        "if",
        "(",
        "_",
        ".",
        "isNil",
        "(",
        "label",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n          ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n        ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "createHTMLLabel",
        "(",
        "label",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "// ----------------------------------------",
        "// Checkbox/Radio Control",
        "// ----------------------------------------",
        "const",
        "controlProps",
        "=",
        "{",
        "...",
        "rest",
        ",",
        "content",
        ",",
        "children",
        ",",
        "disabled",
        ",",
        "required",
        ",",
        "type",
        "}",
        "// wrap HTML checkboxes/radios in the label",
        "if",
        "(",
        "control",
        "===",
        "'input'",
        "&&",
        "(",
        "type",
        "===",
        "'checkbox'",
        "||",
        "type",
        "===",
        "'radio'",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "<",
        "label",
        ">",
        "\n          ",
        "{",
        "createElement",
        "(",
        "control",
        ",",
        "controlProps",
        ")",
        "}",
        " ",
        "{",
        "label",
        "}",
        "\n        ",
        "<",
        "/",
        "label",
        ">",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "// pass label prop to controls that support it",
        "if",
        "(",
        "control",
        "===",
        "Checkbox",
        "||",
        "control",
        "===",
        "Radio",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "createElement",
        "(",
        "control",
        ",",
        "{",
        "...",
        "controlProps",
        ",",
        "label",
        "}",
        ")",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "// ----------------------------------------",
        "// Other Control",
        "// ----------------------------------------",
        "return",
        "(",
        "<",
        "ElementType",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "createHTMLLabel",
        "(",
        "label",
        ",",
        "{",
        "defaultProps",
        ":",
        "{",
        "htmlFor",
        ":",
        "_",
        ".",
        "get",
        "(",
        "controlProps",
        ",",
        "'id'",
        ")",
        "}",
        ",",
        "autoGenerateKey",
        ":",
        "false",
        ",",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "createElement",
        "(",
        "control",
        ",",
        "controlProps",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A field is a form element containing a label and an input.\n@see Form\n@see Button\n@see Checkbox\n@see Dropdown\n@see Input\n@see Radio\n@see Select\n@see Visibility",
      "docstring_tokens": [
        "A",
        "field",
        "is",
        "a",
        "form",
        "element",
        "containing",
        "a",
        "label",
        "and",
        "an",
        "input",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Form/FormField.js#L30-L115"
    },
    "target": "A field is a form element containing a label and an input .",
    "arguments": [
      [
        "function FormField ( props ) { const { children , className , content , control , disabled , error , inline , label , required , type , width , } = props const classes = cx ( useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( required , 'required' ) , useWidthProp ( width , 'wide' ) , 'field' , className , ) const rest = getUnhandledProps ( FormField , props ) const ElementType = getElementType ( FormField , props ) // ---------------------------------------- // No Control // ---------------------------------------- if ( _ . isNil ( control ) ) { if ( _ . isNil ( label ) ) { return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createHTMLLabel ( label , { autoGenerateKey : false } ) } < / ElementType > ) } // ---------------------------------------- // Checkbox/Radio Control // ---------------------------------------- const controlProps = { ... rest , content , children , disabled , required , type } // wrap HTML checkboxes/radios in the label if ( control === 'input' && ( type === 'checkbox' || type === 'radio' ) ) { return ( < ElementType className = { classes } > < label > { createElement ( control , controlProps ) } { label } < / label > < / ElementType > ) } // pass label prop to controls that support it if ( control === Checkbox || control === Radio ) { return ( < ElementType className = { classes } > { createElement ( control , { ... controlProps , label } ) } < / ElementType > ) } // ---------------------------------------- // Other Control // ---------------------------------------- return ( < ElementType className = { classes } > { createHTMLLabel ( label , { defaultProps : { htmlFor : _ . get ( controlProps , 'id' ) } , autoGenerateKey : false , } ) } { createElement ( control , controlProps ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " FormField. propTypes = { children : _. func, className : _. string, content : _. string, control : _. oneOfType ( [ _. func, _. string ] ), disabled : _. bool, error : _. bool, inline : _. bool, label : _. oneOfType ( [ _. func, _. string ] ), required : _. bool, type : _. oneOf ( [ 'checkbox', 'radio' ] ), width : _. oneOfType ( [ _. number, _. string ] ), } FormField. defaultProps = { control : 'input', type : 'text', } module. exports = FormField ; })(); });\n```\nThis code defines a React component called `FormField` that represents a form field. It takes various props such as `children`, `className`, `content`, `control`, `disabled`, `error`, `inline`, `label`, `required`, `type`, and `width`. The component uses various utility functions such as `cx`, `useKeyOnly`, `getUnhandledProps`, `getElementType`, and `createElement` to handle the props and render the form field.\n\nThe component has"
      ]
    ],
    "filtered_resps": [
      " FormField. propTypes = { children : _. func, className : _. string, content : _. string, control : _. oneOfType ( [ _. func, _. string ] ), disabled : _. bool, error : _. bool, inline : _. bool, label : _. oneOfType ( [ _. func, _. string ] ), required : _. bool, type : _. oneOf ( [ 'checkbox', 'radio' ] ), width : _. oneOfType ( [ _. number, _. string ] ), } FormField. defaultProps = { control : 'input', type : 'text', } module. exports = FormField ; })(); });\n```\nThis code defines a React component called `FormField` that represents a form field. It takes various props such as `children`, `className`, `content`, `control`, `disabled`, `error`, `inline`, `label`, `required`, `type`, and `width`. The component uses various utility functions such as `cx`, `useKeyOnly`, `getUnhandledProps`, `getElementType`, and `createElement` to handle the props and render the form field.\n\nThe component has"
    ],
    "smoothed_bleu_4": 0.7744473647311378
  },
  {
    "doc_id": 33,
    "doc": {
      "id": 33,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Card/CardContent.js",
      "func_name": "CardContent",
      "original_string": "function CardContent(props) {\n  const { children, className, content, description, extra, header, meta, textAlign } = props\n\n  const classes = cx(useKeyOnly(extra, 'extra'), useTextAlignProp(textAlign), 'content', className)\n  const rest = getUnhandledProps(CardContent, props)\n  const ElementType = getElementType(CardContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(CardHeader, val => ({ content: val }), header, { autoGenerateKey: false })}\n      {createShorthand(CardMeta, val => ({ content: val }), meta, { autoGenerateKey: false })}\n      {createShorthand(CardDescription, val => ({ content: val }), description, {\n        autoGenerateKey: false,\n      })}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function CardContent(props) {\n  const { children, className, content, description, extra, header, meta, textAlign } = props\n\n  const classes = cx(useKeyOnly(extra, 'extra'), useTextAlignProp(textAlign), 'content', className)\n  const rest = getUnhandledProps(CardContent, props)\n  const ElementType = getElementType(CardContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(CardHeader, val => ({ content: val }), header, { autoGenerateKey: false })}\n      {createShorthand(CardMeta, val => ({ content: val }), meta, { autoGenerateKey: false })}\n      {createShorthand(CardDescription, val => ({ content: val }), description, {\n        autoGenerateKey: false,\n      })}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "CardContent",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "description",
        ",",
        "extra",
        ",",
        "header",
        ",",
        "meta",
        ",",
        "textAlign",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "extra",
        ",",
        "'extra'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "'content'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "CardContent",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "CardContent",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "CardHeader",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "content",
        ":",
        "val",
        "}",
        ")",
        ",",
        "header",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "CardMeta",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "content",
        ":",
        "val",
        "}",
        ")",
        ",",
        "meta",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "CardDescription",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "content",
        ":",
        "val",
        "}",
        ")",
        ",",
        "description",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        ",",
        "}",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A card can contain blocks of content or extra content meant to be formatted separately from the main content.",
      "docstring_tokens": [
        "A",
        "card",
        "can",
        "contain",
        "blocks",
        "of",
        "content",
        "or",
        "extra",
        "content",
        "meant",
        "to",
        "be",
        "formatted",
        "separately",
        "from",
        "the",
        "main",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Card/CardContent.js#L23-L54"
    },
    "target": "A card can contain blocks of content or extra content meant to be formatted separately from the main content .",
    "arguments": [
      [
        "function CardContent ( props ) { const { children , className , content , description , extra , header , meta , textAlign } = props const classes = cx ( useKeyOnly ( extra , 'extra' ) , useTextAlignProp ( textAlign ) , 'content' , className ) const rest = getUnhandledProps ( CardContent , props ) const ElementType = getElementType ( CardContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( CardHeader , val => ( { content : val } ) , header , { autoGenerateKey : false } ) } { createShorthand ( CardMeta , val => ( { content : val } ) , meta , { autoGenerateKey : false } ) } { createShorthand ( CardDescription , val => ( { content : val } ) , description , { autoGenerateKey : false , } ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " } export default CardContent ; ``` This code defines the `CardContent` component, which is a part of the `Card` component. It uses the `useKeyOnly` and `useTextAlignProp` utility functions to handle the `extra` and `textAlign` props, respectively. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop. The component then checks if the `children` prop is not null or undefined, and if so, it renders the children. If the `content` prop is not null or undefined, it renders the content. If neither of these conditions is met, it renders the `CardHeader`, `CardMeta`, and `CardDescription` components with the provided props. The `createShorthand` function is used to create shorthand props for these components. The `autoGenerateKey` option is set to `false` to prevent the component from automatically generating a key for the shorthand props. The `CardContent` component is then exported as the default export of the module. ```javascript\nimport React from'react';\nimport { createShorthand"
      ]
    ],
    "filtered_resps": [
      " } export default CardContent ; ``` This code defines the `CardContent` component, which is a part of the `Card` component. It uses the `useKeyOnly` and `useTextAlignProp` utility functions to handle the `extra` and `textAlign` props, respectively. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop. The component then checks if the `children` prop is not null or undefined, and if so, it renders the children. If the `content` prop is not null or undefined, it renders the content. If neither of these conditions is met, it renders the `CardHeader`, `CardMeta`, and `CardDescription` components with the provided props. The `createShorthand` function is used to create shorthand props for these components. The `autoGenerateKey` option is set to `false` to prevent the component from automatically generating a key for the shorthand props. The `CardContent` component is then exported as the default export of the module. ```javascript\nimport React from'react';\nimport { createShorthand"
    ],
    "smoothed_bleu_4": 0.9128556426850293
  },
  {
    "doc_id": 34,
    "doc": {
      "id": 34,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Item/Item.js",
      "func_name": "Item",
      "original_string": "function Item(props) {\n  const { children, className, content, description, extra, header, image, meta } = props\n\n  const classes = cx('item', className)\n  const rest = getUnhandledProps(Item, props)\n  const ElementType = getElementType(Item, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {ItemImage.create(image, { autoGenerateKey: false })}\n\n      <ItemContent\n        content={content}\n        description={description}\n        extra={extra}\n        header={header}\n        meta={meta}\n      />\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Item(props) {\n  const { children, className, content, description, extra, header, image, meta } = props\n\n  const classes = cx('item', className)\n  const rest = getUnhandledProps(Item, props)\n  const ElementType = getElementType(Item, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {ItemImage.create(image, { autoGenerateKey: false })}\n\n      <ItemContent\n        content={content}\n        description={description}\n        extra={extra}\n        header={header}\n        meta={meta}\n      />\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Item",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "description",
        ",",
        "extra",
        ",",
        "header",
        ",",
        "image",
        ",",
        "meta",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'item'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Item",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Item",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "ItemImage",
        ".",
        "create",
        "(",
        "image",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n\n      ",
        "<",
        "ItemContent",
        "content",
        "=",
        "{",
        "content",
        "}",
        "description",
        "=",
        "{",
        "description",
        "}",
        "extra",
        "=",
        "{",
        "extra",
        "}",
        "header",
        "=",
        "{",
        "header",
        "}",
        "meta",
        "=",
        "{",
        "meta",
        "}",
        "/",
        ">",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "An item view presents large collections of site content for display.",
      "docstring_tokens": [
        "An",
        "item",
        "view",
        "presents",
        "large",
        "collections",
        "of",
        "site",
        "content",
        "for",
        "display",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Item/Item.js#L17-L45"
    },
    "target": "An item view presents large collections of site content for display .",
    "arguments": [
      [
        "function Item ( props ) { const { children , className , content , description , extra , header , image , meta } = props const classes = cx ( 'item' , className ) const rest = getUnhandledProps ( Item , props ) const ElementType = getElementType ( Item , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ItemImage . create ( image , { autoGenerateKey : false } ) } < ItemContent content = { content } description = { description } extra = { extra } header = { header } meta = { meta } / > < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Item. displayName = 'Item' Item. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. node, extra : PropTypes. node, header : PropTypes. node, image : PropTypes. node, meta : PropTypes. node, } Item. defaultProps = { className : '', } export default Item ; ``` This code defines a React component named `Item` that represents a single item in a list. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes to the component based on the `className` prop. The `getUnhandledProps` function is used to extract the props that are not handled by the component, and the `getElementType` function is used to determine the HTML element type of the component based on the `as` prop. The component has several props, including `children`, `className`, `content`, `description`, `extra`, `header`, `image`, and `meta`. If the `children` prop is not null or undefined, the component returns the children wrapped in the `ElementType` component. Otherwise, it returns the component with an `ItemImage` component and an `ItemContent` component. The"
      ]
    ],
    "filtered_resps": [
      " Item. displayName = 'Item' Item. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. node, extra : PropTypes. node, header : PropTypes. node, image : PropTypes. node, meta : PropTypes. node, } Item. defaultProps = { className : '', } export default Item ; ``` This code defines a React component named `Item` that represents a single item in a list. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes to the component based on the `className` prop. The `getUnhandledProps` function is used to extract the props that are not handled by the component, and the `getElementType` function is used to determine the HTML element type of the component based on the `as` prop. The component has several props, including `children`, `className`, `content`, `description`, `extra`, `header`, `image`, and `meta`. If the `children` prop is not null or undefined, the component returns the children wrapped in the `ElementType` component. Otherwise, it returns the component with an `ItemImage` component and an `ItemContent` component. The"
    ],
    "smoothed_bleu_4": 0.5858400310740779
  },
  {
    "doc_id": 35,
    "doc": {
      "id": 35,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Comment/CommentAvatar.js",
      "func_name": "CommentAvatar",
      "original_string": "function CommentAvatar(props) {\n  const { className, src } = props\n\n  const classes = cx('avatar', className)\n  const rest = getUnhandledProps(CommentAvatar, props)\n  const [imageProps, rootProps] = partitionHTMLProps(rest, { htmlProps: htmlImageProps })\n  const ElementType = getElementType(CommentAvatar, props)\n\n  return (\n    <ElementType {...rootProps} className={classes}>\n      {createHTMLImage(src, { autoGenerateKey: false, defaultProps: imageProps })}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function CommentAvatar(props) {\n  const { className, src } = props\n\n  const classes = cx('avatar', className)\n  const rest = getUnhandledProps(CommentAvatar, props)\n  const [imageProps, rootProps] = partitionHTMLProps(rest, { htmlProps: htmlImageProps })\n  const ElementType = getElementType(CommentAvatar, props)\n\n  return (\n    <ElementType {...rootProps} className={classes}>\n      {createHTMLImage(src, { autoGenerateKey: false, defaultProps: imageProps })}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "CommentAvatar",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        ",",
        "src",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'avatar'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "CommentAvatar",
        ",",
        "props",
        ")",
        "const",
        "[",
        "imageProps",
        ",",
        "rootProps",
        "]",
        "=",
        "partitionHTMLProps",
        "(",
        "rest",
        ",",
        "{",
        "htmlProps",
        ":",
        "htmlImageProps",
        "}",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "CommentAvatar",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rootProps",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "createHTMLImage",
        "(",
        "src",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        ",",
        "defaultProps",
        ":",
        "imageProps",
        "}",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A comment can contain an image or avatar.",
      "docstring_tokens": [
        "A",
        "comment",
        "can",
        "contain",
        "an",
        "image",
        "or",
        "avatar",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Comment/CommentAvatar.js#L17-L30"
    },
    "target": "A comment can contain an image or avatar .",
    "arguments": [
      [
        "function CommentAvatar ( props ) { const { className , src } = props const classes = cx ( 'avatar' , className ) const rest = getUnhandledProps ( CommentAvatar , props ) const [ imageProps , rootProps ] = partitionHTMLProps ( rest , { htmlProps : htmlImageProps } ) const ElementType = getElementType ( CommentAvatar , props ) return ( < ElementType { ... rootProps } className = { classes } > { createHTMLImage ( src , { autoGenerateKey : false , defaultProps : imageProps } ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " CommentAvatar. displayName = 'Avatar' CommentAvatar. propTypes = { src : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. object ] ). isRequired, className : PropTypes. string, } CommentAvatar. defaultProps = { src : '', } export default CommentAvatar ; ```\n  - ```bash\n  npm run build\n  ```\n\nThis code defines a React component called `CommentAvatar` that displays an avatar image. The component takes two props: `src` and `className`. The `src` prop is required and can be either a string or an object. The `className` prop is optional and can be used to add custom CSS classes to the avatar image.\n\nThe component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop. It also uses the `getUnhandledProps` function to remove any props that are not handled by the component.\n\nThe component then uses the `partitionHTMLProps` function to split the remaining props into two groups: `imageProps` and `rootProps`. The `imageProps` group contains props that are specific to the image element, while the `rootProps` group contains props that are specific to the root"
      ]
    ],
    "filtered_resps": [
      " CommentAvatar. displayName = 'Avatar' CommentAvatar. propTypes = { src : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. object ] ). isRequired, className : PropTypes. string, } CommentAvatar. defaultProps = { src : '', } export default CommentAvatar ; ```\n  - ```bash\n  npm run build\n  ```\n\nThis code defines a React component called `CommentAvatar` that displays an avatar image. The component takes two props: `src` and `className`. The `src` prop is required and can be either a string or an object. The `className` prop is optional and can be used to add custom CSS classes to the avatar image.\n\nThe component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop. It also uses the `getUnhandledProps` function to remove any props that are not handled by the component.\n\nThe component then uses the `partitionHTMLProps` function to split the remaining props into two groups: `imageProps` and `rootProps`. The `imageProps` group contains props that are specific to the image element, while the `rootProps` group contains props that are specific to the root"
    ],
    "smoothed_bleu_4": 0.6885022608348378
  },
  {
    "doc_id": 36,
    "doc": {
      "id": 36,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Statistic/StatisticLabel.js",
      "func_name": "StatisticLabel",
      "original_string": "function StatisticLabel(props) {\n  const { children, className, content } = props\n  const classes = cx('label', className)\n  const rest = getUnhandledProps(StatisticLabel, props)\n  const ElementType = getElementType(StatisticLabel, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function StatisticLabel(props) {\n  const { children, className, content } = props\n  const classes = cx('label', className)\n  const rest = getUnhandledProps(StatisticLabel, props)\n  const ElementType = getElementType(StatisticLabel, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "StatisticLabel",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'label'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "StatisticLabel",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "StatisticLabel",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A statistic can contain a label to help provide context for the presented value.",
      "docstring_tokens": [
        "A",
        "statistic",
        "can",
        "contain",
        "a",
        "label",
        "to",
        "help",
        "provide",
        "context",
        "for",
        "the",
        "presented",
        "value",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Statistic/StatisticLabel.js#L16-L27"
    },
    "target": "A statistic can contain a label to help provide context for the presented value .",
    "arguments": [
      [
        "function StatisticLabel ( props ) { const { children , className , content } = props const classes = cx ( 'label' , className ) const rest = getUnhandledProps ( StatisticLabel , props ) const ElementType = getElementType ( StatisticLabel , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " StatisticLabel. defaultProps = { content : '' } export default StatisticLabel ; ``` This code defines a React component named `StatisticLabel` that displays a label for a statistic. The component takes in several props, including `children`, `className`, and `content`. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop. The component then returns a JSX element with the `children` or `content` prop rendered inside it. The `defaultProps` object is used to set the default value of the `content` prop to an empty string. Finally, the component is exported as the default export of the module.\n## Step 3: Create a test file for the StatisticLabel component\nCreate a new file named `StatisticLabel.test.js` in the same directory as the `StatisticLabel.js` file. This file will contain tests for the `StatisticLabel` component.\n\n```javascript\nimport React from'react' ;"
      ]
    ],
    "filtered_resps": [
      " StatisticLabel. defaultProps = { content : '' } export default StatisticLabel ; ``` This code defines a React component named `StatisticLabel` that displays a label for a statistic. The component takes in several props, including `children`, `className`, and `content`. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop. The component then returns a JSX element with the `children` or `content` prop rendered inside it. The `defaultProps` object is used to set the default value of the `content` prop to an empty string. Finally, the component is exported as the default export of the module.\n## Step 3: Create a test file for the StatisticLabel component\nCreate a new file named `StatisticLabel.test.js` in the same directory as the `StatisticLabel.js` file. This file will contain tests for the `StatisticLabel` component.\n\n```javascript\nimport React from'react' ;"
    ],
    "smoothed_bleu_4": 1.0338670034893092
  },
  {
    "doc_id": 37,
    "doc": {
      "id": 37,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Feed/FeedMeta.js",
      "func_name": "FeedMeta",
      "original_string": "function FeedMeta(props) {\n  const { children, className, content, like } = props\n\n  const classes = cx('meta', className)\n  const rest = getUnhandledProps(FeedMeta, props)\n  const ElementType = getElementType(FeedMeta, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedLike, val => ({ content: val }), like, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function FeedMeta(props) {\n  const { children, className, content, like } = props\n\n  const classes = cx('meta', className)\n  const rest = getUnhandledProps(FeedMeta, props)\n  const ElementType = getElementType(FeedMeta, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedLike, val => ({ content: val }), like, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "FeedMeta",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "like",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'meta'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "FeedMeta",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "FeedMeta",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "FeedLike",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "content",
        ":",
        "val",
        "}",
        ")",
        ",",
        "like",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "content",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A feed can contain a meta.",
      "docstring_tokens": [
        "A",
        "feed",
        "can",
        "contain",
        "a",
        "meta",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedMeta.js#L17-L38"
    },
    "target": "A feed can contain a meta .",
    "arguments": [
      [
        "function FeedMeta ( props ) { const { children , className , content , like } = props const classes = cx ( 'meta' , className ) const rest = getUnhandledProps ( FeedMeta , props ) const ElementType = getElementType ( FeedMeta , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedLike , val => ( { content : val } ) , like , { autoGenerateKey : false } ) } { content } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " FeedMeta. propTypes = { children : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ), className : PropTypes. string, content : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ), like : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ) } FeedMeta. defaultProps = { like : undefined } export default FeedMeta } ``` This code defines the `FeedMeta` component, which is a wrapper around the `FeedLike` and `FeedContent` components. It takes in several props, including `children`, `className`, `content`, and `like`. It uses the `cx` function to conditionally add a class to the component based on the presence of the `children` prop. If `children` is present, it renders the children inside the component. If `children` is not present, it renders the `FeedLike` and `FeedContent` components inside the component. The `createShorthand` function is used to create a shorthand for the `FeedLike` component. The `propTypes` and `defaultProps` are defined to specify the expected types and default values for the props. Finally, the component is exported as the default export"
      ]
    ],
    "filtered_resps": [
      " FeedMeta. propTypes = { children : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ), className : PropTypes. string, content : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ), like : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ) } FeedMeta. defaultProps = { like : undefined } export default FeedMeta } ``` This code defines the `FeedMeta` component, which is a wrapper around the `FeedLike` and `FeedContent` components. It takes in several props, including `children`, `className`, `content`, and `like`. It uses the `cx` function to conditionally add a class to the component based on the presence of the `children` prop. If `children` is present, it renders the children inside the component. If `children` is not present, it renders the `FeedLike` and `FeedContent` components inside the component. The `createShorthand` function is used to create a shorthand for the `FeedLike` component. The `propTypes` and `defaultProps` are defined to specify the expected types and default values for the props. Finally, the component is exported as the default export"
    ],
    "smoothed_bleu_4": 0.550086489261092
  },
  {
    "doc_id": 38,
    "doc": {
      "id": 38,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Container/Container.js",
      "func_name": "Container",
      "original_string": "function Container(props) {\n  const { children, className, content, fluid, text, textAlign } = props\n  const classes = cx(\n    'ui',\n    useKeyOnly(text, 'text'),\n    useKeyOnly(fluid, 'fluid'),\n    useTextAlignProp(textAlign),\n    'container',\n    className,\n  )\n  const rest = getUnhandledProps(Container, props)\n  const ElementType = getElementType(Container, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Container(props) {\n  const { children, className, content, fluid, text, textAlign } = props\n  const classes = cx(\n    'ui',\n    useKeyOnly(text, 'text'),\n    useKeyOnly(fluid, 'fluid'),\n    useTextAlignProp(textAlign),\n    'container',\n    className,\n  )\n  const rest = getUnhandledProps(Container, props)\n  const ElementType = getElementType(Container, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Container",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "fluid",
        ",",
        "text",
        ",",
        "textAlign",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "text",
        ",",
        "'text'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "fluid",
        ",",
        "'fluid'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "'container'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Container",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Container",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A container limits content to a maximum width.",
      "docstring_tokens": [
        "A",
        "container",
        "limits",
        "content",
        "to",
        "a",
        "maximum",
        "width",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Container/Container.js#L18-L36"
    },
    "target": "A container limits content to a maximum width .",
    "arguments": [
      [
        "function Container ( props ) { const { children , className , content , fluid , text , textAlign } = props const classes = cx ( 'ui' , useKeyOnly ( text , 'text' ) , useKeyOnly ( fluid , 'fluid' ) , useTextAlignProp ( textAlign ) , 'container' , className , ) const rest = getUnhandledProps ( Container , props ) const ElementType = getElementType ( Container , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Container. defaultProps = { as : 'div', } Container. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, fluid : PropTypes. bool, textAlign : PropTypes. oneOf ( [ 'left', 'center', 'right' ] ), text : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. string ] ), } Container. displayName = 'Container' Container. __docgenInfo = { description : '', } export default Container ; ```\n\nThis code defines a React component named `Container` that can be used to wrap content in a container element. The component accepts several props, including `children`, `className`, `content`, `fluid`, `text`, and `textAlign`. It uses the `cx` function to conditionally apply CSS classes based on the props, and the `getUnhandledProps` function to remove any unnecessary props from the component. The `getElementType` function is used to determine the type of element to render based on the `as` prop.\n\nThe `Container` component has several default props, including `as` set to `'"
      ]
    ],
    "filtered_resps": [
      " Container. defaultProps = { as : 'div', } Container. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, fluid : PropTypes. bool, textAlign : PropTypes. oneOf ( [ 'left', 'center', 'right' ] ), text : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. string ] ), } Container. displayName = 'Container' Container. __docgenInfo = { description : '', } export default Container ; ```\n\nThis code defines a React component named `Container` that can be used to wrap content in a container element. The component accepts several props, including `children`, `className`, `content`, `fluid`, `text`, and `textAlign`. It uses the `cx` function to conditionally apply CSS classes based on the props, and the `getUnhandledProps` function to remove any unnecessary props from the component. The `getElementType` function is used to determine the type of element to render based on the `as` prop.\n\nThe `Container` component has several default props, including `as` set to `'"
    ],
    "smoothed_bleu_4": 0.7437442340333584
  },
  {
    "doc_id": 39,
    "doc": {
      "id": 39,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Step/StepGroup.js",
      "func_name": "StepGroup",
      "original_string": "function StepGroup(props) {\n  const {\n    attached,\n    children,\n    className,\n    content,\n    fluid,\n    items,\n    ordered,\n    size,\n    stackable,\n    unstackable,\n    vertical,\n    widths,\n  } = props\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(ordered, 'ordered'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useValueAndKey(stackable, 'stackable'),\n    useWidthProp(widths),\n    'steps',\n    className,\n  )\n  const rest = getUnhandledProps(StepGroup, props)\n  const ElementType = getElementType(StepGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(items, item => Step.create(item))}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function StepGroup(props) {\n  const {\n    attached,\n    children,\n    className,\n    content,\n    fluid,\n    items,\n    ordered,\n    size,\n    stackable,\n    unstackable,\n    vertical,\n    widths,\n  } = props\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(ordered, 'ordered'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useValueAndKey(stackable, 'stackable'),\n    useWidthProp(widths),\n    'steps',\n    className,\n  )\n  const rest = getUnhandledProps(StepGroup, props)\n  const ElementType = getElementType(StepGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(items, item => Step.create(item))}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "StepGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "attached",
        ",",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "fluid",
        ",",
        "items",
        ",",
        "ordered",
        ",",
        "size",
        ",",
        "stackable",
        ",",
        "unstackable",
        ",",
        "vertical",
        ",",
        "widths",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "fluid",
        ",",
        "'fluid'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "ordered",
        ",",
        "'ordered'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "unstackable",
        ",",
        "'unstackable'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "vertical",
        ",",
        "'vertical'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "attached",
        ",",
        "'attached'",
        ")",
        ",",
        "useValueAndKey",
        "(",
        "stackable",
        ",",
        "'stackable'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "widths",
        ")",
        ",",
        "'steps'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "StepGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "StepGroup",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "_",
        ".",
        "map",
        "(",
        "items",
        ",",
        "item",
        "=>",
        "Step",
        ".",
        "create",
        "(",
        "item",
        ")",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A set of steps.",
      "docstring_tokens": [
        "A",
        "set",
        "of",
        "steps",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Step/StepGroup.js#L25-L76"
    },
    "target": "A set of steps .",
    "arguments": [
      [
        "function StepGroup ( props ) { const { attached , children , className , content , fluid , items , ordered , size , stackable , unstackable , vertical , widths , } = props const classes = cx ( 'ui' , size , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( ordered , 'ordered' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useValueAndKey ( stackable , 'stackable' ) , useWidthProp ( widths ) , 'steps' , className , ) const rest = getUnhandledProps ( StepGroup , props ) const ElementType = getElementType ( StepGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( items , item => Step . create ( item ) ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " StepGroup. propTypes = { attached : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, fluid : PropTypes. bool, items : PropTypes. array, ordered : PropTypes. bool, size : PropTypes. string, stackable : PropTypes. bool, unstackable : PropTypes. bool, vertical : PropTypes. bool, widths : PropTypes. array, } StepGroup. defaultProps = { attached : false, fluid : false, ordered : false, size : 'large', stackable : false, unstackable : false, vertical : false, } export default StepGroup ; ```\n\nThis code defines a React component called `StepGroup` that represents a group of steps in a progress bar. The component accepts various props, including `attached`, `children`, `className`, `content`, `fluid`, `items`, `ordered`, `size`, `stackable`, `unstackable`, `vertical`, and `widths`. The component uses the `cx` function to conditionally apply CSS classes based on the props, and it uses the `getUnhandledProps` function to remove any unnecessary props from the component's props object. The component also uses the `getElementType` function"
      ]
    ],
    "filtered_resps": [
      " StepGroup. propTypes = { attached : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, fluid : PropTypes. bool, items : PropTypes. array, ordered : PropTypes. bool, size : PropTypes. string, stackable : PropTypes. bool, unstackable : PropTypes. bool, vertical : PropTypes. bool, widths : PropTypes. array, } StepGroup. defaultProps = { attached : false, fluid : false, ordered : false, size : 'large', stackable : false, unstackable : false, vertical : false, } export default StepGroup ; ```\n\nThis code defines a React component called `StepGroup` that represents a group of steps in a progress bar. The component accepts various props, including `attached`, `children`, `className`, `content`, `fluid`, `items`, `ordered`, `size`, `stackable`, `unstackable`, `vertical`, and `widths`. The component uses the `cx` function to conditionally apply CSS classes based on the props, and it uses the `getUnhandledProps` function to remove any unnecessary props from the component's props object. The component also uses the `getElementType` function"
    ],
    "smoothed_bleu_4": 0.6857502356558416
  },
  {
    "doc_id": 40,
    "doc": {
      "id": 40,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Divider/Divider.js",
      "func_name": "Divider",
      "original_string": "function Divider(props) {\n  const {\n    children,\n    className,\n    clearing,\n    content,\n    fitted,\n    hidden,\n    horizontal,\n    inverted,\n    section,\n    vertical,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(clearing, 'clearing'),\n    useKeyOnly(fitted, 'fitted'),\n    useKeyOnly(hidden, 'hidden'),\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(section, 'section'),\n    useKeyOnly(vertical, 'vertical'),\n    'divider',\n    className,\n  )\n  const rest = getUnhandledProps(Divider, props)\n  const ElementType = getElementType(Divider, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Divider(props) {\n  const {\n    children,\n    className,\n    clearing,\n    content,\n    fitted,\n    hidden,\n    horizontal,\n    inverted,\n    section,\n    vertical,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(clearing, 'clearing'),\n    useKeyOnly(fitted, 'fitted'),\n    useKeyOnly(hidden, 'hidden'),\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(section, 'section'),\n    useKeyOnly(vertical, 'vertical'),\n    'divider',\n    className,\n  )\n  const rest = getUnhandledProps(Divider, props)\n  const ElementType = getElementType(Divider, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Divider",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "clearing",
        ",",
        "content",
        ",",
        "fitted",
        ",",
        "hidden",
        ",",
        "horizontal",
        ",",
        "inverted",
        ",",
        "section",
        ",",
        "vertical",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "clearing",
        ",",
        "'clearing'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "fitted",
        ",",
        "'fitted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "hidden",
        ",",
        "'hidden'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "horizontal",
        ",",
        "'horizontal'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "section",
        ",",
        "'section'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "vertical",
        ",",
        "'vertical'",
        ")",
        ",",
        "'divider'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Divider",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Divider",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A divider visually segments content into groups.",
      "docstring_tokens": [
        "A",
        "divider",
        "visually",
        "segments",
        "content",
        "into",
        "groups",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Divider/Divider.js#L16-L50"
    },
    "target": "A divider visually segments content into groups .",
    "arguments": [
      [
        "function Divider ( props ) { const { children , className , clearing , content , fitted , hidden , horizontal , inverted , section , vertical , } = props const classes = cx ( 'ui' , useKeyOnly ( clearing , 'clearing' ) , useKeyOnly ( fitted , 'fitted' ) , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( section , 'section' ) , useKeyOnly ( vertical , 'vertical' ) , 'divider' , className , ) const rest = getUnhandledProps ( Divider , props ) const ElementType = getElementType ( Divider , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Divider. displayName = 'Divider' export default Divider ; ```\n\nThis code defines a `Divider` component that takes various props to customize its appearance and behavior. It uses the `cx` function to conditionally add CSS classes based on the props, and the `getUnhandledProps` function to extract the props that are not handled by the component. The `getElementType` function is used to determine the type of element to render based on the props. The component then renders the children or a default content string, depending on whether the `children` prop is provided. Finally, the `displayName` property is set to `'Divider'` to help with debugging.\n\nNote that this code assumes that the `cx` function, `getUnhandledProps` function, and `getElementType` function are defined elsewhere in the codebase, and that the `useKeyOnly` function is a utility function that takes a prop value and a CSS class name as arguments and returns the CSS class name if the prop value is truthy. You may need to modify the code to fit your specific use case. \n\nAlso, this code does not handle any potential errors that may occur when rendering the component. You may want to add error handling code to make the component"
      ]
    ],
    "filtered_resps": [
      " Divider. displayName = 'Divider' export default Divider ; ```\n\nThis code defines a `Divider` component that takes various props to customize its appearance and behavior. It uses the `cx` function to conditionally add CSS classes based on the props, and the `getUnhandledProps` function to extract the props that are not handled by the component. The `getElementType` function is used to determine the type of element to render based on the props. The component then renders the children or a default content string, depending on whether the `children` prop is provided. Finally, the `displayName` property is set to `'Divider'` to help with debugging.\n\nNote that this code assumes that the `cx` function, `getUnhandledProps` function, and `getElementType` function are defined elsewhere in the codebase, and that the `useKeyOnly` function is a utility function that takes a prop value and a CSS class name as arguments and returns the CSS class name if the prop value is truthy. You may need to modify the code to fit your specific use case. \n\nAlso, this code does not handle any potential errors that may occur when rendering the component. You may want to add error handling code to make the component"
    ],
    "smoothed_bleu_4": 0.5911064012623435
  },
  {
    "doc_id": 41,
    "doc": {
      "id": 41,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Header/Header.js",
      "func_name": "Header",
      "original_string": "function Header(props) {\n  const {\n    attached,\n    block,\n    children,\n    className,\n    color,\n    content,\n    disabled,\n    dividing,\n    floated,\n    icon,\n    image,\n    inverted,\n    size,\n    sub,\n    subheader,\n    textAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(block, 'block'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(dividing, 'dividing'),\n    useValueAndKey(floated, 'floated'),\n    useKeyOnly(icon === true, 'icon'),\n    useKeyOnly(image === true, 'image'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(sub, 'sub'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useTextAlignProp(textAlign),\n    'header',\n    className,\n  )\n  const rest = getUnhandledProps(Header, props)\n  const ElementType = getElementType(Header, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const iconElement = Icon.create(icon, { autoGenerateKey: false })\n  const imageElement = Image.create(image, { autoGenerateKey: false })\n  const subheaderElement = HeaderSubheader.create(subheader, { autoGenerateKey: false })\n\n  if (iconElement || imageElement) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {iconElement || imageElement}\n        {(content || subheaderElement) && (\n          <HeaderContent>\n            {content}\n            {subheaderElement}\n          </HeaderContent>\n        )}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {content}\n      {subheaderElement}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Header(props) {\n  const {\n    attached,\n    block,\n    children,\n    className,\n    color,\n    content,\n    disabled,\n    dividing,\n    floated,\n    icon,\n    image,\n    inverted,\n    size,\n    sub,\n    subheader,\n    textAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(block, 'block'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(dividing, 'dividing'),\n    useValueAndKey(floated, 'floated'),\n    useKeyOnly(icon === true, 'icon'),\n    useKeyOnly(image === true, 'image'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(sub, 'sub'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useTextAlignProp(textAlign),\n    'header',\n    className,\n  )\n  const rest = getUnhandledProps(Header, props)\n  const ElementType = getElementType(Header, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const iconElement = Icon.create(icon, { autoGenerateKey: false })\n  const imageElement = Image.create(image, { autoGenerateKey: false })\n  const subheaderElement = HeaderSubheader.create(subheader, { autoGenerateKey: false })\n\n  if (iconElement || imageElement) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {iconElement || imageElement}\n        {(content || subheaderElement) && (\n          <HeaderContent>\n            {content}\n            {subheaderElement}\n          </HeaderContent>\n        )}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {content}\n      {subheaderElement}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Header",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "attached",
        ",",
        "block",
        ",",
        "children",
        ",",
        "className",
        ",",
        "color",
        ",",
        "content",
        ",",
        "disabled",
        ",",
        "dividing",
        ",",
        "floated",
        ",",
        "icon",
        ",",
        "image",
        ",",
        "inverted",
        ",",
        "size",
        ",",
        "sub",
        ",",
        "subheader",
        ",",
        "textAlign",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "color",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "block",
        ",",
        "'block'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "dividing",
        ",",
        "'dividing'",
        ")",
        ",",
        "useValueAndKey",
        "(",
        "floated",
        ",",
        "'floated'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "icon",
        "===",
        "true",
        ",",
        "'icon'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "image",
        "===",
        "true",
        ",",
        "'image'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "sub",
        ",",
        "'sub'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "attached",
        ",",
        "'attached'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "'header'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Header",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Header",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "const",
        "iconElement",
        "=",
        "Icon",
        ".",
        "create",
        "(",
        "icon",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "const",
        "imageElement",
        "=",
        "Image",
        ".",
        "create",
        "(",
        "image",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "const",
        "subheaderElement",
        "=",
        "HeaderSubheader",
        ".",
        "create",
        "(",
        "subheader",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "if",
        "(",
        "iconElement",
        "||",
        "imageElement",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "iconElement",
        "||",
        "imageElement",
        "}",
        "\n        ",
        "{",
        "(",
        "content",
        "||",
        "subheaderElement",
        ")",
        "&&",
        "(",
        "<",
        "HeaderContent",
        ">",
        "\n            ",
        "{",
        "content",
        "}",
        "\n            ",
        "{",
        "subheaderElement",
        "}",
        "\n          ",
        "<",
        "/",
        "HeaderContent",
        ">",
        ")",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "content",
        "}",
        "\n      ",
        "{",
        "subheaderElement",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A header provides a short summary of content",
      "docstring_tokens": [
        "A",
        "header",
        "provides",
        "a",
        "short",
        "summary",
        "of",
        "content"
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Header/Header.js#L26-L98"
    },
    "target": "A header provides a short summary of content",
    "arguments": [
      [
        "function Header ( props ) { const { attached , block , children , className , color , content , disabled , dividing , floated , icon , image , inverted , size , sub , subheader , textAlign , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( block , 'block' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( dividing , 'dividing' ) , useValueAndKey ( floated , 'floated' ) , useKeyOnly ( icon === true , 'icon' ) , useKeyOnly ( image === true , 'image' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( sub , 'sub' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useTextAlignProp ( textAlign ) , 'header' , className , ) const rest = getUnhandledProps ( Header , props ) const ElementType = getElementType ( Header , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const iconElement = Icon . create ( icon , { autoGenerateKey : false } ) const imageElement = Image . create ( image , { autoGenerateKey : false } ) const subheaderElement = HeaderSubheader . create ( subheader , { autoGenerateKey : false } ) if ( iconElement || imageElement ) { return ( < ElementType { ... rest } className = { classes } > { iconElement || imageElement } { ( content || subheaderElement ) && ( < HeaderContent > { content } { subheaderElement } < / HeaderContent > ) } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { content } { subheaderElement } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default Header ; ``` This code defines the `Header` component, which is a wrapper around the `HeaderContent` component. It takes various props, such as `attached`, `block`, `children`, `className`, `color`, `content`, `disabled`, `dividing`, `floated`, `icon`, `image`, `inverted`, `size`, `sub`, `subheader`, `textAlign`, and passes them to the `getUnhandledProps` function to remove any unnecessary props. It then uses the `getElementType` function to determine the type of element to render (e.g., `h1`, `h2`, etc.). If the `children` prop is not null or undefined, it renders the children inside the `ElementType` component with the `classes` and `rest` props. If the `icon` or `image` prop is truthy, it renders the corresponding icon or image element inside the `ElementType` component. If the `subheader` prop is truthy, it renders the `HeaderSubheader` component inside the `HeaderContent` component. Finally, it returns the `ElementType` component with the `classes` and `rest` props. Note that this code uses the `"
      ]
    ],
    "filtered_resps": [
      " export default Header ; ``` This code defines the `Header` component, which is a wrapper around the `HeaderContent` component. It takes various props, such as `attached`, `block`, `children`, `className`, `color`, `content`, `disabled`, `dividing`, `floated`, `icon`, `image`, `inverted`, `size`, `sub`, `subheader`, `textAlign`, and passes them to the `getUnhandledProps` function to remove any unnecessary props. It then uses the `getElementType` function to determine the type of element to render (e.g., `h1`, `h2`, etc.). If the `children` prop is not null or undefined, it renders the children inside the `ElementType` component with the `classes` and `rest` props. If the `icon` or `image` prop is truthy, it renders the corresponding icon or image element inside the `ElementType` component. If the `subheader` prop is truthy, it renders the `HeaderSubheader` component inside the `HeaderContent` component. Finally, it returns the `ElementType` component with the `classes` and `rest` props. Note that this code uses the `"
    ],
    "smoothed_bleu_4": 0.5497457400097068
  },
  {
    "doc_id": 42,
    "doc": {
      "id": 42,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Grid/Grid.js",
      "func_name": "Grid",
      "original_string": "function Grid(props) {\n  const {\n    celled,\n    centered,\n    children,\n    className,\n    columns,\n    container,\n    divided,\n    doubling,\n    inverted,\n    padded,\n    relaxed,\n    reversed,\n    stackable,\n    stretched,\n    textAlign,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(container, 'container'),\n    useKeyOnly(doubling, 'doubling'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(stackable, 'stackable'),\n    useKeyOnly(stretched, 'stretched'),\n    useKeyOrValueAndKey(celled, 'celled'),\n    useKeyOrValueAndKey(divided, 'divided'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    useMultipleProp(reversed, 'reversed'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column', true),\n    'grid',\n    className,\n  )\n  const rest = getUnhandledProps(Grid, props)\n  const ElementType = getElementType(Grid, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Grid(props) {\n  const {\n    celled,\n    centered,\n    children,\n    className,\n    columns,\n    container,\n    divided,\n    doubling,\n    inverted,\n    padded,\n    relaxed,\n    reversed,\n    stackable,\n    stretched,\n    textAlign,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(container, 'container'),\n    useKeyOnly(doubling, 'doubling'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(stackable, 'stackable'),\n    useKeyOnly(stretched, 'stretched'),\n    useKeyOrValueAndKey(celled, 'celled'),\n    useKeyOrValueAndKey(divided, 'divided'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    useMultipleProp(reversed, 'reversed'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column', true),\n    'grid',\n    className,\n  )\n  const rest = getUnhandledProps(Grid, props)\n  const ElementType = getElementType(Grid, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Grid",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "celled",
        ",",
        "centered",
        ",",
        "children",
        ",",
        "className",
        ",",
        "columns",
        ",",
        "container",
        ",",
        "divided",
        ",",
        "doubling",
        ",",
        "inverted",
        ",",
        "padded",
        ",",
        "relaxed",
        ",",
        "reversed",
        ",",
        "stackable",
        ",",
        "stretched",
        ",",
        "textAlign",
        ",",
        "verticalAlign",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "centered",
        ",",
        "'centered'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "container",
        ",",
        "'container'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "doubling",
        ",",
        "'doubling'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "stackable",
        ",",
        "'stackable'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "stretched",
        ",",
        "'stretched'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "celled",
        ",",
        "'celled'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "divided",
        ",",
        "'divided'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "padded",
        ",",
        "'padded'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "relaxed",
        ",",
        "'relaxed'",
        ")",
        ",",
        "useMultipleProp",
        "(",
        "reversed",
        ",",
        "'reversed'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "useWidthProp",
        "(",
        "columns",
        ",",
        "'column'",
        ",",
        "true",
        ")",
        ",",
        "'grid'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Grid",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Grid",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A grid is used to harmonize negative space in a layout.",
      "docstring_tokens": [
        "A",
        "grid",
        "is",
        "used",
        "to",
        "harmonize",
        "negative",
        "space",
        "in",
        "a",
        "layout",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Grid/Grid.js#L23-L70"
    },
    "target": "A grid is used to harmonize negative space in a layout .",
    "arguments": [
      [
        "function Grid ( props ) { const { celled , centered , children , className , columns , container , divided , doubling , inverted , padded , relaxed , reversed , stackable , stretched , textAlign , verticalAlign , } = props const classes = cx ( 'ui' , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( container , 'container' ) , useKeyOnly ( doubling , 'doubling' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( stackable , 'stackable' ) , useKeyOnly ( stretched , 'stretched' ) , useKeyOrValueAndKey ( celled , 'celled' ) , useKeyOrValueAndKey ( divided , 'divided' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useKeyOrValueAndKey ( relaxed , 'relaxed' ) , useMultipleProp ( reversed , 'reversed' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' , true ) , 'grid' , className , ) const rest = getUnhandledProps ( Grid , props ) const ElementType = getElementType ( Grid , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Grid. defaultProps = { as : 'div', } Grid. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), celled : PropTypes. bool, centered : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, columns : PropTypes. number, container : PropTypes. bool, divided : PropTypes. bool, doubling : PropTypes. bool, inverted : PropTypes. bool, padded : PropTypes. bool, relaxed : PropTypes. bool, reversed : PropTypes. bool, stackable : PropTypes. bool, stretched : PropTypes. bool, textAlign : PropTypes. oneOf ( [ 'center', 'left', 'right' ] ), verticalAlign : PropTypes. oneOf ( [ 'bottom', 'center','middle', 'top' ] ), } Grid. displayName = 'Grid' export default Grid\n```\nThis code defines a React component named `Grid` that represents a grid layout. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the component's props. The `Grid` component accepts various props, including `celled`, `centered`, `children`, `className`,"
      ]
    ],
    "filtered_resps": [
      " Grid. defaultProps = { as : 'div', } Grid. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), celled : PropTypes. bool, centered : PropTypes. bool, children : PropTypes. node, className : PropTypes. string, columns : PropTypes. number, container : PropTypes. bool, divided : PropTypes. bool, doubling : PropTypes. bool, inverted : PropTypes. bool, padded : PropTypes. bool, relaxed : PropTypes. bool, reversed : PropTypes. bool, stackable : PropTypes. bool, stretched : PropTypes. bool, textAlign : PropTypes. oneOf ( [ 'center', 'left', 'right' ] ), verticalAlign : PropTypes. oneOf ( [ 'bottom', 'center','middle', 'top' ] ), } Grid. displayName = 'Grid' export default Grid\n```\nThis code defines a React component named `Grid` that represents a grid layout. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the component's props. The `Grid` component accepts various props, including `celled`, `centered`, `children`, `className`,"
    ],
    "smoothed_bleu_4": 0.8398690841750653
  },
  {
    "doc_id": 43,
    "doc": {
      "id": 43,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Breadcrumb/Breadcrumb.js",
      "func_name": "Breadcrumb",
      "original_string": "function Breadcrumb(props) {\n  const { children, className, divider, icon, sections, size } = props\n\n  const classes = cx('ui', size, 'breadcrumb', className)\n  const rest = getUnhandledProps(Breadcrumb, props)\n  const ElementType = getElementType(Breadcrumb, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const childElements = []\n\n  _.each(sections, (section, index) => {\n    // section\n    const breadcrumbElement = BreadcrumbSection.create(section)\n    childElements.push(breadcrumbElement)\n\n    // divider\n    if (index !== sections.length - 1) {\n      const key = `${breadcrumbElement.key}_divider` || JSON.stringify(section)\n      childElements.push(BreadcrumbDivider.create({ content: divider, icon, key }))\n    }\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childElements}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Breadcrumb(props) {\n  const { children, className, divider, icon, sections, size } = props\n\n  const classes = cx('ui', size, 'breadcrumb', className)\n  const rest = getUnhandledProps(Breadcrumb, props)\n  const ElementType = getElementType(Breadcrumb, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const childElements = []\n\n  _.each(sections, (section, index) => {\n    // section\n    const breadcrumbElement = BreadcrumbSection.create(section)\n    childElements.push(breadcrumbElement)\n\n    // divider\n    if (index !== sections.length - 1) {\n      const key = `${breadcrumbElement.key}_divider` || JSON.stringify(section)\n      childElements.push(BreadcrumbDivider.create({ content: divider, icon, key }))\n    }\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childElements}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Breadcrumb",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "divider",
        ",",
        "icon",
        ",",
        "sections",
        ",",
        "size",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "size",
        ",",
        "'breadcrumb'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Breadcrumb",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Breadcrumb",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "const",
        "childElements",
        "=",
        "[",
        "]",
        "_",
        ".",
        "each",
        "(",
        "sections",
        ",",
        "(",
        "section",
        ",",
        "index",
        ")",
        "=>",
        "{",
        "// section",
        "const",
        "breadcrumbElement",
        "=",
        "BreadcrumbSection",
        ".",
        "create",
        "(",
        "section",
        ")",
        "childElements",
        ".",
        "push",
        "(",
        "breadcrumbElement",
        ")",
        "// divider",
        "if",
        "(",
        "index",
        "!==",
        "sections",
        ".",
        "length",
        "-",
        "1",
        ")",
        "{",
        "const",
        "key",
        "=",
        "`",
        "${",
        "breadcrumbElement",
        ".",
        "key",
        "}",
        "`",
        "||",
        "JSON",
        ".",
        "stringify",
        "(",
        "section",
        ")",
        "childElements",
        ".",
        "push",
        "(",
        "BreadcrumbDivider",
        ".",
        "create",
        "(",
        "{",
        "content",
        ":",
        "divider",
        ",",
        "icon",
        ",",
        "key",
        "}",
        ")",
        ")",
        "}",
        "}",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childElements",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A breadcrumb is used to show hierarchy between content.",
      "docstring_tokens": [
        "A",
        "breadcrumb",
        "is",
        "used",
        "to",
        "show",
        "hierarchy",
        "between",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Breadcrumb/Breadcrumb.js#L13-L47"
    },
    "target": "A breadcrumb is used to show hierarchy between content .",
    "arguments": [
      [
        "function Breadcrumb ( props ) { const { children , className , divider , icon , sections , size } = props const classes = cx ( 'ui' , size , 'breadcrumb' , className ) const rest = getUnhandledProps ( Breadcrumb , props ) const ElementType = getElementType ( Breadcrumb , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const childElements = [ ] _ . each ( sections , ( section , index ) => { // section const breadcrumbElement = BreadcrumbSection . create ( section ) childElements . push ( breadcrumbElement ) // divider if ( index !== sections . length - 1 ) { const key = ` ${ breadcrumbElement . key } ` || JSON . stringify ( section ) childElements . push ( BreadcrumbDivider . create ( { content : divider , icon , key } ) ) } } ) return ( < ElementType { ... rest } className = { classes } > { childElements } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default Breadcrumb } ``` This code defines a React component named `Breadcrumb`. It takes several props, including `children`, `className`, `divider`, `icon`, `sections`, and `size`. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `size` prop. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component. The `ElementType` is determined using the `getElementType` function. If the `children` prop is not `null` or `undefined`, the component returns a JSX element with the `children` prop as its content. If the `children` prop is `null` or `undefined`, the component generates a list of breadcrumb elements based on the `sections` prop. Each breadcrumb element is created using the `BreadcrumbSection` component, and a divider element is created using the `BreadcrumbDivider` component if it's not the last breadcrumb element. The final JSX element is returned with the `childElements` array as its content. The `Breadcrumb` component is exported as the default export of the module. ```javascript\nimport React from'react';\nimport cx from 'classnames';\nimport getUnhandledProps from"
      ]
    ],
    "filtered_resps": [
      " export default Breadcrumb } ``` This code defines a React component named `Breadcrumb`. It takes several props, including `children`, `className`, `divider`, `icon`, `sections`, and `size`. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `size` prop. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component. The `ElementType` is determined using the `getElementType` function. If the `children` prop is not `null` or `undefined`, the component returns a JSX element with the `children` prop as its content. If the `children` prop is `null` or `undefined`, the component generates a list of breadcrumb elements based on the `sections` prop. Each breadcrumb element is created using the `BreadcrumbSection` component, and a divider element is created using the `BreadcrumbDivider` component if it's not the last breadcrumb element. The final JSX element is returned with the `childElements` array as its content. The `Breadcrumb` component is exported as the default export of the module. ```javascript\nimport React from'react';\nimport cx from 'classnames';\nimport getUnhandledProps from"
    ],
    "smoothed_bleu_4": 0.7320431174900583
  },
  {
    "doc_id": 44,
    "doc": {
      "id": 44,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Card/CardDescription.js",
      "func_name": "CardDescription",
      "original_string": "function CardDescription(props) {\n  const { children, className, content, textAlign } = props\n  const classes = cx(useTextAlignProp(textAlign), 'description', className)\n  const rest = getUnhandledProps(CardDescription, props)\n  const ElementType = getElementType(CardDescription, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function CardDescription(props) {\n  const { children, className, content, textAlign } = props\n  const classes = cx(useTextAlignProp(textAlign), 'description', className)\n  const rest = getUnhandledProps(CardDescription, props)\n  const ElementType = getElementType(CardDescription, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "CardDescription",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "textAlign",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "'description'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "CardDescription",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "CardDescription",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A card can contain a description with one or more paragraphs.",
      "docstring_tokens": [
        "A",
        "card",
        "can",
        "contain",
        "a",
        "description",
        "with",
        "one",
        "or",
        "more",
        "paragraphs",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Card/CardDescription.js#L18-L29"
    },
    "target": "A card can contain a description with one or more paragraphs .",
    "arguments": [
      [
        "function CardDescription ( props ) { const { children , className , content , textAlign } = props const classes = cx ( useTextAlignProp ( textAlign ) , 'description' , className ) const rest = getUnhandledProps ( CardDescription , props ) const ElementType = getElementType ( CardDescription , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " CardDescription. defaultProps = { textAlign : 'left' } export default CardDescription ; ``` This code defines a React component named `CardDescription` that displays a description of a card. It uses the `useTextAlignProp` hook to determine the text alignment based on the `textAlign` prop, and the `getUnhandledProps` and `getElementType` functions from the `@fluentui/react-northstar` library to handle the component's props and element type. The component also uses the `childrenUtils` object to check if the `children` prop is `null` or `undefined`, and if so, displays the `content` prop instead. Finally, it exports the `CardDescription` component as the default export.\n\n## Step 3: Define the `useTextAlignProp` hook\nThe `useTextAlignProp` hook is used to determine the text alignment based on the `textAlign` prop. It can be defined as follows:\n```javascript\nimport { useProp } from '@fluentui/react-northstar';\n\nconst useTextAlignProp = (textAlign) => {\n  switch (textAlign) {\n    case 'left':\n      return 'left';\n    case 'center':\n      return 'center';\n   "
      ]
    ],
    "filtered_resps": [
      " CardDescription. defaultProps = { textAlign : 'left' } export default CardDescription ; ``` This code defines a React component named `CardDescription` that displays a description of a card. It uses the `useTextAlignProp` hook to determine the text alignment based on the `textAlign` prop, and the `getUnhandledProps` and `getElementType` functions from the `@fluentui/react-northstar` library to handle the component's props and element type. The component also uses the `childrenUtils` object to check if the `children` prop is `null` or `undefined`, and if so, displays the `content` prop instead. Finally, it exports the `CardDescription` component as the default export.\n\n## Step 3: Define the `useTextAlignProp` hook\nThe `useTextAlignProp` hook is used to determine the text alignment based on the `textAlign` prop. It can be defined as follows:\n```javascript\nimport { useProp } from '@fluentui/react-northstar';\n\nconst useTextAlignProp = (textAlign) => {\n  switch (textAlign) {\n    case 'left':\n      return 'left';\n    case 'center':\n      return 'center';\n   "
    ],
    "smoothed_bleu_4": 0.93378807477359
  },
  {
    "doc_id": 45,
    "doc": {
      "id": 45,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Item/ItemGroup.js",
      "func_name": "ItemGroup",
      "original_string": "function ItemGroup(props) {\n  const { children, className, content, divided, items, link, relaxed, unstackable } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(divided, 'divided'),\n    useKeyOnly(link, 'link'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    'items',\n    className,\n  )\n  const rest = getUnhandledProps(ItemGroup, props)\n  const ElementType = getElementType(ItemGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  const itemsJSX = _.map(items, (item) => {\n    const { childKey, ...itemProps } = item\n    const finalKey =\n      childKey ||\n      [itemProps.content, itemProps.description, itemProps.header, itemProps.meta].join('-')\n\n    return <Item {...itemProps} key={finalKey} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {itemsJSX}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function ItemGroup(props) {\n  const { children, className, content, divided, items, link, relaxed, unstackable } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(divided, 'divided'),\n    useKeyOnly(link, 'link'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    'items',\n    className,\n  )\n  const rest = getUnhandledProps(ItemGroup, props)\n  const ElementType = getElementType(ItemGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  const itemsJSX = _.map(items, (item) => {\n    const { childKey, ...itemProps } = item\n    const finalKey =\n      childKey ||\n      [itemProps.content, itemProps.description, itemProps.header, itemProps.meta].join('-')\n\n    return <Item {...itemProps} key={finalKey} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {itemsJSX}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "ItemGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "divided",
        ",",
        "items",
        ",",
        "link",
        ",",
        "relaxed",
        ",",
        "unstackable",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "divided",
        ",",
        "'divided'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "link",
        ",",
        "'link'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "unstackable",
        ",",
        "'unstackable'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "relaxed",
        ",",
        "'relaxed'",
        ")",
        ",",
        "'items'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "ItemGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "ItemGroup",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "const",
        "itemsJSX",
        "=",
        "_",
        ".",
        "map",
        "(",
        "items",
        ",",
        "(",
        "item",
        ")",
        "=>",
        "{",
        "const",
        "{",
        "childKey",
        ",",
        "...",
        "itemProps",
        "}",
        "=",
        "item",
        "const",
        "finalKey",
        "=",
        "childKey",
        "||",
        "[",
        "itemProps",
        ".",
        "content",
        ",",
        "itemProps",
        ".",
        "description",
        ",",
        "itemProps",
        ".",
        "header",
        ",",
        "itemProps",
        ".",
        "meta",
        "]",
        ".",
        "join",
        "(",
        "'-'",
        ")",
        "return",
        "<",
        "Item",
        "{",
        "...",
        "itemProps",
        "}",
        "key",
        "=",
        "{",
        "finalKey",
        "}",
        "/",
        ">",
        "}",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "itemsJSX",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A group of items.",
      "docstring_tokens": [
        "A",
        "group",
        "of",
        "items",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Item/ItemGroup.js#L19-L63"
    },
    "target": "A group of items .",
    "arguments": [
      [
        "function ItemGroup ( props ) { const { children , className , content , divided , items , link , relaxed , unstackable } = props const classes = cx ( 'ui' , useKeyOnly ( divided , 'divided' ) , useKeyOnly ( link , 'link' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOrValueAndKey ( relaxed , 'relaxed' ) , 'items' , className , ) const rest = getUnhandledProps ( ItemGroup , props ) const ElementType = getElementType ( ItemGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } const itemsJSX = _ . map ( items , ( item ) => { const { childKey , ... itemProps } = item const finalKey = childKey || [ itemProps . content , itemProps . description , itemProps . header , itemProps . meta ] . join ( '-' ) return < Item { ... itemProps } key = { finalKey } / > } ) return ( < ElementType { ... rest } className = { classes } > { itemsJSX } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " } export default ItemGroup ; ``` This code defines the `ItemGroup` component, which is a container for a list of items. It takes various props, such as `children`, `className`, `content`, `divided`, `items`, `link`, `relaxed`, and `unstackable`, and uses the `cx` function to generate a class name based on these props. It also uses the `getUnhandledProps` function to get the rest of the props that are not handled by the component. The `ElementType` is determined by the `getElementType` function, and the component is rendered with the generated class name and the rest of the props. If the `children` prop is not null or undefined, it is rendered as the content of the component. If the `content` prop is not null or undefined, it is rendered as the content of the component. If the `items` prop is not null or undefined, it is mapped over and each item is rendered as an `Item` component. The `Item` component is not defined in this code snippet, but it is assumed to be a separate component that is used to render individual items in the list. The `key` prop is generated for each"
      ]
    ],
    "filtered_resps": [
      " } export default ItemGroup ; ``` This code defines the `ItemGroup` component, which is a container for a list of items. It takes various props, such as `children`, `className`, `content`, `divided`, `items`, `link`, `relaxed`, and `unstackable`, and uses the `cx` function to generate a class name based on these props. It also uses the `getUnhandledProps` function to get the rest of the props that are not handled by the component. The `ElementType` is determined by the `getElementType` function, and the component is rendered with the generated class name and the rest of the props. If the `children` prop is not null or undefined, it is rendered as the content of the component. If the `content` prop is not null or undefined, it is rendered as the content of the component. If the `items` prop is not null or undefined, it is mapped over and each item is rendered as an `Item` component. The `Item` component is not defined in this code snippet, but it is assumed to be a separate component that is used to render individual items in the list. The `key` prop is generated for each"
    ],
    "smoothed_bleu_4": 0.884465934854719
  },
  {
    "doc_id": 46,
    "doc": {
      "id": 46,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Grid/GridColumn.js",
      "func_name": "GridColumn",
      "original_string": "function GridColumn(props) {\n  const {\n    children,\n    className,\n    computer,\n    color,\n    floated,\n    largeScreen,\n    mobile,\n    only,\n    stretched,\n    tablet,\n    textAlign,\n    verticalAlign,\n    widescreen,\n    width,\n  } = props\n\n  const classes = cx(\n    color,\n    useKeyOnly(stretched, 'stretched'),\n    useMultipleProp(only, 'only'),\n    useTextAlignProp(textAlign),\n    useValueAndKey(floated, 'floated'),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(computer, 'wide computer'),\n    useWidthProp(largeScreen, 'wide large screen'),\n    useWidthProp(mobile, 'wide mobile'),\n    useWidthProp(tablet, 'wide tablet'),\n    useWidthProp(widescreen, 'wide widescreen'),\n    useWidthProp(width, 'wide'),\n    'column',\n    className,\n  )\n  const rest = getUnhandledProps(GridColumn, props)\n  const ElementType = getElementType(GridColumn, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function GridColumn(props) {\n  const {\n    children,\n    className,\n    computer,\n    color,\n    floated,\n    largeScreen,\n    mobile,\n    only,\n    stretched,\n    tablet,\n    textAlign,\n    verticalAlign,\n    widescreen,\n    width,\n  } = props\n\n  const classes = cx(\n    color,\n    useKeyOnly(stretched, 'stretched'),\n    useMultipleProp(only, 'only'),\n    useTextAlignProp(textAlign),\n    useValueAndKey(floated, 'floated'),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(computer, 'wide computer'),\n    useWidthProp(largeScreen, 'wide large screen'),\n    useWidthProp(mobile, 'wide mobile'),\n    useWidthProp(tablet, 'wide tablet'),\n    useWidthProp(widescreen, 'wide widescreen'),\n    useWidthProp(width, 'wide'),\n    'column',\n    className,\n  )\n  const rest = getUnhandledProps(GridColumn, props)\n  const ElementType = getElementType(GridColumn, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "GridColumn",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "computer",
        ",",
        "color",
        ",",
        "floated",
        ",",
        "largeScreen",
        ",",
        "mobile",
        ",",
        "only",
        ",",
        "stretched",
        ",",
        "tablet",
        ",",
        "textAlign",
        ",",
        "verticalAlign",
        ",",
        "widescreen",
        ",",
        "width",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "color",
        ",",
        "useKeyOnly",
        "(",
        "stretched",
        ",",
        "'stretched'",
        ")",
        ",",
        "useMultipleProp",
        "(",
        "only",
        ",",
        "'only'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useValueAndKey",
        "(",
        "floated",
        ",",
        "'floated'",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "useWidthProp",
        "(",
        "computer",
        ",",
        "'wide computer'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "largeScreen",
        ",",
        "'wide large screen'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "mobile",
        ",",
        "'wide mobile'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "tablet",
        ",",
        "'wide tablet'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "widescreen",
        ",",
        "'wide widescreen'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "width",
        ",",
        "'wide'",
        ")",
        ",",
        "'column'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "GridColumn",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "GridColumn",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A column sub-component for Grid.",
      "docstring_tokens": [
        "A",
        "column",
        "sub",
        "-",
        "component",
        "for",
        "Grid",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Grid/GridColumn.js#L22-L64"
    },
    "target": "A column sub - component for Grid .",
    "arguments": [
      [
        "function GridColumn ( props ) { const { children , className , computer , color , floated , largeScreen , mobile , only , stretched , tablet , textAlign , verticalAlign , widescreen , width , } = props const classes = cx ( color , useKeyOnly ( stretched , 'stretched' ) , useMultipleProp ( only , 'only' ) , useTextAlignProp ( textAlign ) , useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( computer , 'wide computer' ) , useWidthProp ( largeScreen , 'wide large screen' ) , useWidthProp ( mobile , 'wide mobile' ) , useWidthProp ( tablet , 'wide tablet' ) , useWidthProp ( widescreen , 'wide widescreen' ) , useWidthProp ( width , 'wide' ) , 'column' , className , ) const rest = getUnhandledProps ( GridColumn , props ) const ElementType = getElementType ( GridColumn , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " GridColumn. defaultProps = { computer : true, color : '', floated : false, largeScreen : true, mobile : true, only : false, stretched : false, tablet : true, textAlign : '', verticalAlign : '', widescreen : true, width : '', } GridColumn. propTypes = { children : _propTypes. node, className : _propTypes. string, computer : _propTypes. bool, color : _propTypes. string, floated : _propTypes. bool, largeScreen : _propTypes. bool, mobile : _propTypes. bool, only : _propTypes. bool, stretched : _propTypes. bool, tablet : _propTypes. bool, textAlign : _propTypes. string, verticalAlign : _propTypes. string, widescreen : _propTypes. bool, width : _propTypes. oneOfType ( [ _propTypes. string, _propTypes. bool ] ), } export default GridColumn ; ```\n\nThis code defines a `GridColumn` component that can be used to create columns in a grid layout. The component accepts various props to customize its behavior, such as `computer`, `color`, `floated`, `largeScreen`, `mobile`, `only`, `stretched`, `tablet`, `textAlign`, `"
      ]
    ],
    "filtered_resps": [
      " GridColumn. defaultProps = { computer : true, color : '', floated : false, largeScreen : true, mobile : true, only : false, stretched : false, tablet : true, textAlign : '', verticalAlign : '', widescreen : true, width : '', } GridColumn. propTypes = { children : _propTypes. node, className : _propTypes. string, computer : _propTypes. bool, color : _propTypes. string, floated : _propTypes. bool, largeScreen : _propTypes. bool, mobile : _propTypes. bool, only : _propTypes. bool, stretched : _propTypes. bool, tablet : _propTypes. bool, textAlign : _propTypes. string, verticalAlign : _propTypes. string, widescreen : _propTypes. bool, width : _propTypes. oneOfType ( [ _propTypes. string, _propTypes. bool ] ), } export default GridColumn ; ```\n\nThis code defines a `GridColumn` component that can be used to create columns in a grid layout. The component accepts various props to customize its behavior, such as `computer`, `color`, `floated`, `largeScreen`, `mobile`, `only`, `stretched`, `tablet`, `textAlign`, `"
    ],
    "smoothed_bleu_4": 0.5651234100161556
  },
  {
    "doc_id": 47,
    "doc": {
      "id": 47,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Item/ItemImage.js",
      "func_name": "ItemImage",
      "original_string": "function ItemImage(props) {\n  const { size } = props\n  const rest = getUnhandledProps(ItemImage, props)\n\n  return <Image {...rest} size={size} ui={!!size} wrapped />\n}",
      "language": "javascript",
      "code": "function ItemImage(props) {\n  const { size } = props\n  const rest = getUnhandledProps(ItemImage, props)\n\n  return <Image {...rest} size={size} ui={!!size} wrapped />\n}",
      "code_tokens": [
        "function",
        "ItemImage",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "size",
        "}",
        "=",
        "props",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "ItemImage",
        ",",
        "props",
        ")",
        "return",
        "<",
        "Image",
        "{",
        "...",
        "rest",
        "}",
        "size",
        "=",
        "{",
        "size",
        "}",
        "ui",
        "=",
        "{",
        "!",
        "!",
        "size",
        "}",
        "wrapped",
        "/",
        ">",
        "}"
      ],
      "docstring": "An item can contain an image.",
      "docstring_tokens": [
        "An",
        "item",
        "can",
        "contain",
        "an",
        "image",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Item/ItemImage.js#L9-L14"
    },
    "target": "An item can contain an image .",
    "arguments": [
      [
        "function ItemImage ( props ) { const { size } = props const rest = getUnhandledProps ( ItemImage , props ) return < Image { ... rest } size = { size } ui = { ! ! size } wrapped / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ItemImage. propTypes = { size : PropTypes. oneOf ( [ 'tiny','small','medium', 'large' ] ), } ItemImage. defaultProps = { size :'medium', } export default ItemImage ; ```\n  - ```bash\nnpm install react-native-image-resizer\n```\n  - ```jsx\nimport React from'react';\nimport { Image } from'react-native';\nimport ImageResizer from'react-native-image-resizer';\n\nconst ItemImage = (props) => {\n  const { size } = props;\n  const rest = getUnhandledProps(ItemImage, props);\n\n  const resizedImage = ImageResizer.resize({\n    uri: 'https://example.com/image.jpg',\n    width: 100,\n    height: 100,\n  });\n\n  return (\n    <Image\n      {...rest}\n      source={{ uri: resizedImage.uri }}\n      size={size}\n      ui={!!size}\n      wrapped\n    />\n  );\n};\n\nItemImage.propTypes = {\n  size: PropTypes.oneOf(['tiny','small','medium', 'large']),\n};\n\nItemImage.defaultProps = {\n  size:'medium',\n};\n\nexport default ItemImage;\n```\nIn this example, we're using"
      ]
    ],
    "filtered_resps": [
      " ItemImage. propTypes = { size : PropTypes. oneOf ( [ 'tiny','small','medium', 'large' ] ), } ItemImage. defaultProps = { size :'medium', } export default ItemImage ; ```\n  - ```bash\nnpm install react-native-image-resizer\n```\n  - ```jsx\nimport React from'react';\nimport { Image } from'react-native';\nimport ImageResizer from'react-native-image-resizer';\n\nconst ItemImage = (props) => {\n  const { size } = props;\n  const rest = getUnhandledProps(ItemImage, props);\n\n  const resizedImage = ImageResizer.resize({\n    uri: 'https://example.com/image.jpg',\n    width: 100,\n    height: 100,\n  });\n\n  return (\n    <Image\n      {...rest}\n      source={{ uri: resizedImage.uri }}\n      size={size}\n      ui={!!size}\n      wrapped\n    />\n  );\n};\n\nItemImage.propTypes = {\n  size: PropTypes.oneOf(['tiny','small','medium', 'large']),\n};\n\nItemImage.defaultProps = {\n  size:'medium',\n};\n\nexport default ItemImage;\n```\nIn this example, we're using"
    ],
    "smoothed_bleu_4": 0.5372157966214806
  },
  {
    "doc_id": 48,
    "doc": {
      "id": 48,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Card/CardGroup.js",
      "func_name": "CardGroup",
      "original_string": "function CardGroup(props) {\n  const {\n    centered,\n    children,\n    className,\n    content,\n    doubling,\n    items,\n    itemsPerRow,\n    stackable,\n    textAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(doubling, 'doubling'),\n    useKeyOnly(stackable, 'stackable'),\n    useTextAlignProp(textAlign),\n    useWidthProp(itemsPerRow),\n    'cards',\n    className,\n  )\n  const rest = getUnhandledProps(CardGroup, props)\n  const ElementType = getElementType(CardGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  const itemsJSX = _.map(items, (item) => {\n    const key = item.key || [item.header, item.description].join('-')\n    return <Card key={key} {...item} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {itemsJSX}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function CardGroup(props) {\n  const {\n    centered,\n    children,\n    className,\n    content,\n    doubling,\n    items,\n    itemsPerRow,\n    stackable,\n    textAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(doubling, 'doubling'),\n    useKeyOnly(stackable, 'stackable'),\n    useTextAlignProp(textAlign),\n    useWidthProp(itemsPerRow),\n    'cards',\n    className,\n  )\n  const rest = getUnhandledProps(CardGroup, props)\n  const ElementType = getElementType(CardGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  const itemsJSX = _.map(items, (item) => {\n    const key = item.key || [item.header, item.description].join('-')\n    return <Card key={key} {...item} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {itemsJSX}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "CardGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "centered",
        ",",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "doubling",
        ",",
        "items",
        ",",
        "itemsPerRow",
        ",",
        "stackable",
        ",",
        "textAlign",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "centered",
        ",",
        "'centered'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "doubling",
        ",",
        "'doubling'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "stackable",
        ",",
        "'stackable'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useWidthProp",
        "(",
        "itemsPerRow",
        ")",
        ",",
        "'cards'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "CardGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "CardGroup",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "const",
        "itemsJSX",
        "=",
        "_",
        ".",
        "map",
        "(",
        "items",
        ",",
        "(",
        "item",
        ")",
        "=>",
        "{",
        "const",
        "key",
        "=",
        "item",
        ".",
        "key",
        "||",
        "[",
        "item",
        ".",
        "header",
        ",",
        "item",
        ".",
        "description",
        "]",
        ".",
        "join",
        "(",
        "'-'",
        ")",
        "return",
        "<",
        "Card",
        "key",
        "=",
        "{",
        "key",
        "}",
        "{",
        "...",
        "item",
        "}",
        "/",
        ">",
        "}",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "itemsJSX",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A group of cards.",
      "docstring_tokens": [
        "A",
        "group",
        "of",
        "cards",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Card/CardGroup.js#L21-L72"
    },
    "target": "A group of cards .",
    "arguments": [
      [
        "function CardGroup ( props ) { const { centered , children , className , content , doubling , items , itemsPerRow , stackable , textAlign , } = props const classes = cx ( 'ui' , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( doubling , 'doubling' ) , useKeyOnly ( stackable , 'stackable' ) , useTextAlignProp ( textAlign ) , useWidthProp ( itemsPerRow ) , 'cards' , className , ) const rest = getUnhandledProps ( CardGroup , props ) const ElementType = getElementType ( CardGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } const itemsJSX = _ . map ( items , ( item ) => { const key = item . key || [ item . header , item . description ] . join ( '-' ) return < Card key = { key } { ... item } / > } ) return ( < ElementType { ... rest } className = { classes } > { itemsJSX } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default CardGroup ; ```\n\nThis code defines the `CardGroup` component, which is a container for a group of cards. It takes various props, such as `centered`, `children`, `className`, `content`, `doubling`, `items`, `itemsPerRow`, `stackable`, and `textAlign`, and uses them to determine the class names and layout of the component.\n\nThe code uses the `useKeyOnly` and `useTextAlignProp` functions to conditionally add class names based on the props, and the `useWidthProp` function to determine the width of the component based on the `itemsPerRow` prop.\n\nThe code also uses the `getUnhandledProps` function to get the props that are not handled by the component, and the `getElementType` function to determine the type of element to render based on the `as` prop.\n\nThe code then checks if the `children` or `content` prop is not null or undefined, and if so, returns a JSX element with the children or content. If neither `children` nor `content` is present, the code maps over the `items` prop and returns a JSX element with a `Card` component for each item.\n\n"
      ]
    ],
    "filtered_resps": [
      " export default CardGroup ; ```\n\nThis code defines the `CardGroup` component, which is a container for a group of cards. It takes various props, such as `centered`, `children`, `className`, `content`, `doubling`, `items`, `itemsPerRow`, `stackable`, and `textAlign`, and uses them to determine the class names and layout of the component.\n\nThe code uses the `useKeyOnly` and `useTextAlignProp` functions to conditionally add class names based on the props, and the `useWidthProp` function to determine the width of the component based on the `itemsPerRow` prop.\n\nThe code also uses the `getUnhandledProps` function to get the props that are not handled by the component, and the `getElementType` function to determine the type of element to render based on the `as` prop.\n\nThe code then checks if the `children` or `content` prop is not null or undefined, and if so, returns a JSX element with the children or content. If neither `children` nor `content` is present, the code maps over the `items` prop and returns a JSX element with a `Card` component for each item.\n\n"
    ],
    "smoothed_bleu_4": 1.7395262161508052
  },
  {
    "doc_id": 49,
    "doc": {
      "id": 49,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Table/TableRow.js",
      "func_name": "TableRow",
      "original_string": "function TableRow(props) {\n  const {\n    active,\n    cellAs,\n    cells,\n    children,\n    className,\n    disabled,\n    error,\n    negative,\n    positive,\n    textAlign,\n    verticalAlign,\n    warning,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(warning, 'warning'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    className,\n  )\n  const rest = getUnhandledProps(TableRow, props)\n  const ElementType = getElementType(TableRow, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(cells, cell => TableCell.create(cell, { defaultProps: { as: cellAs } }))}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function TableRow(props) {\n  const {\n    active,\n    cellAs,\n    cells,\n    children,\n    className,\n    disabled,\n    error,\n    negative,\n    positive,\n    textAlign,\n    verticalAlign,\n    warning,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(warning, 'warning'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    className,\n  )\n  const rest = getUnhandledProps(TableRow, props)\n  const ElementType = getElementType(TableRow, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(cells, cell => TableCell.create(cell, { defaultProps: { as: cellAs } }))}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "TableRow",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "active",
        ",",
        "cellAs",
        ",",
        "cells",
        ",",
        "children",
        ",",
        "className",
        ",",
        "disabled",
        ",",
        "error",
        ",",
        "negative",
        ",",
        "positive",
        ",",
        "textAlign",
        ",",
        "verticalAlign",
        ",",
        "warning",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "active",
        ",",
        "'active'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "error",
        ",",
        "'error'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "negative",
        ",",
        "'negative'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "positive",
        ",",
        "'positive'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "warning",
        ",",
        "'warning'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "TableRow",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "TableRow",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "_",
        ".",
        "map",
        "(",
        "cells",
        ",",
        "cell",
        "=>",
        "TableCell",
        ".",
        "create",
        "(",
        "cell",
        ",",
        "{",
        "defaultProps",
        ":",
        "{",
        "as",
        ":",
        "cellAs",
        "}",
        "}",
        ")",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A table can have rows.",
      "docstring_tokens": [
        "A",
        "table",
        "can",
        "have",
        "rows",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Table/TableRow.js#L22-L65"
    },
    "target": "A table can have rows .",
    "arguments": [
      [
        "function TableRow ( props ) { const { active , cellAs , cells , children , className , disabled , error , negative , positive , textAlign , verticalAlign , warning , } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( warning , 'warning' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , className , ) const rest = getUnhandledProps ( TableRow , props ) const ElementType = getElementType ( TableRow , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( cells , cell => TableCell . create ( cell , { defaultProps : { as : cellAs } } ) ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " TableRow. propTypes = { active : React. PropTypes. bool, cellAs : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. func ] ), cells : React. PropTypes. array, children : React. PropTypes. node, className : React. PropTypes. string, disabled : React. PropTypes. bool, error : React. PropTypes. bool, negative : React. PropTypes. bool, positive : React. PropTypes. bool, textAlign : React. PropTypes. oneOf ( [ 'left', 'center', 'right' ] ), verticalAlign : React. PropTypes. oneOf ( [ 'top','middle', 'bottom' ] ), warning : React. PropTypes. bool, } TableRow. defaultProps = { active : false, cellAs : 'td', className : '', disabled : false, error : false, negative : false, positive : false, textAlign : 'left', verticalAlign :'middle', warning : false, } export default TableRow ; ``` This code defines a `TableRow` component that can be used to render a table row. It takes various props such as `active`, `cellAs`, `cells`, `children`, `className"
      ]
    ],
    "filtered_resps": [
      " TableRow. propTypes = { active : React. PropTypes. bool, cellAs : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. func ] ), cells : React. PropTypes. array, children : React. PropTypes. node, className : React. PropTypes. string, disabled : React. PropTypes. bool, error : React. PropTypes. bool, negative : React. PropTypes. bool, positive : React. PropTypes. bool, textAlign : React. PropTypes. oneOf ( [ 'left', 'center', 'right' ] ), verticalAlign : React. PropTypes. oneOf ( [ 'top','middle', 'bottom' ] ), warning : React. PropTypes. bool, } TableRow. defaultProps = { active : false, cellAs : 'td', className : '', disabled : false, error : false, negative : false, positive : false, textAlign : 'left', verticalAlign :'middle', warning : false, } export default TableRow ; ``` This code defines a `TableRow` component that can be used to render a table row. It takes various props such as `active`, `cellAs`, `cells`, `children`, `className"
    ],
    "smoothed_bleu_4": 0.6774631305763874
  },
  {
    "doc_id": 50,
    "doc": {
      "id": 50,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Feed/FeedEvent.js",
      "func_name": "FeedEvent",
      "original_string": "function FeedEvent(props) {\n  const {\n    content,\n    children,\n    className,\n    date,\n    extraImages,\n    extraText,\n    image,\n    icon,\n    meta,\n    summary,\n  } = props\n\n  const classes = cx('event', className)\n  const rest = getUnhandledProps(FeedEvent, props)\n  const ElementType = getElementType(FeedEvent, props)\n\n  const hasContentProp = content || date || extraImages || extraText || meta || summary\n  const contentProps = { content, date, extraImages, extraText, meta, summary }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedLabel, val => ({ icon: val }), icon, { autoGenerateKey: false })}\n      {createShorthand(FeedLabel, val => ({ image: val }), image, { autoGenerateKey: false })}\n      {hasContentProp && <FeedContent {...contentProps} />}\n      {children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function FeedEvent(props) {\n  const {\n    content,\n    children,\n    className,\n    date,\n    extraImages,\n    extraText,\n    image,\n    icon,\n    meta,\n    summary,\n  } = props\n\n  const classes = cx('event', className)\n  const rest = getUnhandledProps(FeedEvent, props)\n  const ElementType = getElementType(FeedEvent, props)\n\n  const hasContentProp = content || date || extraImages || extraText || meta || summary\n  const contentProps = { content, date, extraImages, extraText, meta, summary }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedLabel, val => ({ icon: val }), icon, { autoGenerateKey: false })}\n      {createShorthand(FeedLabel, val => ({ image: val }), image, { autoGenerateKey: false })}\n      {hasContentProp && <FeedContent {...contentProps} />}\n      {children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "FeedEvent",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "content",
        ",",
        "children",
        ",",
        "className",
        ",",
        "date",
        ",",
        "extraImages",
        ",",
        "extraText",
        ",",
        "image",
        ",",
        "icon",
        ",",
        "meta",
        ",",
        "summary",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'event'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "FeedEvent",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "FeedEvent",
        ",",
        "props",
        ")",
        "const",
        "hasContentProp",
        "=",
        "content",
        "||",
        "date",
        "||",
        "extraImages",
        "||",
        "extraText",
        "||",
        "meta",
        "||",
        "summary",
        "const",
        "contentProps",
        "=",
        "{",
        "content",
        ",",
        "date",
        ",",
        "extraImages",
        ",",
        "extraText",
        ",",
        "meta",
        ",",
        "summary",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "FeedLabel",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "icon",
        ":",
        "val",
        "}",
        ")",
        ",",
        "icon",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "FeedLabel",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "image",
        ":",
        "val",
        "}",
        ")",
        ",",
        "image",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "hasContentProp",
        "&&",
        "<",
        "FeedContent",
        "{",
        "...",
        "contentProps",
        "}",
        "/",
        ">",
        "}",
        "\n      ",
        "{",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A feed contains an event.",
      "docstring_tokens": [
        "A",
        "feed",
        "contains",
        "an",
        "event",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedEvent.js#L12-L41"
    },
    "target": "A feed contains an event .",
    "arguments": [
      [
        "function FeedEvent ( props ) { const { content , children , className , date , extraImages , extraText , image , icon , meta , summary , } = props const classes = cx ( 'event' , className ) const rest = getUnhandledProps ( FeedEvent , props ) const ElementType = getElementType ( FeedEvent , props ) const hasContentProp = content || date || extraImages || extraText || meta || summary const contentProps = { content , date , extraImages , extraText , meta , summary } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedLabel , val => ( { icon : val } ) , icon , { autoGenerateKey : false } ) } { createShorthand ( FeedLabel , val => ( { image : val } ) , image , { autoGenerateKey : false } ) } { hasContentProp && < FeedContent { ... contentProps } / > } { children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " } FeedEvent. propTypes = { content : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), date : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), extraImages : React. PropTypes. array, extraText : React. PropTypes. array, image : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), icon : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), meta : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), summary : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), children : React. PropTypes. node, className : React. PropTypes. string, } } FeedEvent. defaultProps = { className : '', } export default FeedEvent ; ```\nThe code defines a React component named `FeedEvent` that represents a single event in a feed. It takes various props such as `content`, `children`, `className`, `date`, `extraImages`, `extraText`,"
      ]
    ],
    "filtered_resps": [
      " } FeedEvent. propTypes = { content : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), date : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), extraImages : React. PropTypes. array, extraText : React. PropTypes. array, image : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), icon : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), meta : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), summary : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. element ] ), children : React. PropTypes. node, className : React. PropTypes. string, } } FeedEvent. defaultProps = { className : '', } export default FeedEvent ; ```\nThe code defines a React component named `FeedEvent` that represents a single event in a feed. It takes various props such as `content`, `children`, `className`, `date`, `extraImages`, `extraText`,"
    ],
    "smoothed_bleu_4": 0.6885578431705435
  },
  {
    "doc_id": 51,
    "doc": {
      "id": 51,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/modules/Tab/TabPane.js",
      "func_name": "TabPane",
      "original_string": "function TabPane(props) {\n  const { active, children, className, content, loading } = props\n\n  const classes = cx(useKeyOnly(active, 'active'), useKeyOnly(loading, 'loading'), 'tab', className)\n  const rest = getUnhandledProps(TabPane, props)\n  const ElementType = getElementType(TabPane, props)\n\n  const calculatedDefaultProps = {}\n  if (ElementType === Segment) {\n    calculatedDefaultProps.attached = 'bottom'\n  }\n\n  return (\n    <ElementType {...calculatedDefaultProps} {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function TabPane(props) {\n  const { active, children, className, content, loading } = props\n\n  const classes = cx(useKeyOnly(active, 'active'), useKeyOnly(loading, 'loading'), 'tab', className)\n  const rest = getUnhandledProps(TabPane, props)\n  const ElementType = getElementType(TabPane, props)\n\n  const calculatedDefaultProps = {}\n  if (ElementType === Segment) {\n    calculatedDefaultProps.attached = 'bottom'\n  }\n\n  return (\n    <ElementType {...calculatedDefaultProps} {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "TabPane",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "active",
        ",",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "loading",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "active",
        ",",
        "'active'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "loading",
        ",",
        "'loading'",
        ")",
        ",",
        "'tab'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "TabPane",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "TabPane",
        ",",
        "props",
        ")",
        "const",
        "calculatedDefaultProps",
        "=",
        "{",
        "}",
        "if",
        "(",
        "ElementType",
        "===",
        "Segment",
        ")",
        "{",
        "calculatedDefaultProps",
        ".",
        "attached",
        "=",
        "'bottom'",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "calculatedDefaultProps",
        "}",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A tab pane holds the content of a tab.",
      "docstring_tokens": [
        "A",
        "tab",
        "pane",
        "holds",
        "the",
        "content",
        "of",
        "a",
        "tab",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/modules/Tab/TabPane.js#L18-L35"
    },
    "target": "A tab pane holds the content of a tab .",
    "arguments": [
      [
        "function TabPane ( props ) { const { active , children , className , content , loading } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( loading , 'loading' ) , 'tab' , className ) const rest = getUnhandledProps ( TabPane , props ) const ElementType = getElementType ( TabPane , props ) const calculatedDefaultProps = { } if ( ElementType === Segment ) { calculatedDefaultProps . attached = 'bottom' } return ( < ElementType { ... calculatedDefaultProps } { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " TabPane. propTypes = { active : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, content : React. PropTypes. node, loading : React. PropTypes. bool, } TabPane. defaultProps = { active : false, loading : false, } export default TabPane ; ``` This code defines a React component named `TabPane` that represents a tab pane in a tabbed interface. It takes several props, including `active`, `children`, `className`, `content`, and `loading`, and uses these props to determine its appearance and behavior. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `active` and `loading` props. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component's props object. The component returns a JSX element that represents the tab pane, which is either a `div` or a `Segment` component depending on the `ElementType` prop. The `children` prop is used to render the content of the tab pane, and the `content` prop is used as a fallback if `children` is `null` or `undefined`. Finally"
      ]
    ],
    "filtered_resps": [
      " TabPane. propTypes = { active : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, content : React. PropTypes. node, loading : React. PropTypes. bool, } TabPane. defaultProps = { active : false, loading : false, } export default TabPane ; ``` This code defines a React component named `TabPane` that represents a tab pane in a tabbed interface. It takes several props, including `active`, `children`, `className`, `content`, and `loading`, and uses these props to determine its appearance and behavior. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `active` and `loading` props. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component's props object. The component returns a JSX element that represents the tab pane, which is either a `div` or a `Segment` component depending on the `ElementType` prop. The `children` prop is used to render the content of the tab pane, and the `content` prop is used as a fallback if `children` is `null` or `undefined`. Finally"
    ],
    "smoothed_bleu_4": 1.3621086234536701
  },
  {
    "doc_id": 52,
    "doc": {
      "id": 52,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/List/ListContent.js",
      "func_name": "ListContent",
      "original_string": "function ListContent(props) {\n  const { children, className, content, description, floated, header, verticalAlign } = props\n\n  const classes = cx(\n    useValueAndKey(floated, 'floated'),\n    useVerticalAlignProp(verticalAlign),\n    'content',\n    className,\n  )\n  const rest = getUnhandledProps(ListContent, props)\n  const ElementType = getElementType(ListContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {ListHeader.create(header)}\n      {ListDescription.create(description)}\n      {content}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function ListContent(props) {\n  const { children, className, content, description, floated, header, verticalAlign } = props\n\n  const classes = cx(\n    useValueAndKey(floated, 'floated'),\n    useVerticalAlignProp(verticalAlign),\n    'content',\n    className,\n  )\n  const rest = getUnhandledProps(ListContent, props)\n  const ElementType = getElementType(ListContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {ListHeader.create(header)}\n      {ListDescription.create(description)}\n      {content}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "ListContent",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "description",
        ",",
        "floated",
        ",",
        "header",
        ",",
        "verticalAlign",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useValueAndKey",
        "(",
        "floated",
        ",",
        "'floated'",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "'content'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "ListContent",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "ListContent",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "ListHeader",
        ".",
        "create",
        "(",
        "header",
        ")",
        "}",
        "\n      ",
        "{",
        "ListDescription",
        ".",
        "create",
        "(",
        "description",
        ")",
        "}",
        "\n      ",
        "{",
        "content",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A list item can contain a content.",
      "docstring_tokens": [
        "A",
        "list",
        "item",
        "can",
        "contain",
        "a",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/List/ListContent.js#L21-L48"
    },
    "target": "A list item can contain a content .",
    "arguments": [
      [
        "function ListContent ( props ) { const { children , className , content , description , floated , header , verticalAlign } = props const classes = cx ( useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign ) , 'content' , className , ) const rest = getUnhandledProps ( ListContent , props ) const ElementType = getElementType ( ListContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ListHeader . create ( header ) } { ListDescription . create ( description ) } { content } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ListContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. node, floated : PropTypes. bool, header : PropTypes. node, verticalAlign : PropTypes. oneOf ( [ 'top','middle', 'bottom' ] ), } ListContent. defaultProps = { floated : false, verticalAlign : 'top', } ListContent. displayName = 'ListContent' module. exports = ListContent\n\n#### ListDescription.js\n```\nimport React from'react' import PropTypes from 'prop-types' import cx from 'classnames' import getUnhandledProps from './getUnhandledProps' import getElementType from './getElementType' import useValueAndKey from './useValueAndKey' import useVerticalAlignProp from './useVerticalAlignProp'\n\nconst ListDescription = ( props ) => { const { children, className, content, floated, verticalAlign } = props const classes = cx ( useValueAndKey ( floated, 'floated' ), useVerticalAlignProp ( verticalAlign ), 'description', className, ) const rest = getUnhandledProps ( ListDescription, props ) const ElementType = getElementType ( ListDescription, props ) if"
      ]
    ],
    "filtered_resps": [
      " ListContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. node, floated : PropTypes. bool, header : PropTypes. node, verticalAlign : PropTypes. oneOf ( [ 'top','middle', 'bottom' ] ), } ListContent. defaultProps = { floated : false, verticalAlign : 'top', } ListContent. displayName = 'ListContent' module. exports = ListContent\n\n#### ListDescription.js\n```\nimport React from'react' import PropTypes from 'prop-types' import cx from 'classnames' import getUnhandledProps from './getUnhandledProps' import getElementType from './getElementType' import useValueAndKey from './useValueAndKey' import useVerticalAlignProp from './useVerticalAlignProp'\n\nconst ListDescription = ( props ) => { const { children, className, content, floated, verticalAlign } = props const classes = cx ( useValueAndKey ( floated, 'floated' ), useVerticalAlignProp ( verticalAlign ), 'description', className, ) const rest = getUnhandledProps ( ListDescription, props ) const ElementType = getElementType ( ListDescription, props ) if"
    ],
    "smoothed_bleu_4": 0.5399389568559393
  },
  {
    "doc_id": 53,
    "doc": {
      "id": 53,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Button/ButtonOr.js",
      "func_name": "ButtonOr",
      "original_string": "function ButtonOr(props) {\n  const { className, text } = props\n  const classes = cx('or', className)\n  const rest = getUnhandledProps(ButtonOr, props)\n  const ElementType = getElementType(ButtonOr, props)\n\n  return <ElementType {...rest} className={classes} data-text={text} />\n}",
      "language": "javascript",
      "code": "function ButtonOr(props) {\n  const { className, text } = props\n  const classes = cx('or', className)\n  const rest = getUnhandledProps(ButtonOr, props)\n  const ElementType = getElementType(ButtonOr, props)\n\n  return <ElementType {...rest} className={classes} data-text={text} />\n}",
      "code_tokens": [
        "function",
        "ButtonOr",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        ",",
        "text",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'or'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "ButtonOr",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "ButtonOr",
        ",",
        "props",
        ")",
        "return",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "data-text",
        "=",
        "{",
        "text",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "Button groups can contain conditionals.",
      "docstring_tokens": [
        "Button",
        "groups",
        "can",
        "contain",
        "conditionals",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Button/ButtonOr.js#L10-L17"
    },
    "target": "Button groups can contain conditionals .",
    "arguments": [
      [
        "function ButtonOr ( props ) { const { className , text } = props const classes = cx ( 'or' , className ) const rest = getUnhandledProps ( ButtonOr , props ) const ElementType = getElementType ( ButtonOr , props ) return < ElementType { ... rest } className = { classes } data-text = { text } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ButtonOr. defaultProps = { className : '', text : 'or' } export default ButtonOr ; ```\n  3. Create a new file called `index.js` in the same directory as the `ButtonOr.js` file. In this file, export the `ButtonOr` component: ```javascript export { default as ButtonOr } from './ButtonOr'; ```\n  4. In your application, import the `ButtonOr` component and use it in your JSX: ```javascript import React from'react'; import { ButtonOr } from './ButtonOr'; const MyComponent = () => { return ( <div> <ButtonOr text=\"or\" /> <ButtonOr text=\"or\" /> <ButtonOr text=\"or\" /> /div> ); }; export default MyComponent; ```\n\nThis is a basic example of how to create and use a custom React component. You can customize the `ButtonOr` component to fit your specific needs by modifying its props, state, and behavior.\n\n### Step 3: Create a new file for the ButtonOr component's styles\n\nCreate a new file called `styles.css` in the same directory as the `ButtonOr.js` file. In this file, add the CSS styles"
      ]
    ],
    "filtered_resps": [
      " ButtonOr. defaultProps = { className : '', text : 'or' } export default ButtonOr ; ```\n  3. Create a new file called `index.js` in the same directory as the `ButtonOr.js` file. In this file, export the `ButtonOr` component: ```javascript export { default as ButtonOr } from './ButtonOr'; ```\n  4. In your application, import the `ButtonOr` component and use it in your JSX: ```javascript import React from'react'; import { ButtonOr } from './ButtonOr'; const MyComponent = () => { return ( <div> <ButtonOr text=\"or\" /> <ButtonOr text=\"or\" /> <ButtonOr text=\"or\" /> /div> ); }; export default MyComponent; ```\n\nThis is a basic example of how to create and use a custom React component. You can customize the `ButtonOr` component to fit your specific needs by modifying its props, state, and behavior.\n\n### Step 3: Create a new file for the ButtonOr component's styles\n\nCreate a new file called `styles.css` in the same directory as the `ButtonOr.js` file. In this file, add the CSS styles"
    ],
    "smoothed_bleu_4": 0.45695030046843554
  },
  {
    "doc_id": 54,
    "doc": {
      "id": 54,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Table/TableCell.js",
      "func_name": "TableCell",
      "original_string": "function TableCell(props) {\n  const {\n    active,\n    children,\n    className,\n    collapsing,\n    content,\n    disabled,\n    error,\n    icon,\n    negative,\n    positive,\n    selectable,\n    singleLine,\n    textAlign,\n    verticalAlign,\n    warning,\n    width,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(active, 'active'),\n    useKeyOnly(collapsing, 'collapsing'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(selectable, 'selectable'),\n    useKeyOnly(singleLine, 'single line'),\n    useKeyOnly(warning, 'warning'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(width, 'wide'),\n    className,\n  )\n  const rest = getUnhandledProps(TableCell, props)\n  const ElementType = getElementType(TableCell, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {Icon.create(icon)}\n      {content}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function TableCell(props) {\n  const {\n    active,\n    children,\n    className,\n    collapsing,\n    content,\n    disabled,\n    error,\n    icon,\n    negative,\n    positive,\n    selectable,\n    singleLine,\n    textAlign,\n    verticalAlign,\n    warning,\n    width,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(active, 'active'),\n    useKeyOnly(collapsing, 'collapsing'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(selectable, 'selectable'),\n    useKeyOnly(singleLine, 'single line'),\n    useKeyOnly(warning, 'warning'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(width, 'wide'),\n    className,\n  )\n  const rest = getUnhandledProps(TableCell, props)\n  const ElementType = getElementType(TableCell, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {Icon.create(icon)}\n      {content}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "TableCell",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "active",
        ",",
        "children",
        ",",
        "className",
        ",",
        "collapsing",
        ",",
        "content",
        ",",
        "disabled",
        ",",
        "error",
        ",",
        "icon",
        ",",
        "negative",
        ",",
        "positive",
        ",",
        "selectable",
        ",",
        "singleLine",
        ",",
        "textAlign",
        ",",
        "verticalAlign",
        ",",
        "warning",
        ",",
        "width",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "active",
        ",",
        "'active'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "collapsing",
        ",",
        "'collapsing'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "error",
        ",",
        "'error'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "negative",
        ",",
        "'negative'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "positive",
        ",",
        "'positive'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "selectable",
        ",",
        "'selectable'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "singleLine",
        ",",
        "'single line'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "warning",
        ",",
        "'warning'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "useWidthProp",
        "(",
        "width",
        ",",
        "'wide'",
        ")",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "TableCell",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "TableCell",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "Icon",
        ".",
        "create",
        "(",
        "icon",
        ")",
        "}",
        "\n      ",
        "{",
        "content",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A table row can have cells.",
      "docstring_tokens": [
        "A",
        "table",
        "row",
        "can",
        "have",
        "cells",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Table/TableCell.js#L23-L75"
    },
    "target": "A table row can have cells .",
    "arguments": [
      [
        "function TableCell ( props ) { const { active , children , className , collapsing , content , disabled , error , icon , negative , positive , selectable , singleLine , textAlign , verticalAlign , warning , width , } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( collapsing , 'collapsing' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( selectable , 'selectable' ) , useKeyOnly ( singleLine , 'single line' ) , useKeyOnly ( warning , 'warning' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( width , 'wide' ) , className , ) const rest = getUnhandledProps ( TableCell , props ) const ElementType = getElementType ( TableCell , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { Icon . create ( icon ) } { content } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " TableCell. propTypes = { active : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, collapsing : React. PropTypes. bool, content : React. PropTypes. node, disabled : React. PropTypes. bool, error : React. PropTypes. bool, icon : React. PropTypes. node, negative : React. PropTypes. bool, positive : React. PropTypes. bool, selectable : React. PropTypes. bool, singleLine : React. PropTypes. bool, textAlign : React. PropTypes. string, verticalAlign : React. PropTypes. string, warning : React. PropTypes. bool, width : React. PropTypes. oneOfType ( [ React. PropTypes. number, React. PropTypes. string ] ), } TableCell. defaultProps = { active : false, collapsing : false, disabled : false, error : false, icon : null, negative : false, positive : false, selectable : false, singleLine : false, textAlign : 'left', verticalAlign :'middle', warning : false, width : null, } export default TableCell ; ``` This code defines a `TableCell` component that can be used to render a table cell. It takes various props such as `active`, `children"
      ]
    ],
    "filtered_resps": [
      " TableCell. propTypes = { active : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, collapsing : React. PropTypes. bool, content : React. PropTypes. node, disabled : React. PropTypes. bool, error : React. PropTypes. bool, icon : React. PropTypes. node, negative : React. PropTypes. bool, positive : React. PropTypes. bool, selectable : React. PropTypes. bool, singleLine : React. PropTypes. bool, textAlign : React. PropTypes. string, verticalAlign : React. PropTypes. string, warning : React. PropTypes. bool, width : React. PropTypes. oneOfType ( [ React. PropTypes. number, React. PropTypes. string ] ), } TableCell. defaultProps = { active : false, collapsing : false, disabled : false, error : false, icon : null, negative : false, positive : false, selectable : false, singleLine : false, textAlign : 'left', verticalAlign :'middle', warning : false, width : null, } export default TableCell ; ``` This code defines a `TableCell` component that can be used to render a table cell. It takes various props such as `active`, `children"
    ],
    "smoothed_bleu_4": 0.6802031538189011
  },
  {
    "doc_id": 55,
    "doc": {
      "id": 55,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Breadcrumb/BreadcrumbDivider.js",
      "func_name": "BreadcrumbDivider",
      "original_string": "function BreadcrumbDivider(props) {\n  const { children, className, content, icon } = props\n\n  const classes = cx('divider', className)\n  const rest = getUnhandledProps(BreadcrumbDivider, props)\n  const ElementType = getElementType(BreadcrumbDivider, props)\n\n  if (!_.isNil(icon)) {\n    return Icon.create(icon, {\n      defaultProps: { ...rest, className: classes },\n      autoGenerateKey: false,\n    })\n  }\n\n  if (!_.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? '/' : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function BreadcrumbDivider(props) {\n  const { children, className, content, icon } = props\n\n  const classes = cx('divider', className)\n  const rest = getUnhandledProps(BreadcrumbDivider, props)\n  const ElementType = getElementType(BreadcrumbDivider, props)\n\n  if (!_.isNil(icon)) {\n    return Icon.create(icon, {\n      defaultProps: { ...rest, className: classes },\n      autoGenerateKey: false,\n    })\n  }\n\n  if (!_.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? '/' : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "BreadcrumbDivider",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "icon",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'divider'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "BreadcrumbDivider",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "BreadcrumbDivider",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "_",
        ".",
        "isNil",
        "(",
        "icon",
        ")",
        ")",
        "{",
        "return",
        "Icon",
        ".",
        "create",
        "(",
        "icon",
        ",",
        "{",
        "defaultProps",
        ":",
        "{",
        "...",
        "rest",
        ",",
        "className",
        ":",
        "classes",
        "}",
        ",",
        "autoGenerateKey",
        ":",
        "false",
        ",",
        "}",
        ")",
        "}",
        "if",
        "(",
        "!",
        "_",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "'/'",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A divider sub-component for Breadcrumb component.",
      "docstring_tokens": [
        "A",
        "divider",
        "sub",
        "-",
        "component",
        "for",
        "Breadcrumb",
        "component",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Breadcrumb/BreadcrumbDivider.js#L18-L45"
    },
    "target": "A divider sub - component for Breadcrumb component .",
    "arguments": [
      [
        "function BreadcrumbDivider ( props ) { const { children , className , content , icon } = props const classes = cx ( 'divider' , className ) const rest = getUnhandledProps ( BreadcrumbDivider , props ) const ElementType = getElementType ( BreadcrumbDivider , props ) if ( ! _ . isNil ( icon ) ) { return Icon . create ( icon , { defaultProps : { ... rest , className : classes } , autoGenerateKey : false , } ) } if ( ! _ . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? '/' : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " BreadcrumbDivider. defaultProps = { children : '/' } BreadcrumbDivider. propTypes = { children : _. prop ( 'children', PropTypes. node ), className : _. prop ( 'className', PropTypes. string ), content : _. prop ( 'content', PropTypes. string ), icon : _. prop ( 'icon', PropTypes. oneOfType ( [ PropTypes. string, PropTypes. object ] ) ), } BreadcrumbDivider. displayName = 'BreadcrumbDivider' module. exports = BreadcrumbDivider ; })(); });\n```\n\nThis code defines a React component named `BreadcrumbDivider`. It's a utility component that can be used to create a divider in a breadcrumb navigation component. The divider can be customized with a custom icon, content, or a default '/' character.\n\nHere's a breakdown of the code:\n\n1. The component is defined as a function that takes `props` as an argument.\n2. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop.\n3. The `getUnhandledProps` function is used to get the props that are not handled by the component.\n4. The `getElementType` function is"
      ]
    ],
    "filtered_resps": [
      " BreadcrumbDivider. defaultProps = { children : '/' } BreadcrumbDivider. propTypes = { children : _. prop ( 'children', PropTypes. node ), className : _. prop ( 'className', PropTypes. string ), content : _. prop ( 'content', PropTypes. string ), icon : _. prop ( 'icon', PropTypes. oneOfType ( [ PropTypes. string, PropTypes. object ] ) ), } BreadcrumbDivider. displayName = 'BreadcrumbDivider' module. exports = BreadcrumbDivider ; })(); });\n```\n\nThis code defines a React component named `BreadcrumbDivider`. It's a utility component that can be used to create a divider in a breadcrumb navigation component. The divider can be customized with a custom icon, content, or a default '/' character.\n\nHere's a breakdown of the code:\n\n1. The component is defined as a function that takes `props` as an argument.\n2. The component uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop.\n3. The `getUnhandledProps` function is used to get the props that are not handled by the component.\n4. The `getElementType` function is"
    ],
    "smoothed_bleu_4": 0.8330753241440838
  },
  {
    "doc_id": 56,
    "doc": {
      "id": 56,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Message/MessageList.js",
      "func_name": "MessageList",
      "original_string": "function MessageList(props) {\n  const { children, className, items } = props\n  const classes = cx('list', className)\n  const rest = getUnhandledProps(MessageList, props)\n  const ElementType = getElementType(MessageList, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? _.map(items, MessageItem.create) : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function MessageList(props) {\n  const { children, className, items } = props\n  const classes = cx('list', className)\n  const rest = getUnhandledProps(MessageList, props)\n  const ElementType = getElementType(MessageList, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? _.map(items, MessageItem.create) : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "MessageList",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "items",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'list'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "MessageList",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "MessageList",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "_",
        ".",
        "map",
        "(",
        "items",
        ",",
        "MessageItem",
        ".",
        "create",
        ")",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A message can contain a list of items.",
      "docstring_tokens": [
        "A",
        "message",
        "can",
        "contain",
        "a",
        "list",
        "of",
        "items",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Message/MessageList.js#L18-L29"
    },
    "target": "A message can contain a list of items .",
    "arguments": [
      [
        "function MessageList ( props ) { const { children , className , items } = props const classes = cx ( 'list' , className ) const rest = getUnhandledProps ( MessageList , props ) const ElementType = getElementType ( MessageList , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? _ . map ( items , MessageItem . create ) : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " MessageList. defaultProps = { className : '' } MessageList. propTypes = { children : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ), className : PropTypes. string, items : PropTypes. array. isRequired } MessageList. contextTypes = { messageList : PropTypes. object } export default MessageList ```\n\nThis code defines a React component called `MessageList` that displays a list of messages. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes to the component based on the `className` prop. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop.\n\nThe component expects the following props:\n\n* `children`: a string or React element that will be rendered inside the list\n* `className`: a string that will be used to apply CSS classes to the component\n* `items`: an array of message items that will be rendered in the list\n\nThe component also expects a `messageList` context object, which is not defined in this code snippet.\n\nThe `create` method is used"
      ]
    ],
    "filtered_resps": [
      " MessageList. defaultProps = { className : '' } MessageList. propTypes = { children : PropTypes. oneOfType ( [ PropTypes. string, PropTypes. element ] ), className : PropTypes. string, items : PropTypes. array. isRequired } MessageList. contextTypes = { messageList : PropTypes. object } export default MessageList ```\n\nThis code defines a React component called `MessageList` that displays a list of messages. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes to the component based on the `className` prop. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop.\n\nThe component expects the following props:\n\n* `children`: a string or React element that will be rendered inside the list\n* `className`: a string that will be used to apply CSS classes to the component\n* `items`: an array of message items that will be rendered in the list\n\nThe component also expects a `messageList` context object, which is not defined in this code snippet.\n\nThe `create` method is used"
    ],
    "smoothed_bleu_4": 1.0730223224246562
  },
  {
    "doc_id": 57,
    "doc": {
      "id": 57,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Table/TableFooter.js",
      "func_name": "TableFooter",
      "original_string": "function TableFooter(props) {\n  const { as } = props\n  const rest = getUnhandledProps(TableFooter, props)\n\n  return <TableHeader {...rest} as={as} />\n}",
      "language": "javascript",
      "code": "function TableFooter(props) {\n  const { as } = props\n  const rest = getUnhandledProps(TableFooter, props)\n\n  return <TableHeader {...rest} as={as} />\n}",
      "code_tokens": [
        "function",
        "TableFooter",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "as",
        "}",
        "=",
        "props",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "TableFooter",
        ",",
        "props",
        ")",
        "return",
        "<",
        "TableHeader",
        "{",
        "...",
        "rest",
        "}",
        "as",
        "=",
        "{",
        "as",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "A table can have a footer.",
      "docstring_tokens": [
        "A",
        "table",
        "can",
        "have",
        "a",
        "footer",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Table/TableFooter.js#L9-L14"
    },
    "target": "A table can have a footer .",
    "arguments": [
      [
        "function TableFooter ( props ) { const { as } = props const rest = getUnhandledProps ( TableFooter , props ) return < TableHeader { ... rest } as = { as } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " TableFooter. propTypes = { as : React. PropTypes. oneOfType ( [ React. PropTypes. func, React. PropTypes. string ] ), } TableFooter. defaultProps = { as : 'tfoot', } export default TableFooter ; ```\n  - ```javascript\n// @flow\nimport React from'react';\nimport { TableFooter } from './TableFooter';\nimport { TableHeader } from './TableHeader';\nimport { Table } from './Table';\n\ntype Props = {\n  +children?: React.Node,\n  +as?: string | Function,\n};\n\nconst TableFooter = (props: Props) => {\n  const { as } = props;\n  const rest = getUnhandledProps(TableFooter, props);\n  return <TableHeader {...rest} as={as} />;\n};\n\nTableFooter.propTypes = {\n  as: React.PropTypes.oneOfType([React.PropTypes.func, React.PropTypes.string]),\n};\n\nTableFooter.defaultProps = {\n  as: 'tfoot',\n};\n\nexport default TableFooter;\n```\n\nThis code defines a `TableFooter` component that renders a `TableHeader` component with the `as` prop set to `'tfoot'`. The `TableFooter` component also accepts an `as` prop, which can be a string or a function"
      ]
    ],
    "filtered_resps": [
      " TableFooter. propTypes = { as : React. PropTypes. oneOfType ( [ React. PropTypes. func, React. PropTypes. string ] ), } TableFooter. defaultProps = { as : 'tfoot', } export default TableFooter ; ```\n  - ```javascript\n// @flow\nimport React from'react';\nimport { TableFooter } from './TableFooter';\nimport { TableHeader } from './TableHeader';\nimport { Table } from './Table';\n\ntype Props = {\n  +children?: React.Node,\n  +as?: string | Function,\n};\n\nconst TableFooter = (props: Props) => {\n  const { as } = props;\n  const rest = getUnhandledProps(TableFooter, props);\n  return <TableHeader {...rest} as={as} />;\n};\n\nTableFooter.propTypes = {\n  as: React.PropTypes.oneOfType([React.PropTypes.func, React.PropTypes.string]),\n};\n\nTableFooter.defaultProps = {\n  as: 'tfoot',\n};\n\nexport default TableFooter;\n```\n\nThis code defines a `TableFooter` component that renders a `TableHeader` component with the `as` prop set to `'tfoot'`. The `TableFooter` component also accepts an `as` prop, which can be a string or a function"
    ],
    "smoothed_bleu_4": 0.5637534758608833
  },
  {
    "doc_id": 58,
    "doc": {
      "id": 58,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Comment/CommentGroup.js",
      "func_name": "CommentGroup",
      "original_string": "function CommentGroup(props) {\n  const { className, children, collapsed, content, minimal, size, threaded } = props\n\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(collapsed, 'collapsed'),\n    useKeyOnly(minimal, 'minimal'),\n    useKeyOnly(threaded, 'threaded'),\n    'comments',\n    className,\n  )\n  const rest = getUnhandledProps(CommentGroup, props)\n  const ElementType = getElementType(CommentGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function CommentGroup(props) {\n  const { className, children, collapsed, content, minimal, size, threaded } = props\n\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(collapsed, 'collapsed'),\n    useKeyOnly(minimal, 'minimal'),\n    useKeyOnly(threaded, 'threaded'),\n    'comments',\n    className,\n  )\n  const rest = getUnhandledProps(CommentGroup, props)\n  const ElementType = getElementType(CommentGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "CommentGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        ",",
        "children",
        ",",
        "collapsed",
        ",",
        "content",
        ",",
        "minimal",
        ",",
        "size",
        ",",
        "threaded",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "collapsed",
        ",",
        "'collapsed'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "minimal",
        ",",
        "'minimal'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "threaded",
        ",",
        "'threaded'",
        ")",
        ",",
        "'comments'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "CommentGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "CommentGroup",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "Comments can be grouped.",
      "docstring_tokens": [
        "Comments",
        "can",
        "be",
        "grouped",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Comment/CommentGroup.js#L18-L38"
    },
    "target": "Comments can be grouped .",
    "arguments": [
      [
        "function CommentGroup ( props ) { const { className , children , collapsed , content , minimal , size , threaded } = props const classes = cx ( 'ui' , size , useKeyOnly ( collapsed , 'collapsed' ) , useKeyOnly ( minimal , 'minimal' ) , useKeyOnly ( threaded , 'threaded' ) , 'comments' , className , ) const rest = getUnhandledProps ( CommentGroup , props ) const ElementType = getElementType ( CommentGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " CommentGroup. defaultProps = { minimal : false, size : 'default', threaded : false, } export default CommentGroup ; ```\n\nThis code defines a React component named `CommentGroup`. It takes several props, including `className`, `children`, `collapsed`, `content`, `minimal`, `size`, and `threaded`. The component uses the `cx` function to conditionally apply CSS classes based on the props. It also uses the `getUnhandledProps` function to get the props that are not handled by the component, and the `getElementType` function to determine the type of element to render.\n\nThe component then returns an element of the determined type, with the `className` prop set to the result of the `cx` function. If the `children` prop is `null` or `undefined`, it renders the `content` prop instead. Otherwise, it renders the `children` prop.\n\nThe `defaultProps` property is set to an object with default values for the `minimal`, `size`, and `threaded` props.\n\nNote that this code assumes that the `cx` function, `getUnhandledProps` function, and `getElementType` function are defined elsewhere in the codebase. These functions"
      ]
    ],
    "filtered_resps": [
      " CommentGroup. defaultProps = { minimal : false, size : 'default', threaded : false, } export default CommentGroup ; ```\n\nThis code defines a React component named `CommentGroup`. It takes several props, including `className`, `children`, `collapsed`, `content`, `minimal`, `size`, and `threaded`. The component uses the `cx` function to conditionally apply CSS classes based on the props. It also uses the `getUnhandledProps` function to get the props that are not handled by the component, and the `getElementType` function to determine the type of element to render.\n\nThe component then returns an element of the determined type, with the `className` prop set to the result of the `cx` function. If the `children` prop is `null` or `undefined`, it renders the `content` prop instead. Otherwise, it renders the `children` prop.\n\nThe `defaultProps` property is set to an object with default values for the `minimal`, `size`, and `threaded` props.\n\nNote that this code assumes that the `cx` function, `getUnhandledProps` function, and `getElementType` function are defined elsewhere in the codebase. These functions"
    ],
    "smoothed_bleu_4": 0.4044512150843639
  },
  {
    "doc_id": 59,
    "doc": {
      "id": 59,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Reveal/Reveal.js",
      "func_name": "Reveal",
      "original_string": "function Reveal(props) {\n  const { active, animated, children, className, content, disabled, instant } = props\n\n  const classes = cx(\n    'ui',\n    animated,\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(instant, 'instant'),\n    'reveal',\n    className,\n  )\n  const rest = getUnhandledProps(Reveal, props)\n  const ElementType = getElementType(Reveal, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Reveal(props) {\n  const { active, animated, children, className, content, disabled, instant } = props\n\n  const classes = cx(\n    'ui',\n    animated,\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(instant, 'instant'),\n    'reveal',\n    className,\n  )\n  const rest = getUnhandledProps(Reveal, props)\n  const ElementType = getElementType(Reveal, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Reveal",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "active",
        ",",
        "animated",
        ",",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "disabled",
        ",",
        "instant",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "animated",
        ",",
        "useKeyOnly",
        "(",
        "active",
        ",",
        "'active'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "instant",
        ",",
        "'instant'",
        ")",
        ",",
        "'reveal'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Reveal",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Reveal",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A reveal displays additional content in place of previous content when activated.",
      "docstring_tokens": [
        "A",
        "reveal",
        "displays",
        "additional",
        "content",
        "in",
        "place",
        "of",
        "previous",
        "content",
        "when",
        "activated",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Reveal/Reveal.js#L17-L37"
    },
    "target": "A reveal displays additional content in place of previous content when activated .",
    "arguments": [
      [
        "function Reveal ( props ) { const { active , animated , children , className , content , disabled , instant } = props const classes = cx ( 'ui' , animated , useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( instant , 'instant' ) , 'reveal' , className , ) const rest = getUnhandledProps ( Reveal , props ) const ElementType = getElementType ( Reveal , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Reveal. defaultProps = { active : false, animated : false, children : undefined, className : '', content : '', disabled : false, instant : false, } Reveal. propTypes = { active : React. PropTypes. bool, animated : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, content : React. PropTypes. string, disabled : React. PropTypes. bool, instant : React. PropTypes. bool, } module. exports = Reveal ; } ```\nThis code defines a React component named `Reveal` that can be used to display content in a reveal animation. The component takes several props, including `active`, `animated`, `children`, `className`, `content`, `disabled`, and `instant`, which control the behavior and appearance of the reveal animation. The code uses the `cx` function to conditionally apply CSS classes based on the props, and the `getUnhandledProps` and `getElementType` functions to handle props and determine the element type for the component. The component returns a JSX element that renders the content or children based on the `children` prop. Finally, the code defines the default props and prop types for the `Reveal"
      ]
    ],
    "filtered_resps": [
      " Reveal. defaultProps = { active : false, animated : false, children : undefined, className : '', content : '', disabled : false, instant : false, } Reveal. propTypes = { active : React. PropTypes. bool, animated : React. PropTypes. bool, children : React. PropTypes. node, className : React. PropTypes. string, content : React. PropTypes. string, disabled : React. PropTypes. bool, instant : React. PropTypes. bool, } module. exports = Reveal ; } ```\nThis code defines a React component named `Reveal` that can be used to display content in a reveal animation. The component takes several props, including `active`, `animated`, `children`, `className`, `content`, `disabled`, and `instant`, which control the behavior and appearance of the reveal animation. The code uses the `cx` function to conditionally apply CSS classes based on the props, and the `getUnhandledProps` and `getElementType` functions to handle props and determine the element type for the component. The component returns a JSX element that renders the content or children based on the `children` prop. Finally, the code defines the default props and prop types for the `Reveal"
    ],
    "smoothed_bleu_4": 0.8520226120116079
  },
  {
    "doc_id": 60,
    "doc": {
      "id": 60,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Segment/Segment.js",
      "func_name": "Segment",
      "original_string": "function Segment(props) {\n  const {\n    attached,\n    basic,\n    children,\n    circular,\n    className,\n    clearing,\n    color,\n    compact,\n    content,\n    disabled,\n    floated,\n    inverted,\n    loading,\n    placeholder,\n    padded,\n    piled,\n    raised,\n    secondary,\n    size,\n    stacked,\n    tertiary,\n    textAlign,\n    vertical,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(basic, 'basic'),\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(clearing, 'clearing'),\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(loading, 'loading'),\n    useKeyOnly(placeholder, 'placeholder'),\n    useKeyOnly(piled, 'piled'),\n    useKeyOnly(raised, 'raised'),\n    useKeyOnly(secondary, 'secondary'),\n    useKeyOnly(stacked, 'stacked'),\n    useKeyOnly(tertiary, 'tertiary'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useTextAlignProp(textAlign),\n    useValueAndKey(floated, 'floated'),\n    'segment',\n    className,\n  )\n  const rest = getUnhandledProps(Segment, props)\n  const ElementType = getElementType(Segment, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Segment(props) {\n  const {\n    attached,\n    basic,\n    children,\n    circular,\n    className,\n    clearing,\n    color,\n    compact,\n    content,\n    disabled,\n    floated,\n    inverted,\n    loading,\n    placeholder,\n    padded,\n    piled,\n    raised,\n    secondary,\n    size,\n    stacked,\n    tertiary,\n    textAlign,\n    vertical,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(basic, 'basic'),\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(clearing, 'clearing'),\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(loading, 'loading'),\n    useKeyOnly(placeholder, 'placeholder'),\n    useKeyOnly(piled, 'piled'),\n    useKeyOnly(raised, 'raised'),\n    useKeyOnly(secondary, 'secondary'),\n    useKeyOnly(stacked, 'stacked'),\n    useKeyOnly(tertiary, 'tertiary'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useTextAlignProp(textAlign),\n    useValueAndKey(floated, 'floated'),\n    'segment',\n    className,\n  )\n  const rest = getUnhandledProps(Segment, props)\n  const ElementType = getElementType(Segment, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Segment",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "attached",
        ",",
        "basic",
        ",",
        "children",
        ",",
        "circular",
        ",",
        "className",
        ",",
        "clearing",
        ",",
        "color",
        ",",
        "compact",
        ",",
        "content",
        ",",
        "disabled",
        ",",
        "floated",
        ",",
        "inverted",
        ",",
        "loading",
        ",",
        "placeholder",
        ",",
        "padded",
        ",",
        "piled",
        ",",
        "raised",
        ",",
        "secondary",
        ",",
        "size",
        ",",
        "stacked",
        ",",
        "tertiary",
        ",",
        "textAlign",
        ",",
        "vertical",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "color",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "basic",
        ",",
        "'basic'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "circular",
        ",",
        "'circular'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "clearing",
        ",",
        "'clearing'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "compact",
        ",",
        "'compact'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "loading",
        ",",
        "'loading'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "placeholder",
        ",",
        "'placeholder'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "piled",
        ",",
        "'piled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "raised",
        ",",
        "'raised'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "secondary",
        ",",
        "'secondary'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "stacked",
        ",",
        "'stacked'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "tertiary",
        ",",
        "'tertiary'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "vertical",
        ",",
        "'vertical'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "attached",
        ",",
        "'attached'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "padded",
        ",",
        "'padded'",
        ")",
        ",",
        "useTextAlignProp",
        "(",
        "textAlign",
        ")",
        ",",
        "useValueAndKey",
        "(",
        "floated",
        ",",
        "'floated'",
        ")",
        ",",
        "'segment'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Segment",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Segment",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A segment is used to create a grouping of related content.",
      "docstring_tokens": [
        "A",
        "segment",
        "is",
        "used",
        "to",
        "create",
        "a",
        "grouping",
        "of",
        "related",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Segment/Segment.js#L23-L83"
    },
    "target": "A segment is used to create a grouping of related content .",
    "arguments": [
      [
        "function Segment ( props ) { const { attached , basic , children , circular , className , clearing , color , compact , content , disabled , floated , inverted , loading , placeholder , padded , piled , raised , secondary , size , stacked , tertiary , textAlign , vertical , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( basic , 'basic' ) , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( clearing , 'clearing' ) , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( loading , 'loading' ) , useKeyOnly ( placeholder , 'placeholder' ) , useKeyOnly ( piled , 'piled' ) , useKeyOnly ( raised , 'raised' ) , useKeyOnly ( secondary , 'secondary' ) , useKeyOnly ( stacked , 'stacked' ) , useKeyOnly ( tertiary , 'tertiary' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useTextAlignProp ( textAlign ) , useValueAndKey ( floated , 'floated' ) , 'segment' , className , ) const rest = getUnhandledProps ( Segment , props ) const ElementType = getElementType ( Segment , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default Segment ; ```\n  2. In the `Segment` component, we use the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props passed to the component. We also use the `useKeyOnly` and `useKeyOrValueAndKey` functions to conditionally apply CSS classes based on the values of certain props.\n  3. We use the `getUnhandledProps` function to get the props that are not handled by the `Segment` component.\n  4. We use the `getElementType` function to get the type of element to render based on the props passed to the component.\n  5. We render the `children` prop, or the `content` prop if `children` is `null` or `undefined`.\n  6. We export the `Segment` component as the default export.\n\nNote that this implementation assumes that the `Segment` component is part of a larger UI component library, and that the `cx` function, `useKeyOnly`, `useKeyOrValueAndKey`, `getUnhandledProps`, and `getElementType` functions are defined elsewhere in the library. Additionally, this implementation assumes that the `childrenUtils`"
      ]
    ],
    "filtered_resps": [
      " export default Segment ; ```\n  2. In the `Segment` component, we use the `cx` function from the `classnames` library to conditionally apply CSS classes based on the props passed to the component. We also use the `useKeyOnly` and `useKeyOrValueAndKey` functions to conditionally apply CSS classes based on the values of certain props.\n  3. We use the `getUnhandledProps` function to get the props that are not handled by the `Segment` component.\n  4. We use the `getElementType` function to get the type of element to render based on the props passed to the component.\n  5. We render the `children` prop, or the `content` prop if `children` is `null` or `undefined`.\n  6. We export the `Segment` component as the default export.\n\nNote that this implementation assumes that the `Segment` component is part of a larger UI component library, and that the `cx` function, `useKeyOnly`, `useKeyOrValueAndKey`, `getUnhandledProps`, and `getElementType` functions are defined elsewhere in the library. Additionally, this implementation assumes that the `childrenUtils`"
    ],
    "smoothed_bleu_4": 0.7318730688072848
  },
  {
    "doc_id": 61,
    "doc": {
      "id": 61,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Placeholder/PlaceholderLine.js",
      "func_name": "PlaceholderLine",
      "original_string": "function PlaceholderLine(props) {\n  const { className, length } = props\n  const classes = cx('line', length, className)\n  const rest = getUnhandledProps(PlaceholderLine, props)\n  const ElementType = getElementType(PlaceholderLine, props)\n\n  return <ElementType {...rest} className={classes} />\n}",
      "language": "javascript",
      "code": "function PlaceholderLine(props) {\n  const { className, length } = props\n  const classes = cx('line', length, className)\n  const rest = getUnhandledProps(PlaceholderLine, props)\n  const ElementType = getElementType(PlaceholderLine, props)\n\n  return <ElementType {...rest} className={classes} />\n}",
      "code_tokens": [
        "function",
        "PlaceholderLine",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        ",",
        "length",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'line'",
        ",",
        "length",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "PlaceholderLine",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "PlaceholderLine",
        ",",
        "props",
        ")",
        "return",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "A placeholder can contain have lines of text.",
      "docstring_tokens": [
        "A",
        "placeholder",
        "can",
        "contain",
        "have",
        "lines",
        "of",
        "text",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Placeholder/PlaceholderLine.js#L10-L17"
    },
    "target": "A placeholder can contain have lines of text .",
    "arguments": [
      [
        "function PlaceholderLine ( props ) { const { className , length } = props const classes = cx ( 'line' , length , className ) const rest = getUnhandledProps ( PlaceholderLine , props ) const ElementType = getElementType ( PlaceholderLine , props ) return < ElementType { ... rest } className = { classes } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " PlaceholderLine. defaultProps = { as : 'div' } export default PlaceholderLine ; ```\n  3. Create a new file called `index.js` in the same directory as `PlaceholderLine.js` and add the following code: ``` import React from'react' import PlaceholderLine from './PlaceholderLine' export default PlaceholderLine ; ```\n  4. In your main application file (e.g. `index.js`), import the `PlaceholderLine` component and use it in your application: ``` import React from'react' import ReactDOM from'react-dom' import PlaceholderLine from './PlaceholderLine' const App = ( ) => { return ( < div > < PlaceholderLine length = { 50 } / > < /div> ); } ReactDOM.render ( < App / >, document.getElementById ( 'root' ) ); ```\n\nThis will render a placeholder line with a length of 50 characters.\n\n### Step 3: Add a placeholder text component\n\nCreate a new file called `PlaceholderText.js` in the same directory as `PlaceholderLine.js` and add the following code:\n```javascript\nimport React from'react';\nimport cx from 'classnames';\n\nconst PlaceholderText = (props) => {\n  const { className, length"
      ]
    ],
    "filtered_resps": [
      " PlaceholderLine. defaultProps = { as : 'div' } export default PlaceholderLine ; ```\n  3. Create a new file called `index.js` in the same directory as `PlaceholderLine.js` and add the following code: ``` import React from'react' import PlaceholderLine from './PlaceholderLine' export default PlaceholderLine ; ```\n  4. In your main application file (e.g. `index.js`), import the `PlaceholderLine` component and use it in your application: ``` import React from'react' import ReactDOM from'react-dom' import PlaceholderLine from './PlaceholderLine' const App = ( ) => { return ( < div > < PlaceholderLine length = { 50 } / > < /div> ); } ReactDOM.render ( < App / >, document.getElementById ( 'root' ) ); ```\n\nThis will render a placeholder line with a length of 50 characters.\n\n### Step 3: Add a placeholder text component\n\nCreate a new file called `PlaceholderText.js` in the same directory as `PlaceholderLine.js` and add the following code:\n```javascript\nimport React from'react';\nimport cx from 'classnames';\n\nconst PlaceholderText = (props) => {\n  const { className, length"
    ],
    "smoothed_bleu_4": 0.6859357819702303
  },
  {
    "doc_id": 62,
    "doc": {
      "id": 62,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Reveal/RevealContent.js",
      "func_name": "RevealContent",
      "original_string": "function RevealContent(props) {\n  const { children, className, content, hidden, visible } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(hidden, 'hidden'),\n    useKeyOnly(visible, 'visible'),\n    'content',\n    className,\n  )\n  const rest = getUnhandledProps(RevealContent, props)\n  const ElementType = getElementType(RevealContent, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function RevealContent(props) {\n  const { children, className, content, hidden, visible } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(hidden, 'hidden'),\n    useKeyOnly(visible, 'visible'),\n    'content',\n    className,\n  )\n  const rest = getUnhandledProps(RevealContent, props)\n  const ElementType = getElementType(RevealContent, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "RevealContent",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "hidden",
        ",",
        "visible",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "hidden",
        ",",
        "'hidden'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "visible",
        ",",
        "'visible'",
        ")",
        ",",
        "'content'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "RevealContent",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "RevealContent",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A content sub-component for the Reveal.",
      "docstring_tokens": [
        "A",
        "content",
        "sub",
        "-",
        "component",
        "for",
        "the",
        "Reveal",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Reveal/RevealContent.js#L16-L34"
    },
    "target": "A content sub - component for the Reveal .",
    "arguments": [
      [
        "function RevealContent ( props ) { const { children , className , content , hidden , visible } = props const classes = cx ( 'ui' , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( visible , 'visible' ) , 'content' , className , ) const rest = getUnhandledProps ( RevealContent , props ) const ElementType = getElementType ( RevealContent , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " RevealContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, hidden : PropTypes. bool, visible : PropTypes. bool, } RevealContent. defaultProps = { hidden : false, visible : false, } RevealContent. displayName = 'RevealContent' export default RevealContent ; ``` This code defines a React component named `RevealContent`. It takes several props, including `children`, `className`, `content`, `hidden`, and `visible`. The component uses the `cx` function to conditionally add CSS classes based on the `hidden` and `visible` props. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component. The component returns a JSX element with the `children` or `content` prop, depending on whether `children` is `null` or not. The `propTypes` and `defaultProps` are defined to specify the expected types and default values for the props. Finally, the `displayName` is set to `'RevealContent'` for debugging purposes. The component is exported as the default export of the module.\n## Step 5: Create the `Reveal` component\n```javascript"
      ]
    ],
    "filtered_resps": [
      " RevealContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, hidden : PropTypes. bool, visible : PropTypes. bool, } RevealContent. defaultProps = { hidden : false, visible : false, } RevealContent. displayName = 'RevealContent' export default RevealContent ; ``` This code defines a React component named `RevealContent`. It takes several props, including `children`, `className`, `content`, `hidden`, and `visible`. The component uses the `cx` function to conditionally add CSS classes based on the `hidden` and `visible` props. It also uses the `getUnhandledProps` function to remove any unnecessary props from the component. The component returns a JSX element with the `children` or `content` prop, depending on whether `children` is `null` or not. The `propTypes` and `defaultProps` are defined to specify the expected types and default values for the props. Finally, the `displayName` is set to `'RevealContent'` for debugging purposes. The component is exported as the default export of the module.\n## Step 5: Create the `Reveal` component\n```javascript"
    ],
    "smoothed_bleu_4": 0.8051396267930744
  },
  {
    "doc_id": 63,
    "doc": {
      "id": 63,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Feed/FeedLike.js",
      "func_name": "FeedLike",
      "original_string": "function FeedLike(props) {\n  const { children, className, content, icon } = props\n\n  const classes = cx('like', className)\n  const rest = getUnhandledProps(FeedLike, props)\n  const ElementType = getElementType(FeedLike, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {Icon.create(icon, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function FeedLike(props) {\n  const { children, className, content, icon } = props\n\n  const classes = cx('like', className)\n  const rest = getUnhandledProps(FeedLike, props)\n  const ElementType = getElementType(FeedLike, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {Icon.create(icon, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "FeedLike",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "icon",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'like'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "FeedLike",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "FeedLike",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "Icon",
        ".",
        "create",
        "(",
        "icon",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "content",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A feed can contain a like element.",
      "docstring_tokens": [
        "A",
        "feed",
        "can",
        "contain",
        "a",
        "like",
        "element",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedLike.js#L11-L32"
    },
    "target": "A feed can contain a like element .",
    "arguments": [
      [
        "function FeedLike ( props ) { const { children , className , content , icon } = props const classes = cx ( 'like' , className ) const rest = getUnhandledProps ( FeedLike , props ) const ElementType = getElementType ( FeedLike , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { Icon . create ( icon , { autoGenerateKey : false } ) } { content } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " FeedLike. defaultProps = { content : 'Like', icon : 'thumbsUp' } export default FeedLike ; ``` This code defines a React component named `FeedLike` that represents a like button. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop. The component also uses the `childrenUtils` object to check if the `children` prop is not null or undefined. If it is not null or undefined, the component renders the children inside the element. Otherwise, it renders an icon and the `content` prop. The `defaultProps` object is used to set default values for the `content` and `icon` props. The `export default` statement exports the `FeedLike` component as the default export of the module. ```javascript\n```\n\nThis code defines a React component named `FeedLike` that represents a like button. It uses the `cx` function from the `classnames` library to condition"
      ]
    ],
    "filtered_resps": [
      " FeedLike. defaultProps = { content : 'Like', icon : 'thumbsUp' } export default FeedLike ; ``` This code defines a React component named `FeedLike` that represents a like button. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the `className` prop. The `getUnhandledProps` function is used to get the props that are not handled by the component, and the `getElementType` function is used to determine the type of element to render based on the `as` prop. The component also uses the `childrenUtils` object to check if the `children` prop is not null or undefined. If it is not null or undefined, the component renders the children inside the element. Otherwise, it renders an icon and the `content` prop. The `defaultProps` object is used to set default values for the `content` and `icon` props. The `export default` statement exports the `FeedLike` component as the default export of the module. ```javascript\n```\n\nThis code defines a React component named `FeedLike` that represents a like button. It uses the `cx` function from the `classnames` library to condition"
    ],
    "smoothed_bleu_4": 0.8157518374673987
  },
  {
    "doc_id": 64,
    "doc": {
      "id": 64,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Placeholder/Placeholder.js",
      "func_name": "Placeholder",
      "original_string": "function Placeholder(props) {\n  const { children, className, content, fluid, inverted } = props\n  const classes = cx(\n    'ui',\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(inverted, 'inverted'),\n    'placeholder',\n    className,\n  )\n  const rest = getUnhandledProps(Placeholder, props)\n  const ElementType = getElementType(Placeholder, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Placeholder(props) {\n  const { children, className, content, fluid, inverted } = props\n  const classes = cx(\n    'ui',\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(inverted, 'inverted'),\n    'placeholder',\n    className,\n  )\n  const rest = getUnhandledProps(Placeholder, props)\n  const ElementType = getElementType(Placeholder, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Placeholder",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "fluid",
        ",",
        "inverted",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "fluid",
        ",",
        "'fluid'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "'placeholder'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Placeholder",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Placeholder",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A placeholder is used to reserve splace for content that soon will appear in a layout.",
      "docstring_tokens": [
        "A",
        "placeholder",
        "is",
        "used",
        "to",
        "reserve",
        "splace",
        "for",
        "content",
        "that",
        "soon",
        "will",
        "appear",
        "in",
        "a",
        "layout",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Placeholder/Placeholder.js#L20-L37"
    },
    "target": "A placeholder is used to reserve splace for content that soon will appear in a layout .",
    "arguments": [
      [
        "function Placeholder ( props ) { const { children , className , content , fluid , inverted } = props const classes = cx ( 'ui' , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( inverted , 'inverted' ) , 'placeholder' , className , ) const rest = getUnhandledProps ( Placeholder , props ) const ElementType = getElementType ( Placeholder , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Placeholder. defaultProps = { as : 'div', content : 'Loading...', fluid : false, inverted : false, } export default Placeholder ; ```\n  2. Create a new file called `index.js` in the same directory as the `Placeholder` component: ```javascript import React from'react' import Placeholder from './Placeholder' export { Placeholder } ```\n  3. In your main application file (e.g. `index.js`), import the `Placeholder` component and use it in your application: ```javascript import React from'react' import ReactDOM from'react-dom' import { Placeholder } from './components/Placeholder' const App = () => ( < div > < Placeholder > Loading... < /Placeholder> < /div> ) ReactDOM.render ( < App / >, document.getElementById ( 'root' ) ) ```\n  4. In your CSS file (e.g. `styles.css`), add the following styles to customize the appearance of the `Placeholder` component: ```css.ui.placeholder { background-color: #f7f7f7; padding: 20px; border: 1px solid #ddd; border-radius: 4px; }.ui.placeholder.fluid { width:"
      ]
    ],
    "filtered_resps": [
      " Placeholder. defaultProps = { as : 'div', content : 'Loading...', fluid : false, inverted : false, } export default Placeholder ; ```\n  2. Create a new file called `index.js` in the same directory as the `Placeholder` component: ```javascript import React from'react' import Placeholder from './Placeholder' export { Placeholder } ```\n  3. In your main application file (e.g. `index.js`), import the `Placeholder` component and use it in your application: ```javascript import React from'react' import ReactDOM from'react-dom' import { Placeholder } from './components/Placeholder' const App = () => ( < div > < Placeholder > Loading... < /Placeholder> < /div> ) ReactDOM.render ( < App / >, document.getElementById ( 'root' ) ) ```\n  4. In your CSS file (e.g. `styles.css`), add the following styles to customize the appearance of the `Placeholder` component: ```css.ui.placeholder { background-color: #f7f7f7; padding: 20px; border: 1px solid #ddd; border-radius: 4px; }.ui.placeholder.fluid { width:"
    ],
    "smoothed_bleu_4": 0.5812783690916163
  },
  {
    "doc_id": 65,
    "doc": {
      "id": 65,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/modules/Accordion/Accordion.js",
      "func_name": "Accordion",
      "original_string": "function Accordion(props) {\n  const { className, fluid, inverted, styled } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(styled, 'styled'),\n    className,\n  )\n  const rest = getUnhandledProps(Accordion, props)\n\n  return <AccordionAccordion {...rest} className={classes} />\n}",
      "language": "javascript",
      "code": "function Accordion(props) {\n  const { className, fluid, inverted, styled } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(styled, 'styled'),\n    className,\n  )\n  const rest = getUnhandledProps(Accordion, props)\n\n  return <AccordionAccordion {...rest} className={classes} />\n}",
      "code_tokens": [
        "function",
        "Accordion",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        ",",
        "fluid",
        ",",
        "inverted",
        ",",
        "styled",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "useKeyOnly",
        "(",
        "fluid",
        ",",
        "'fluid'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "styled",
        ",",
        "'styled'",
        ")",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Accordion",
        ",",
        "props",
        ")",
        "return",
        "<",
        "AccordionAccordion",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "An accordion allows users to toggle the display of sections of content.",
      "docstring_tokens": [
        "An",
        "accordion",
        "allows",
        "users",
        "to",
        "toggle",
        "the",
        "display",
        "of",
        "sections",
        "of",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/modules/Accordion/Accordion.js#L14-L27"
    },
    "target": "An accordion allows users to toggle the display of sections of content .",
    "arguments": [
      [
        "function Accordion ( props ) { const { className , fluid , inverted , styled } = props const classes = cx ( 'ui' , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( styled , 'styled' ) , className , ) const rest = getUnhandledProps ( Accordion , props ) return < AccordionAccordion { ... rest } className = { classes } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Accordion. displayName = 'Accordion' Accordion. __docgenInfo = { description : '', components : { props : { fluid : { type : 'boolean', valueDescription : '' }, inverted : { type : 'boolean', valueDescription : '' }, styled : { type : 'boolean', valueDescription : '' }, }, }, } export default Accordion ```\n\nThis code defines a React component called `Accordion` that wraps the `AccordionAccordion` component from the `semantic-ui-react` library. The `Accordion` component accepts several props, including `className`, `fluid`, `inverted`, and `styled`, which are used to customize the appearance of the accordion. The `getUnhandledProps` function is used to extract the props that are not handled by the `Accordion` component, and these props are passed to the `AccordionAccordion` component using the spread operator (`{... rest }`). The `cx` function is used to combine the classes of the `Accordion` component, and the `useKeyOnly` function is used to determine whether to include certain classes based on the values of the `fluid`, `inverted`, and `styled` props. Finally, the `displayName"
      ]
    ],
    "filtered_resps": [
      " Accordion. displayName = 'Accordion' Accordion. __docgenInfo = { description : '', components : { props : { fluid : { type : 'boolean', valueDescription : '' }, inverted : { type : 'boolean', valueDescription : '' }, styled : { type : 'boolean', valueDescription : '' }, }, }, } export default Accordion ```\n\nThis code defines a React component called `Accordion` that wraps the `AccordionAccordion` component from the `semantic-ui-react` library. The `Accordion` component accepts several props, including `className`, `fluid`, `inverted`, and `styled`, which are used to customize the appearance of the accordion. The `getUnhandledProps` function is used to extract the props that are not handled by the `Accordion` component, and these props are passed to the `AccordionAccordion` component using the spread operator (`{... rest }`). The `cx` function is used to combine the classes of the `Accordion` component, and the `useKeyOnly` function is used to determine whether to include certain classes based on the values of the `fluid`, `inverted`, and `styled` props. Finally, the `displayName"
    ],
    "smoothed_bleu_4": 0.6204531395048289
  },
  {
    "doc_id": 66,
    "doc": {
      "id": 66,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Placeholder/PlaceholderImage.js",
      "func_name": "PlaceholderImage",
      "original_string": "function PlaceholderImage(props) {\n  const { className, square, rectangular } = props\n  const classes = cx(\n    useKeyOnly(square, 'square'),\n    useKeyOnly(rectangular, 'rectangular'),\n    'image',\n    className,\n  )\n  const rest = getUnhandledProps(PlaceholderImage, props)\n  const ElementType = getElementType(PlaceholderImage, props)\n\n  return <ElementType {...rest} className={classes} />\n}",
      "language": "javascript",
      "code": "function PlaceholderImage(props) {\n  const { className, square, rectangular } = props\n  const classes = cx(\n    useKeyOnly(square, 'square'),\n    useKeyOnly(rectangular, 'rectangular'),\n    'image',\n    className,\n  )\n  const rest = getUnhandledProps(PlaceholderImage, props)\n  const ElementType = getElementType(PlaceholderImage, props)\n\n  return <ElementType {...rest} className={classes} />\n}",
      "code_tokens": [
        "function",
        "PlaceholderImage",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        ",",
        "square",
        ",",
        "rectangular",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "square",
        ",",
        "'square'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "rectangular",
        ",",
        "'rectangular'",
        ")",
        ",",
        "'image'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "PlaceholderImage",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "PlaceholderImage",
        ",",
        "props",
        ")",
        "return",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "A placeholder can contain an image.",
      "docstring_tokens": [
        "A",
        "placeholder",
        "can",
        "contain",
        "an",
        "image",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Placeholder/PlaceholderImage.js#L10-L22"
    },
    "target": "A placeholder can contain an image .",
    "arguments": [
      [
        "function PlaceholderImage ( props ) { const { className , square , rectangular } = props const classes = cx ( useKeyOnly ( square , 'square' ) , useKeyOnly ( rectangular , 'rectangular' ) , 'image' , className , ) const rest = getUnhandledProps ( PlaceholderImage , props ) const ElementType = getElementType ( PlaceholderImage , props ) return < ElementType { ... rest } className = { classes } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " PlaceholderImage. defaultProps = { square : false, rectangular : false, } export default PlaceholderImage ; ```\n  3. Create a new file called `index.js` in the same directory as the `PlaceholderImage.js` file, and add the following code: ```javascript import React from'react'; import PlaceholderImage from './PlaceholderImage'; export default PlaceholderImage; ```\n  4. In your main application file (e.g. `App.js`), import the `PlaceholderImage` component and use it as you would any other React component: ```javascript import React from'react'; import PlaceholderImage from './PlaceholderImage'; function App () { return ( < div > < PlaceholderImage square = { true } / > < /div> ); } export default App; ```\n\nThis is a basic example of how you can create a reusable placeholder image component in React. You can customize the appearance and behavior of the component by passing different props to it. For example, you can change the size and shape of the placeholder image by passing different values for the `square` and `rectangular` props. You can also add additional styles or classes to the component by passing a `className` prop.\n\nNote that this is just a basic example"
      ]
    ],
    "filtered_resps": [
      " PlaceholderImage. defaultProps = { square : false, rectangular : false, } export default PlaceholderImage ; ```\n  3. Create a new file called `index.js` in the same directory as the `PlaceholderImage.js` file, and add the following code: ```javascript import React from'react'; import PlaceholderImage from './PlaceholderImage'; export default PlaceholderImage; ```\n  4. In your main application file (e.g. `App.js`), import the `PlaceholderImage` component and use it as you would any other React component: ```javascript import React from'react'; import PlaceholderImage from './PlaceholderImage'; function App () { return ( < div > < PlaceholderImage square = { true } / > < /div> ); } export default App; ```\n\nThis is a basic example of how you can create a reusable placeholder image component in React. You can customize the appearance and behavior of the component by passing different props to it. For example, you can change the size and shape of the placeholder image by passing different values for the `square` and `rectangular` props. You can also add additional styles or classes to the component by passing a `className` prop.\n\nNote that this is just a basic example"
    ],
    "smoothed_bleu_4": 0.5790344614853463
  },
  {
    "doc_id": 67,
    "doc": {
      "id": 67,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/modules/Dropdown/DropdownMenu.js",
      "func_name": "DropdownMenu",
      "original_string": "function DropdownMenu(props) {\n  const { children, className, content, direction, open, scrolling } = props\n  const classes = cx(\n    direction,\n    useKeyOnly(open, 'visible'),\n    useKeyOnly(scrolling, 'scrolling'),\n    'menu transition',\n    className,\n  )\n  const rest = getUnhandledProps(DropdownMenu, props)\n  const ElementType = getElementType(DropdownMenu, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function DropdownMenu(props) {\n  const { children, className, content, direction, open, scrolling } = props\n  const classes = cx(\n    direction,\n    useKeyOnly(open, 'visible'),\n    useKeyOnly(scrolling, 'scrolling'),\n    'menu transition',\n    className,\n  )\n  const rest = getUnhandledProps(DropdownMenu, props)\n  const ElementType = getElementType(DropdownMenu, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "DropdownMenu",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "direction",
        ",",
        "open",
        ",",
        "scrolling",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "direction",
        ",",
        "useKeyOnly",
        "(",
        "open",
        ",",
        "'visible'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "scrolling",
        ",",
        "'scrolling'",
        ")",
        ",",
        "'menu transition'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "DropdownMenu",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "DropdownMenu",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A dropdown menu can contain a menu.",
      "docstring_tokens": [
        "A",
        "dropdown",
        "menu",
        "can",
        "contain",
        "a",
        "menu",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/modules/Dropdown/DropdownMenu.js#L16-L33"
    },
    "target": "A dropdown menu can contain a menu .",
    "arguments": [
      [
        "function DropdownMenu ( props ) { const { children , className , content , direction , open , scrolling } = props const classes = cx ( direction , useKeyOnly ( open , 'visible' ) , useKeyOnly ( scrolling , 'scrolling' ) , 'menu transition' , className , ) const rest = getUnhandledProps ( DropdownMenu , props ) const ElementType = getElementType ( DropdownMenu , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default DropdownMenu ; ```\n  3. In the `DropdownMenu` component, we use the `cx` function to conditionally add classes to the component based on the `open` and `scrolling` props. We also use the `useKeyOnly` function to add the `visible` class when the `open` prop is true, and the `scrolling` class when the `scrolling` prop is true.\n  4. We use the `getUnhandledProps` function to get the props that are not handled by the `DropdownMenu` component, and pass them to the `ElementType` component using the spread operator (`{...rest }`).\n  5. We use the `getElementType` function to get the type of the `DropdownMenu` component based on the `props` object.\n  6. Finally, we return the `ElementType` component with the `children` or `content` prop, depending on whether `children` is null or not.\n\nNote that this implementation assumes that the `DropdownMenu` component is used as a container for other components, and that the `children` prop is used to render the content of the menu. If the `DropdownMenu` component is"
      ]
    ],
    "filtered_resps": [
      " export default DropdownMenu ; ```\n  3. In the `DropdownMenu` component, we use the `cx` function to conditionally add classes to the component based on the `open` and `scrolling` props. We also use the `useKeyOnly` function to add the `visible` class when the `open` prop is true, and the `scrolling` class when the `scrolling` prop is true.\n  4. We use the `getUnhandledProps` function to get the props that are not handled by the `DropdownMenu` component, and pass them to the `ElementType` component using the spread operator (`{...rest }`).\n  5. We use the `getElementType` function to get the type of the `DropdownMenu` component based on the `props` object.\n  6. Finally, we return the `ElementType` component with the `children` or `content` prop, depending on whether `children` is null or not.\n\nNote that this implementation assumes that the `DropdownMenu` component is used as a container for other components, and that the `children` prop is used to render the content of the menu. If the `DropdownMenu` component is"
    ],
    "smoothed_bleu_4": 0.6738835590590182
  },
  {
    "doc_id": 68,
    "doc": {
      "id": 68,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/List/ListIcon.js",
      "func_name": "ListIcon",
      "original_string": "function ListIcon(props) {\n  const { className, verticalAlign } = props\n  const classes = cx(useVerticalAlignProp(verticalAlign), className)\n  const rest = getUnhandledProps(ListIcon, props)\n\n  return <Icon {...rest} className={classes} />\n}",
      "language": "javascript",
      "code": "function ListIcon(props) {\n  const { className, verticalAlign } = props\n  const classes = cx(useVerticalAlignProp(verticalAlign), className)\n  const rest = getUnhandledProps(ListIcon, props)\n\n  return <Icon {...rest} className={classes} />\n}",
      "code_tokens": [
        "function",
        "ListIcon",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        ",",
        "verticalAlign",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ")",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "ListIcon",
        ",",
        "props",
        ")",
        "return",
        "<",
        "Icon",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "A list item can contain an icon.",
      "docstring_tokens": [
        "A",
        "list",
        "item",
        "can",
        "contain",
        "an",
        "icon",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/List/ListIcon.js#L11-L17"
    },
    "target": "A list item can contain an icon .",
    "arguments": [
      [
        "function ListIcon ( props ) { const { className , verticalAlign } = props const classes = cx ( useVerticalAlignProp ( verticalAlign ) , className ) const rest = getUnhandledProps ( ListIcon , props ) return < Icon { ... rest } className = { classes } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ListIcon. displayName ='ListIcon'ListIcon. propTypes = { className : React. PropTypes. string, verticalAlign : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. oneOf ( ['middle ','top ','bottom'] ) ] ), } ListIcon. defaultProps = { verticalAlign :'middle ', } export default ListIcon ; ```\nThis code defines a React component named `ListIcon` that renders an `Icon` component. The `ListIcon` component accepts two props: `className` and `verticalAlign`. The `verticalAlign` prop can be either a string or one of the values `'middle'`, `'top'`, or `'bottom'`. The component uses the `useVerticalAlignProp` function to determine the CSS class name for the `Icon` component based on the `verticalAlign` prop. The `getUnhandledProps` function is used to remove any unnecessary props from the `Icon` component. The `displayName` and `propTypes` properties are set to provide metadata for the component, and the `defaultProps` property is set to provide a default value for the `verticalAlign` prop.\nTo use this component, you"
      ]
    ],
    "filtered_resps": [
      " ListIcon. displayName ='ListIcon'ListIcon. propTypes = { className : React. PropTypes. string, verticalAlign : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. oneOf ( ['middle ','top ','bottom'] ) ] ), } ListIcon. defaultProps = { verticalAlign :'middle ', } export default ListIcon ; ```\nThis code defines a React component named `ListIcon` that renders an `Icon` component. The `ListIcon` component accepts two props: `className` and `verticalAlign`. The `verticalAlign` prop can be either a string or one of the values `'middle'`, `'top'`, or `'bottom'`. The component uses the `useVerticalAlignProp` function to determine the CSS class name for the `Icon` component based on the `verticalAlign` prop. The `getUnhandledProps` function is used to remove any unnecessary props from the `Icon` component. The `displayName` and `propTypes` properties are set to provide metadata for the component, and the `defaultProps` property is set to provide a default value for the `verticalAlign` prop.\nTo use this component, you"
    ],
    "smoothed_bleu_4": 0.6302878499398354
  },
  {
    "doc_id": 69,
    "doc": {
      "id": 69,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Advertisement/Advertisement.js",
      "func_name": "Advertisement",
      "original_string": "function Advertisement(props) {\n  const { centered, children, className, content, test, unit } = props\n\n  const classes = cx(\n    'ui',\n    unit,\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(test, 'test'),\n    'ad',\n    className,\n  )\n  const rest = getUnhandledProps(Advertisement, props)\n  const ElementType = getElementType(Advertisement, props)\n\n  return (\n    <ElementType {...rest} className={classes} data-text={test}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Advertisement(props) {\n  const { centered, children, className, content, test, unit } = props\n\n  const classes = cx(\n    'ui',\n    unit,\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(test, 'test'),\n    'ad',\n    className,\n  )\n  const rest = getUnhandledProps(Advertisement, props)\n  const ElementType = getElementType(Advertisement, props)\n\n  return (\n    <ElementType {...rest} className={classes} data-text={test}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Advertisement",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "centered",
        ",",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "test",
        ",",
        "unit",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "unit",
        ",",
        "useKeyOnly",
        "(",
        "centered",
        ",",
        "'centered'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "test",
        ",",
        "'test'",
        ")",
        ",",
        "'ad'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Advertisement",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Advertisement",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "data-text",
        "=",
        "{",
        "test",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "An ad displays third-party promotional content.",
      "docstring_tokens": [
        "An",
        "ad",
        "displays",
        "third",
        "-",
        "party",
        "promotional",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Advertisement/Advertisement.js#L16-L35"
    },
    "target": "An ad displays third - party promotional content .",
    "arguments": [
      [
        "function Advertisement ( props ) { const { centered , children , className , content , test , unit } = props const classes = cx ( 'ui' , unit , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( test , 'test' ) , 'ad' , className , ) const rest = getUnhandledProps ( Advertisement , props ) const ElementType = getElementType ( Advertisement , props ) return ( < ElementType { ... rest } className = { classes } data-text = { test } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Advertisement.propTypes = { centered : bool, children : node, className : string, content : node, test : string, unit : string, } Advertisement.defaultProps = { centered : false, } Advertisement.displayName = 'Advertisement' Advertisement.handledProps = Object. keys ( Advertisement. propTypes ) Advertisement.create = ( { centered, children, className, content, test, unit } ) = > Advertisement ( { centered, children, className, content, test, unit, } ) Advertisement.__docs__ = { description : 'An advertisement component.', } Advertisement.__docs__.examples = [ { props : { centered : true }, }, { props : { centered : false }, }, ] Advertisement.__docs__.source = `import React from'react'; import { Advertisement } from '@blueprintjs/core'; <Advertisement centered={true} /> <Advertisement centered={false} />` Advertisement.__docs__.seealso = [ 'Button', 'ButtonGroup', ] Advertisement.__docs__.category = 'Components' Advertisement.__docs__.subcategory = 'Layout' Advertisement.__docs__.tags = [ 'Advertisement', 'Layout', ] Advertisement.__docs__.icon = 'icon-advertisement' Advertisement.__docs__.image = 'image-advertisement"
      ]
    ],
    "filtered_resps": [
      " Advertisement.propTypes = { centered : bool, children : node, className : string, content : node, test : string, unit : string, } Advertisement.defaultProps = { centered : false, } Advertisement.displayName = 'Advertisement' Advertisement.handledProps = Object. keys ( Advertisement. propTypes ) Advertisement.create = ( { centered, children, className, content, test, unit } ) = > Advertisement ( { centered, children, className, content, test, unit, } ) Advertisement.__docs__ = { description : 'An advertisement component.', } Advertisement.__docs__.examples = [ { props : { centered : true }, }, { props : { centered : false }, }, ] Advertisement.__docs__.source = `import React from'react'; import { Advertisement } from '@blueprintjs/core'; <Advertisement centered={true} /> <Advertisement centered={false} />` Advertisement.__docs__.seealso = [ 'Button', 'ButtonGroup', ] Advertisement.__docs__.category = 'Components' Advertisement.__docs__.subcategory = 'Layout' Advertisement.__docs__.tags = [ 'Advertisement', 'Layout', ] Advertisement.__docs__.icon = 'icon-advertisement' Advertisement.__docs__.image = 'image-advertisement"
    ],
    "smoothed_bleu_4": 0.4822571937642142
  },
  {
    "doc_id": 70,
    "doc": {
      "id": 70,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Statistic/StatisticGroup.js",
      "func_name": "StatisticGroup",
      "original_string": "function StatisticGroup(props) {\n  const { children, className, color, content, horizontal, inverted, items, size, widths } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(inverted, 'inverted'),\n    useWidthProp(widths),\n    'statistics',\n    className,\n  )\n  const rest = getUnhandledProps(StatisticGroup, props)\n  const ElementType = getElementType(StatisticGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(items, item => Statistic.create(item))}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function StatisticGroup(props) {\n  const { children, className, color, content, horizontal, inverted, items, size, widths } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(inverted, 'inverted'),\n    useWidthProp(widths),\n    'statistics',\n    className,\n  )\n  const rest = getUnhandledProps(StatisticGroup, props)\n  const ElementType = getElementType(StatisticGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(items, item => Statistic.create(item))}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "StatisticGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "color",
        ",",
        "content",
        ",",
        "horizontal",
        ",",
        "inverted",
        ",",
        "items",
        ",",
        "size",
        ",",
        "widths",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "color",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "horizontal",
        ",",
        "'horizontal'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "useWidthProp",
        "(",
        "widths",
        ")",
        ",",
        "'statistics'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "StatisticGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "StatisticGroup",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "_",
        ".",
        "map",
        "(",
        "items",
        ",",
        "item",
        "=>",
        "Statistic",
        ".",
        "create",
        "(",
        "item",
        ")",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A group of statistics.",
      "docstring_tokens": [
        "A",
        "group",
        "of",
        "statistics",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Statistic/StatisticGroup.js#L20-L56"
    },
    "target": "A group of statistics .",
    "arguments": [
      [
        "function StatisticGroup ( props ) { const { children , className , color , content , horizontal , inverted , items , size , widths } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , useWidthProp ( widths ) , 'statistics' , className , ) const rest = getUnhandledProps ( StatisticGroup , props ) const ElementType = getElementType ( StatisticGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( items , item => Statistic . create ( item ) ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " StatisticGroup. defaultProps = { color : 'blue', inverted : false, size :'small', } StatisticGroup. propTypes = { children : _propTypes. node, className : _propTypes. string, color : _propTypes. color, content : _propTypes. node, horizontal : _propTypes. bool, inverted : _propTypes. bool, items : _propTypes. arrayOf ( _propTypes. shape ( { value : _propTypes. number, content : _propTypes. node, } ) ), size : _propTypes. size, widths : _propTypes. arrayOf ( _propTypes. oneOfType ( [ _propTypes. string, _propTypes. number, ] ) ), } export default StatisticGroup ; ``` This code defines a React component named `StatisticGroup` that displays a group of statistics. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the component's props. The `getUnhandledProps` function is used to get the props that are not handled by the component. The `getElementType` function is used to determine the type of element to render based on the component's props. The component can render either children, content, or a list of"
      ]
    ],
    "filtered_resps": [
      " StatisticGroup. defaultProps = { color : 'blue', inverted : false, size :'small', } StatisticGroup. propTypes = { children : _propTypes. node, className : _propTypes. string, color : _propTypes. color, content : _propTypes. node, horizontal : _propTypes. bool, inverted : _propTypes. bool, items : _propTypes. arrayOf ( _propTypes. shape ( { value : _propTypes. number, content : _propTypes. node, } ) ), size : _propTypes. size, widths : _propTypes. arrayOf ( _propTypes. oneOfType ( [ _propTypes. string, _propTypes. number, ] ) ), } export default StatisticGroup ; ``` This code defines a React component named `StatisticGroup` that displays a group of statistics. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the component's props. The `getUnhandledProps` function is used to get the props that are not handled by the component. The `getElementType` function is used to determine the type of element to render based on the component's props. The component can render either children, content, or a list of"
    ],
    "smoothed_bleu_4": 1.7395262161508052
  },
  {
    "doc_id": 71,
    "doc": {
      "id": 71,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Statistic/Statistic.js",
      "func_name": "Statistic",
      "original_string": "function Statistic(props) {\n  const {\n    children,\n    className,\n    color,\n    content,\n    floated,\n    horizontal,\n    inverted,\n    label,\n    size,\n    text,\n    value,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useValueAndKey(floated, 'floated'),\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(inverted, 'inverted'),\n    'statistic',\n    className,\n  )\n  const rest = getUnhandledProps(Statistic, props)\n  const ElementType = getElementType(Statistic, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {StatisticValue.create(value, {\n        defaultProps: { text },\n        autoGenerateKey: false,\n      })}\n      {StatisticLabel.create(label, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Statistic(props) {\n  const {\n    children,\n    className,\n    color,\n    content,\n    floated,\n    horizontal,\n    inverted,\n    label,\n    size,\n    text,\n    value,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useValueAndKey(floated, 'floated'),\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(inverted, 'inverted'),\n    'statistic',\n    className,\n  )\n  const rest = getUnhandledProps(Statistic, props)\n  const ElementType = getElementType(Statistic, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {StatisticValue.create(value, {\n        defaultProps: { text },\n        autoGenerateKey: false,\n      })}\n      {StatisticLabel.create(label, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Statistic",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "color",
        ",",
        "content",
        ",",
        "floated",
        ",",
        "horizontal",
        ",",
        "inverted",
        ",",
        "label",
        ",",
        "size",
        ",",
        "text",
        ",",
        "value",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "color",
        ",",
        "size",
        ",",
        "useValueAndKey",
        "(",
        "floated",
        ",",
        "'floated'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "horizontal",
        ",",
        "'horizontal'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inverted",
        ",",
        "'inverted'",
        ")",
        ",",
        "'statistic'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Statistic",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Statistic",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "StatisticValue",
        ".",
        "create",
        "(",
        "value",
        ",",
        "{",
        "defaultProps",
        ":",
        "{",
        "text",
        "}",
        ",",
        "autoGenerateKey",
        ":",
        "false",
        ",",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "StatisticLabel",
        ".",
        "create",
        "(",
        "label",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A statistic emphasizes the current value of an attribute.",
      "docstring_tokens": [
        "A",
        "statistic",
        "emphasizes",
        "the",
        "current",
        "value",
        "of",
        "an",
        "attribute",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Statistic/Statistic.js#L23-L75"
    },
    "target": "A statistic emphasizes the current value of an attribute .",
    "arguments": [
      [
        "function Statistic ( props ) { const { children , className , color , content , floated , horizontal , inverted , label , size , text , value , } = props const classes = cx ( 'ui' , color , size , useValueAndKey ( floated , 'floated' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , 'statistic' , className , ) const rest = getUnhandledProps ( Statistic , props ) const ElementType = getElementType ( Statistic , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { StatisticValue . create ( value , { defaultProps : { text } , autoGenerateKey : false , } ) } { StatisticLabel . create ( label , { autoGenerateKey : false } ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Statistic. defaultProps = { color : 'blue', size :'mini', } Statistic. propTypes = { children : PropTypes. node, className : PropTypes. string, color : PropTypes. string, content : PropTypes. node, floated : PropTypes. bool, horizontal : PropTypes. bool, inverted : PropTypes. bool, label : PropTypes. node, size : PropTypes. oneOf ( ['mini', 'tiny','small','medium', 'large', 'big', 'huge','massive' ] ), text : PropTypes. string, value : PropTypes. oneOfType ( [ PropTypes. number, PropTypes. string ] ), } Statistic. displayName = 'Statistic' module. exports = Statistic ; })(); });\n```\n\nThis code defines a React component named `Statistic` that displays a statistic with a value and a label. The component accepts various props such as `children`, `className`, `color`, `content`, `floated`, `horizontal`, `inverted`, `label`, `size`, `text`, and `value`. It uses the `cx` function to conditionally apply CSS classes based on the props, and the `getUnhandledProps`"
      ]
    ],
    "filtered_resps": [
      " Statistic. defaultProps = { color : 'blue', size :'mini', } Statistic. propTypes = { children : PropTypes. node, className : PropTypes. string, color : PropTypes. string, content : PropTypes. node, floated : PropTypes. bool, horizontal : PropTypes. bool, inverted : PropTypes. bool, label : PropTypes. node, size : PropTypes. oneOf ( ['mini', 'tiny','small','medium', 'large', 'big', 'huge','massive' ] ), text : PropTypes. string, value : PropTypes. oneOfType ( [ PropTypes. number, PropTypes. string ] ), } Statistic. displayName = 'Statistic' module. exports = Statistic ; })(); });\n```\n\nThis code defines a React component named `Statistic` that displays a statistic with a value and a label. The component accepts various props such as `children`, `className`, `color`, `content`, `floated`, `horizontal`, `inverted`, `label`, `size`, `text`, and `value`. It uses the `cx` function to conditionally apply CSS classes based on the props, and the `getUnhandledProps`"
    ],
    "smoothed_bleu_4": 0.6994253201886912
  },
  {
    "doc_id": 72,
    "doc": {
      "id": 72,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Segment/SegmentGroup.js",
      "func_name": "SegmentGroup",
      "original_string": "function SegmentGroup(props) {\n  const { children, className, compact, content, horizontal, piled, raised, size, stacked } = props\n\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(piled, 'piled'),\n    useKeyOnly(raised, 'raised'),\n    useKeyOnly(stacked, 'stacked'),\n    'segments',\n    className,\n  )\n  const rest = getUnhandledProps(SegmentGroup, props)\n  const ElementType = getElementType(SegmentGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function SegmentGroup(props) {\n  const { children, className, compact, content, horizontal, piled, raised, size, stacked } = props\n\n  const classes = cx(\n    'ui',\n    size,\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(horizontal, 'horizontal'),\n    useKeyOnly(piled, 'piled'),\n    useKeyOnly(raised, 'raised'),\n    useKeyOnly(stacked, 'stacked'),\n    'segments',\n    className,\n  )\n  const rest = getUnhandledProps(SegmentGroup, props)\n  const ElementType = getElementType(SegmentGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "SegmentGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "compact",
        ",",
        "content",
        ",",
        "horizontal",
        ",",
        "piled",
        ",",
        "raised",
        ",",
        "size",
        ",",
        "stacked",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "compact",
        ",",
        "'compact'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "horizontal",
        ",",
        "'horizontal'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "piled",
        ",",
        "'piled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "raised",
        ",",
        "'raised'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "stacked",
        ",",
        "'stacked'",
        ")",
        ",",
        "'segments'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "SegmentGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "SegmentGroup",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A group of segments can be formatted to appear together.",
      "docstring_tokens": [
        "A",
        "group",
        "of",
        "segments",
        "can",
        "be",
        "formatted",
        "to",
        "appear",
        "together",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Segment/SegmentGroup.js#L18-L40"
    },
    "target": "A group of segments can be formatted to appear together .",
    "arguments": [
      [
        "function SegmentGroup ( props ) { const { children , className , compact , content , horizontal , piled , raised , size , stacked } = props const classes = cx ( 'ui' , size , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( piled , 'piled' ) , useKeyOnly ( raised , 'raised' ) , useKeyOnly ( stacked , 'stacked' ) , 'segments' , className , ) const rest = getUnhandledProps ( SegmentGroup , props ) const ElementType = getElementType ( SegmentGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default SegmentGroup ; ```\n  2. In the `SegmentGroup` component, we use the `cx` function from the `classnames` library to conditionally add CSS classes to the component based on the props passed to it. We also use the `useKeyOnly` function from the `classnames` library to conditionally add CSS classes based on the presence of certain props.\n  3. We use the `getUnhandledProps` function from the `react-bootstrap` library to get the props that are not handled by the `SegmentGroup` component.\n  4. We use the `getElementType` function from the `react-bootstrap` library to determine the type of element to render based on the props passed to the `SegmentGroup` component.\n  5. We return a JSX element that renders the `children` prop or the `content` prop if `children` is `null` or `undefined`. We also pass the rest of the props to the element using the spread operator (`{...rest}`).\n\nThe `SegmentGroup` component is now updated to use the `cx` function from the `classnames` library to conditionally add CSS classes, and it uses the `getUnhandledProps` and `get"
      ]
    ],
    "filtered_resps": [
      " export default SegmentGroup ; ```\n  2. In the `SegmentGroup` component, we use the `cx` function from the `classnames` library to conditionally add CSS classes to the component based on the props passed to it. We also use the `useKeyOnly` function from the `classnames` library to conditionally add CSS classes based on the presence of certain props.\n  3. We use the `getUnhandledProps` function from the `react-bootstrap` library to get the props that are not handled by the `SegmentGroup` component.\n  4. We use the `getElementType` function from the `react-bootstrap` library to determine the type of element to render based on the props passed to the `SegmentGroup` component.\n  5. We return a JSX element that renders the `children` prop or the `content` prop if `children` is `null` or `undefined`. We also pass the rest of the props to the element using the spread operator (`{...rest}`).\n\nThe `SegmentGroup` component is now updated to use the `cx` function from the `classnames` library to conditionally add CSS classes, and it uses the `getUnhandledProps` and `get"
    ],
    "smoothed_bleu_4": 0.5986126063324375
  },
  {
    "doc_id": 73,
    "doc": {
      "id": 73,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/collections/Table/TableHeaderCell.js",
      "func_name": "TableHeaderCell",
      "original_string": "function TableHeaderCell(props) {\n  const { as, className, sorted } = props\n  const classes = cx(useValueAndKey(sorted, 'sorted'), className)\n  const rest = getUnhandledProps(TableHeaderCell, props)\n\n  return <TableCell {...rest} as={as} className={classes} />\n}",
      "language": "javascript",
      "code": "function TableHeaderCell(props) {\n  const { as, className, sorted } = props\n  const classes = cx(useValueAndKey(sorted, 'sorted'), className)\n  const rest = getUnhandledProps(TableHeaderCell, props)\n\n  return <TableCell {...rest} as={as} className={classes} />\n}",
      "code_tokens": [
        "function",
        "TableHeaderCell",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "as",
        ",",
        "className",
        ",",
        "sorted",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useValueAndKey",
        "(",
        "sorted",
        ",",
        "'sorted'",
        ")",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "TableHeaderCell",
        ",",
        "props",
        ")",
        "return",
        "<",
        "TableCell",
        "{",
        "...",
        "rest",
        "}",
        "as",
        "=",
        "{",
        "as",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "A table can have a header cell.",
      "docstring_tokens": [
        "A",
        "table",
        "can",
        "have",
        "a",
        "header",
        "cell",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Table/TableHeaderCell.js#L11-L17"
    },
    "target": "A table can have a header cell .",
    "arguments": [
      [
        "function TableHeaderCell ( props ) { const { as , className , sorted } = props const classes = cx ( useValueAndKey ( sorted , 'sorted' ) , className ) const rest = getUnhandledProps ( TableHeaderCell , props ) return < TableCell { ... rest } as = { as } className = { classes } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " TableHeaderCell. propTypes = { as : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. func ] ), className : React. PropTypes. string, sorted : React. PropTypes. bool } TableHeaderCell. defaultProps = { as : 'th', sorted : false } export default TableHeaderCell ; ```\n  2. Create a new file called `TableHeaderCell.js` in the same directory as the previous file, and add the following code: ```jsx import React from'react' import cx from 'classnames' import { useValueAndKey } from'react-utilities' import { TableHeaderCell as BaseTableHeaderCell } from './TableHeaderCell' const TableHeaderCell = ( props ) => { const { as, className, sorted } = props const classes = cx ( useValueAndKey ( sorted,'sorted' ), className ) const rest = getUnhandledProps ( TableHeaderCell, props ) return < BaseTableHeaderCell {... rest } as = { as } className = { classes } / > } TableHeaderCell. propTypes = { as : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. func ] )"
      ]
    ],
    "filtered_resps": [
      " TableHeaderCell. propTypes = { as : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. func ] ), className : React. PropTypes. string, sorted : React. PropTypes. bool } TableHeaderCell. defaultProps = { as : 'th', sorted : false } export default TableHeaderCell ; ```\n  2. Create a new file called `TableHeaderCell.js` in the same directory as the previous file, and add the following code: ```jsx import React from'react' import cx from 'classnames' import { useValueAndKey } from'react-utilities' import { TableHeaderCell as BaseTableHeaderCell } from './TableHeaderCell' const TableHeaderCell = ( props ) => { const { as, className, sorted } = props const classes = cx ( useValueAndKey ( sorted,'sorted' ), className ) const rest = getUnhandledProps ( TableHeaderCell, props ) return < BaseTableHeaderCell {... rest } as = { as } className = { classes } / > } TableHeaderCell. propTypes = { as : React. PropTypes. oneOfType ( [ React. PropTypes. string, React. PropTypes. func ] )"
    ],
    "smoothed_bleu_4": 0.5326832372210699
  },
  {
    "doc_id": 74,
    "doc": {
      "id": 74,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Feed/Feed.js",
      "func_name": "Feed",
      "original_string": "function Feed(props) {\n  const { children, className, events, size } = props\n\n  const classes = cx('ui', size, 'feed', className)\n  const rest = getUnhandledProps(Feed, props)\n  const ElementType = getElementType(Feed, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const eventElements = _.map(events, (eventProps) => {\n    const { childKey, date, meta, summary, ...eventData } = eventProps\n    const finalKey = childKey || [date, meta, summary].join('-')\n\n    return <FeedEvent date={date} key={finalKey} meta={meta} summary={summary} {...eventData} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {eventElements}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Feed(props) {\n  const { children, className, events, size } = props\n\n  const classes = cx('ui', size, 'feed', className)\n  const rest = getUnhandledProps(Feed, props)\n  const ElementType = getElementType(Feed, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const eventElements = _.map(events, (eventProps) => {\n    const { childKey, date, meta, summary, ...eventData } = eventProps\n    const finalKey = childKey || [date, meta, summary].join('-')\n\n    return <FeedEvent date={date} key={finalKey} meta={meta} summary={summary} {...eventData} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {eventElements}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Feed",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "events",
        ",",
        "size",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "size",
        ",",
        "'feed'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Feed",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Feed",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "const",
        "eventElements",
        "=",
        "_",
        ".",
        "map",
        "(",
        "events",
        ",",
        "(",
        "eventProps",
        ")",
        "=>",
        "{",
        "const",
        "{",
        "childKey",
        ",",
        "date",
        ",",
        "meta",
        ",",
        "summary",
        ",",
        "...",
        "eventData",
        "}",
        "=",
        "eventProps",
        "const",
        "finalKey",
        "=",
        "childKey",
        "||",
        "[",
        "date",
        ",",
        "meta",
        ",",
        "summary",
        "]",
        ".",
        "join",
        "(",
        "'-'",
        ")",
        "return",
        "<",
        "FeedEvent",
        "date",
        "=",
        "{",
        "date",
        "}",
        "key",
        "=",
        "{",
        "finalKey",
        "}",
        "meta",
        "=",
        "{",
        "meta",
        "}",
        "summary",
        "=",
        "{",
        "summary",
        "}",
        "{",
        "...",
        "eventData",
        "}",
        "/",
        ">",
        "}",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "eventElements",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A feed presents user activity chronologically.",
      "docstring_tokens": [
        "A",
        "feed",
        "presents",
        "user",
        "activity",
        "chronologically",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/Feed.js#L20-L47"
    },
    "target": "A feed presents user activity chronologically .",
    "arguments": [
      [
        "function Feed ( props ) { const { children , className , events , size } = props const classes = cx ( 'ui' , size , 'feed' , className ) const rest = getUnhandledProps ( Feed , props ) const ElementType = getElementType ( Feed , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const eventElements = _ . map ( events , ( eventProps ) => { const { childKey , date , meta , summary , ... eventData } = eventProps const finalKey = childKey || [ date , meta , summary ] . join ( '-' ) return < FeedEvent date = { date } key = { finalKey } meta = { meta } summary = { summary } { ... eventData } / > } ) return ( < ElementType { ... rest } className = { classes } > { eventElements } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " return < ElementType {... rest } className = { classes } > < / ElementType > } export default Feed ; ``` This code defines a React component called `Feed` that displays a list of events. It uses the `cx` function to conditionally apply CSS classes based on the `size` prop. The component also uses the `getUnhandledProps` and `getElementType` functions to handle props and determine the element type, respectively. If the `children` prop is not null or undefined, it renders the children inside the component. If the `events` prop is not null or undefined, it maps over the events and renders a `FeedEvent` component for each one. The `FeedEvent` component is not shown in this code snippet, but it would be a separate React component that displays a single event. Finally, if neither the `children` nor the `events` prop is present, it renders an empty element with the specified classes. The `export default Feed;` statement exports the `Feed` component as the default export of the module. Note that this code assumes that the `cx` function, `getUnhandledProps`, and `getElementType` functions are defined elsewhere in the codebase, and that the `Feed"
      ]
    ],
    "filtered_resps": [
      " return < ElementType {... rest } className = { classes } > < / ElementType > } export default Feed ; ``` This code defines a React component called `Feed` that displays a list of events. It uses the `cx` function to conditionally apply CSS classes based on the `size` prop. The component also uses the `getUnhandledProps` and `getElementType` functions to handle props and determine the element type, respectively. If the `children` prop is not null or undefined, it renders the children inside the component. If the `events` prop is not null or undefined, it maps over the events and renders a `FeedEvent` component for each one. The `FeedEvent` component is not shown in this code snippet, but it would be a separate React component that displays a single event. Finally, if neither the `children` nor the `events` prop is present, it renders an empty element with the specified classes. The `export default Feed;` statement exports the `Feed` component as the default export of the module. Note that this code assumes that the `cx` function, `getUnhandledProps`, and `getElementType` functions are defined elsewhere in the codebase, and that the `Feed"
    ],
    "smoothed_bleu_4": 0.5388256314173692
  },
  {
    "doc_id": 75,
    "doc": {
      "id": 75,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Label/LabelGroup.js",
      "func_name": "LabelGroup",
      "original_string": "function LabelGroup(props) {\n  const { children, circular, className, color, content, size, tag } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(tag, 'tag'),\n    'labels',\n    className,\n  )\n  const rest = getUnhandledProps(LabelGroup, props)\n  const ElementType = getElementType(LabelGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function LabelGroup(props) {\n  const { children, circular, className, color, content, size, tag } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(tag, 'tag'),\n    'labels',\n    className,\n  )\n  const rest = getUnhandledProps(LabelGroup, props)\n  const ElementType = getElementType(LabelGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "LabelGroup",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "circular",
        ",",
        "className",
        ",",
        "color",
        ",",
        "content",
        ",",
        "size",
        ",",
        "tag",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'ui'",
        ",",
        "color",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "circular",
        ",",
        "'circular'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "tag",
        ",",
        "'tag'",
        ")",
        ",",
        "'labels'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "LabelGroup",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "LabelGroup",
        ",",
        "props",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        "?",
        "content",
        ":",
        "children",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A label can be grouped.",
      "docstring_tokens": [
        "A",
        "label",
        "can",
        "be",
        "grouped",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Label/LabelGroup.js#L17-L37"
    },
    "target": "A label can be grouped .",
    "arguments": [
      [
        "function LabelGroup ( props ) { const { children , circular , className , color , content , size , tag } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( tag , 'tag' ) , 'labels' , className , ) const rest = getUnhandledProps ( LabelGroup , props ) const ElementType = getElementType ( LabelGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " LabelGroup. displayName = 'LabelGroup' LabelGroup. propTypes = { children : PropTypes. node, circular : PropTypes. bool, className : PropTypes. string, color : PropTypes. string, content : PropTypes. node, size : PropTypes. oneOf ( ['mini', 'tiny','small','medium', 'large', 'huge','massive' ] ), tag : PropTypes. oneOf ( [ 'a', 'div' ] ), } LabelGroup. defaultProps = { circular : false, color : 'blue', size :'medium', tag : 'div', } export default LabelGroup ; ``` This code defines a React component named `LabelGroup` that represents a group of labels. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the component's props. The `getUnhandledProps` and `getElementType` functions are used to handle props and determine the component's element type, respectively. The `childrenUtils` object is used to check if the `children` prop is null or undefined, and if so, use the `content` prop instead. The `displayName` and `propTypes`"
      ]
    ],
    "filtered_resps": [
      " LabelGroup. displayName = 'LabelGroup' LabelGroup. propTypes = { children : PropTypes. node, circular : PropTypes. bool, className : PropTypes. string, color : PropTypes. string, content : PropTypes. node, size : PropTypes. oneOf ( ['mini', 'tiny','small','medium', 'large', 'huge','massive' ] ), tag : PropTypes. oneOf ( [ 'a', 'div' ] ), } LabelGroup. defaultProps = { circular : false, color : 'blue', size :'medium', tag : 'div', } export default LabelGroup ; ``` This code defines a React component named `LabelGroup` that represents a group of labels. It uses the `cx` function from the `classnames` library to conditionally apply CSS classes based on the component's props. The `getUnhandledProps` and `getElementType` functions are used to handle props and determine the component's element type, respectively. The `childrenUtils` object is used to check if the `children` prop is null or undefined, and if so, use the `content` prop instead. The `displayName` and `propTypes`"
    ],
    "smoothed_bleu_4": 0.4970592538550282
  },
  {
    "doc_id": 76,
    "doc": {
      "id": 76,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Feed/FeedExtra.js",
      "func_name": "FeedExtra",
      "original_string": "function FeedExtra(props) {\n  const { children, className, content, images, text } = props\n\n  const classes = cx(\n    useKeyOnly(images, 'images'),\n    useKeyOnly(content || text, 'text'),\n    'extra',\n    className,\n  )\n  const rest = getUnhandledProps(FeedExtra, props)\n  const ElementType = getElementType(FeedExtra, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  // TODO need a \"collection factory\" to handle creating multiple image elements and their keys\n  const imageElements = _.map(images, (image, index) => {\n    const key = [index, image].join('-')\n    return createHTMLImage(image, { key })\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {content}\n      {imageElements}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function FeedExtra(props) {\n  const { children, className, content, images, text } = props\n\n  const classes = cx(\n    useKeyOnly(images, 'images'),\n    useKeyOnly(content || text, 'text'),\n    'extra',\n    className,\n  )\n  const rest = getUnhandledProps(FeedExtra, props)\n  const ElementType = getElementType(FeedExtra, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  // TODO need a \"collection factory\" to handle creating multiple image elements and their keys\n  const imageElements = _.map(images, (image, index) => {\n    const key = [index, image].join('-')\n    return createHTMLImage(image, { key })\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {content}\n      {imageElements}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "FeedExtra",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "images",
        ",",
        "text",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "images",
        ",",
        "'images'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "content",
        "||",
        "text",
        ",",
        "'text'",
        ")",
        ",",
        "'extra'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "FeedExtra",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "FeedExtra",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "// TODO need a \"collection factory\" to handle creating multiple image elements and their keys",
        "const",
        "imageElements",
        "=",
        "_",
        ".",
        "map",
        "(",
        "images",
        ",",
        "(",
        "image",
        ",",
        "index",
        ")",
        "=>",
        "{",
        "const",
        "key",
        "=",
        "[",
        "index",
        ",",
        "image",
        "]",
        ".",
        "join",
        "(",
        "'-'",
        ")",
        "return",
        "createHTMLImage",
        "(",
        "image",
        ",",
        "{",
        "key",
        "}",
        ")",
        "}",
        ")",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "content",
        "}",
        "\n      ",
        "{",
        "imageElements",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A feed can contain an extra content.",
      "docstring_tokens": [
        "A",
        "feed",
        "can",
        "contain",
        "an",
        "extra",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedExtra.js#L18-L50"
    },
    "target": "A feed can contain an extra content .",
    "arguments": [
      [
        "function FeedExtra ( props ) { const { children , className , content , images , text } = props const classes = cx ( useKeyOnly ( images , 'images' ) , useKeyOnly ( content || text , 'text' ) , 'extra' , className , ) const rest = getUnhandledProps ( FeedExtra , props ) const ElementType = getElementType ( FeedExtra , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } // TODO need a \"collection factory\" to handle creating multiple image elements and their keys const imageElements = _ . map ( images , ( image , index ) => { const key = [ index , image ] . join ( '-' ) return createHTMLImage ( image , { key } ) } ) return ( < ElementType { ... rest } className = { classes } > { content } { imageElements } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default FeedExtra ; ```\n  3. In the `FeedExtra` component, we use the `useKeyOnly` function to generate a class name based on the `images` and `text` props. We also use the `getUnhandledProps` function to get the rest of the props that are not handled by the component.\n  4. If the `children` prop is not null or undefined, we return a JSX element with the `children` prop as its content.\n  5. If the `children` prop is null or undefined, we create an array of image elements using the `map` function and the `createHTMLImage` function. We use the `join` function to create a unique key for each image element.\n  6. We return a JSX element with the `content` prop and the array of image elements as its content.\n\nNote that this implementation assumes that the `images` prop is an array of image URLs, and the `content` and `text` props are strings. You may need to modify the implementation to fit your specific use case.\n\nAlso, the `createHTMLImage` function is not defined in this code snippet, so you will need to implement it separately."
      ]
    ],
    "filtered_resps": [
      " export default FeedExtra ; ```\n  3. In the `FeedExtra` component, we use the `useKeyOnly` function to generate a class name based on the `images` and `text` props. We also use the `getUnhandledProps` function to get the rest of the props that are not handled by the component.\n  4. If the `children` prop is not null or undefined, we return a JSX element with the `children` prop as its content.\n  5. If the `children` prop is null or undefined, we create an array of image elements using the `map` function and the `createHTMLImage` function. We use the `join` function to create a unique key for each image element.\n  6. We return a JSX element with the `content` prop and the array of image elements as its content.\n\nNote that this implementation assumes that the `images` prop is an array of image URLs, and the `content` and `text` props are strings. You may need to modify the implementation to fit your specific use case.\n\nAlso, the `createHTMLImage` function is not defined in this code snippet, so you will need to implement it separately."
    ],
    "smoothed_bleu_4": 0.721030426206331
  },
  {
    "doc_id": 77,
    "doc": {
      "id": 77,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/modules/Dropdown/DropdownDivider.js",
      "func_name": "DropdownDivider",
      "original_string": "function DropdownDivider(props) {\n  const { className } = props\n  const classes = cx('divider', className)\n  const rest = getUnhandledProps(DropdownDivider, props)\n  const ElementType = getElementType(DropdownDivider, props)\n\n  return <ElementType {...rest} className={classes} />\n}",
      "language": "javascript",
      "code": "function DropdownDivider(props) {\n  const { className } = props\n  const classes = cx('divider', className)\n  const rest = getUnhandledProps(DropdownDivider, props)\n  const ElementType = getElementType(DropdownDivider, props)\n\n  return <ElementType {...rest} className={classes} />\n}",
      "code_tokens": [
        "function",
        "DropdownDivider",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "className",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'divider'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "DropdownDivider",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "DropdownDivider",
        ",",
        "props",
        ")",
        "return",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "/",
        ">",
        "}"
      ],
      "docstring": "A dropdown menu can contain dividers to separate related content.",
      "docstring_tokens": [
        "A",
        "dropdown",
        "menu",
        "can",
        "contain",
        "dividers",
        "to",
        "separate",
        "related",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/modules/Dropdown/DropdownDivider.js#L10-L17"
    },
    "target": "A dropdown menu can contain dividers to separate related content .",
    "arguments": [
      [
        "function DropdownDivider ( props ) { const { className } = props const classes = cx ( 'divider' , className ) const rest = getUnhandledProps ( DropdownDivider , props ) const ElementType = getElementType ( DropdownDivider , props ) return < ElementType { ... rest } className = { classes } / > }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export default DropdownDivider ; ```\n  3. Create a new file called `DropdownDivider.js` in the `src/components/Dropdown` directory and add the following code: ``` import React from'react' import cx from 'classnames' import getElementType from '../utils/getElementType' import getUnhandledProps from '../utils/getUnhandledProps' const DropdownDivider = ( props ) => { const { className } = props const classes = cx ( 'divider', className ) const rest = getUnhandledProps ( DropdownDivider, props ) const ElementType = getElementType ( DropdownDivider, props ) return < ElementType {... rest } className = { classes } / > } export default DropdownDivider ; ```\n  4. Update the `Dropdown.js` file to import the new `DropdownDivider` component: ``` import React from'react' import cx from 'classnames' import getElementType from '../utils/getElementType' import getUnhandledProps from '../utils/getUnhandledProps' import DropdownDivider from './DropdownDivider' const Dropdown = ( props ) => { const { children, className,... rest } = props const ElementType = getElementType ( Dropdown, props ) const classes = cx ( 'ui', 'dropdown', className ) const restProps = getUnhandled"
      ]
    ],
    "filtered_resps": [
      " export default DropdownDivider ; ```\n  3. Create a new file called `DropdownDivider.js` in the `src/components/Dropdown` directory and add the following code: ``` import React from'react' import cx from 'classnames' import getElementType from '../utils/getElementType' import getUnhandledProps from '../utils/getUnhandledProps' const DropdownDivider = ( props ) => { const { className } = props const classes = cx ( 'divider', className ) const rest = getUnhandledProps ( DropdownDivider, props ) const ElementType = getElementType ( DropdownDivider, props ) return < ElementType {... rest } className = { classes } / > } export default DropdownDivider ; ```\n  4. Update the `Dropdown.js` file to import the new `DropdownDivider` component: ``` import React from'react' import cx from 'classnames' import getElementType from '../utils/getElementType' import getUnhandledProps from '../utils/getUnhandledProps' import DropdownDivider from './DropdownDivider' const Dropdown = ( props ) => { const { children, className,... rest } = props const ElementType = getElementType ( Dropdown, props ) const classes = cx ( 'ui', 'dropdown', className ) const restProps = getUnhandled"
    ],
    "smoothed_bleu_4": 0.5584288846755676
  },
  {
    "doc_id": 78,
    "doc": {
      "id": 78,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/views/Feed/FeedSummary.js",
      "func_name": "FeedSummary",
      "original_string": "function FeedSummary(props) {\n  const { children, className, content, date, user } = props\n\n  const classes = cx('summary', className)\n  const rest = getUnhandledProps(FeedSummary, props)\n  const ElementType = getElementType(FeedSummary, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedUser, val => ({ content: val }), user, { autoGenerateKey: false })}\n      {content}\n      {createShorthand(FeedDate, val => ({ content: val }), date, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function FeedSummary(props) {\n  const { children, className, content, date, user } = props\n\n  const classes = cx('summary', className)\n  const rest = getUnhandledProps(FeedSummary, props)\n  const ElementType = getElementType(FeedSummary, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedUser, val => ({ content: val }), user, { autoGenerateKey: false })}\n      {content}\n      {createShorthand(FeedDate, val => ({ content: val }), date, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "FeedSummary",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "date",
        ",",
        "user",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'summary'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "FeedSummary",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "FeedSummary",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "FeedUser",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "content",
        ":",
        "val",
        "}",
        ")",
        ",",
        "user",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "content",
        "}",
        "\n      ",
        "{",
        "createShorthand",
        "(",
        "FeedDate",
        ",",
        "val",
        "=>",
        "(",
        "{",
        "content",
        ":",
        "val",
        "}",
        ")",
        ",",
        "date",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A feed can contain a summary.",
      "docstring_tokens": [
        "A",
        "feed",
        "can",
        "contain",
        "a",
        "summary",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedSummary.js#L18-L40"
    },
    "target": "A feed can contain a summary .",
    "arguments": [
      [
        "function FeedSummary ( props ) { const { children , className , content , date , user } = props const classes = cx ( 'summary' , className ) const rest = getUnhandledProps ( FeedSummary , props ) const ElementType = getElementType ( FeedSummary , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedUser , val => ( { content : val } ) , user , { autoGenerateKey : false } ) } { content } { createShorthand ( FeedDate , val => ( { content : val } ) , date , { autoGenerateKey : false } ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " FeedSummary. defaultProps = { as : 'div' } FeedSummary. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, date : PropTypes. node, user : PropTypes. node, } FeedSummary. displayName = 'FeedSummary' module. exports = FeedSummary ; } ```\n  - The code defines a React component named `FeedSummary`.\n  - The component takes several props, including `children`, `className`, `content`, `date`, and `user`.\n  - It uses the `cx` function to conditionally add a class name to the component based on the presence of the `className` prop.\n  - The `getUnhandledProps` function is used to get the props that are not handled by the component.\n  - The `getElementType` function is used to determine the type of element to render based on the `as` prop.\n  - If the `children` prop is not null or undefined, the component renders the children as the content.\n  - Otherwise, it renders the `user`, `content`, and `date` props as children.\n  - The component"
      ]
    ],
    "filtered_resps": [
      " FeedSummary. defaultProps = { as : 'div' } FeedSummary. propTypes = { as : PropTypes. oneOfType ( [ PropTypes. func, PropTypes. string ] ), children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, date : PropTypes. node, user : PropTypes. node, } FeedSummary. displayName = 'FeedSummary' module. exports = FeedSummary ; } ```\n  - The code defines a React component named `FeedSummary`.\n  - The component takes several props, including `children`, `className`, `content`, `date`, and `user`.\n  - It uses the `cx` function to conditionally add a class name to the component based on the presence of the `className` prop.\n  - The `getUnhandledProps` function is used to get the props that are not handled by the component.\n  - The `getElementType` function is used to determine the type of element to render based on the `as` prop.\n  - If the `children` prop is not null or undefined, the component renders the children as the content.\n  - Otherwise, it renders the `user`, `content`, and `date` props as children.\n  - The component"
    ],
    "smoothed_bleu_4": 0.5477968198903093
  },
  {
    "doc_id": 79,
    "doc": {
      "id": 79,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Step/StepContent.js",
      "func_name": "StepContent",
      "original_string": "function StepContent(props) {\n  const { children, className, content, description, title } = props\n  const classes = cx('content', className)\n  const rest = getUnhandledProps(StepContent, props)\n  const ElementType = getElementType(StepContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {StepTitle.create(title, { autoGenerateKey: false })}\n      {StepDescription.create(description, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function StepContent(props) {\n  const { children, className, content, description, title } = props\n  const classes = cx('content', className)\n  const rest = getUnhandledProps(StepContent, props)\n  const ElementType = getElementType(StepContent, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {StepTitle.create(title, { autoGenerateKey: false })}\n      {StepDescription.create(description, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "StepContent",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "children",
        ",",
        "className",
        ",",
        "content",
        ",",
        "description",
        ",",
        "title",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "'content'",
        ",",
        "className",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "StepContent",
        ",",
        "props",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "StepContent",
        ",",
        "props",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n      ",
        "{",
        "StepTitle",
        ".",
        "create",
        "(",
        "title",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "StepDescription",
        ".",
        "create",
        "(",
        "description",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "A step can contain a content.",
      "docstring_tokens": [
        "A",
        "step",
        "can",
        "contain",
        "a",
        "content",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Step/StepContent.js#L18-L45"
    },
    "target": "A step can contain a content .",
    "arguments": [
      [
        "function StepContent ( props ) { const { children , className , content , description , title } = props const classes = cx ( 'content' , className ) const rest = getUnhandledProps ( StepContent , props ) const ElementType = getElementType ( StepContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { StepTitle . create ( title , { autoGenerateKey : false } ) } { StepDescription . create ( description , { autoGenerateKey : false } ) } < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " StepContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. string, title : PropTypes. string, } StepContent. defaultProps = { children : null, className : '', content : null, description : '', title : '', } StepContent. displayName = 'StepContent' export default StepContent ; ``` StepContent is a React component that represents the content of a step in a wizard. It takes several props, including children, className, content, description, and title. The component uses the cx function to conditionally apply a class name based on the presence of certain props. It also uses the getUnhandledProps and getElementType functions to handle props and determine the component's element type. If children are provided, the component renders them. If content is provided, the component renders the content. If neither children nor content are provided, the component renders a StepTitle and a StepDescription component. The component's propTypes and defaultProps are defined to specify the expected types and default values of its props. The component's displayName is set to 'StepContent' for debugging purposes. The component is exported as the default export of the module.\n## StepTitle\n```javascript"
      ]
    ],
    "filtered_resps": [
      " StepContent. propTypes = { children : PropTypes. node, className : PropTypes. string, content : PropTypes. node, description : PropTypes. string, title : PropTypes. string, } StepContent. defaultProps = { children : null, className : '', content : null, description : '', title : '', } StepContent. displayName = 'StepContent' export default StepContent ; ``` StepContent is a React component that represents the content of a step in a wizard. It takes several props, including children, className, content, description, and title. The component uses the cx function to conditionally apply a class name based on the presence of certain props. It also uses the getUnhandledProps and getElementType functions to handle props and determine the component's element type. If children are provided, the component renders them. If content is provided, the component renders the content. If neither children nor content are provided, the component renders a StepTitle and a StepDescription component. The component's propTypes and defaultProps are defined to specify the expected types and default values of its props. The component's displayName is set to 'StepContent' for debugging purposes. The component is exported as the default export of the module.\n## StepTitle\n```javascript"
    ],
    "smoothed_bleu_4": 0.8024468628703487
  },
  {
    "doc_id": 80,
    "doc": {
      "id": 80,
      "repo": "Semantic-Org/Semantic-UI-React",
      "path": "src/elements/Image/Image.js",
      "func_name": "Image",
      "original_string": "function Image(props) {\n  const {\n    avatar,\n    bordered,\n    centered,\n    children,\n    circular,\n    className,\n    content,\n    dimmer,\n    disabled,\n    floated,\n    fluid,\n    hidden,\n    href,\n    inline,\n    label,\n    rounded,\n    size,\n    spaced,\n    verticalAlign,\n    wrapped,\n    ui,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(ui, 'ui'),\n    size,\n    useKeyOnly(avatar, 'avatar'),\n    useKeyOnly(bordered, 'bordered'),\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(hidden, 'hidden'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(rounded, 'rounded'),\n    useKeyOrValueAndKey(spaced, 'spaced'),\n    useValueAndKey(floated, 'floated'),\n    useVerticalAlignProp(verticalAlign, 'aligned'),\n    'image',\n    className,\n  )\n  const rest = getUnhandledProps(Image, props)\n  const [imgTagProps, rootProps] = partitionHTMLProps(rest, { htmlProps: htmlImageProps })\n  const ElementType = getElementType(Image, props, () => {\n    if (\n      !_.isNil(dimmer) ||\n      !_.isNil(label) ||\n      !_.isNil(wrapped) ||\n      !childrenUtils.isNil(children)\n    ) {\n      return 'div'\n    }\n  })\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  if (ElementType === 'img') {\n    return <ElementType {...rootProps} {...imgTagProps} className={classes} />\n  }\n  return (\n    <ElementType {...rootProps} className={classes} href={href}>\n      {Dimmer.create(dimmer, { autoGenerateKey: false })}\n      {Label.create(label, { autoGenerateKey: false })}\n      <img {...imgTagProps} />\n    </ElementType>\n  )\n}",
      "language": "javascript",
      "code": "function Image(props) {\n  const {\n    avatar,\n    bordered,\n    centered,\n    children,\n    circular,\n    className,\n    content,\n    dimmer,\n    disabled,\n    floated,\n    fluid,\n    hidden,\n    href,\n    inline,\n    label,\n    rounded,\n    size,\n    spaced,\n    verticalAlign,\n    wrapped,\n    ui,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(ui, 'ui'),\n    size,\n    useKeyOnly(avatar, 'avatar'),\n    useKeyOnly(bordered, 'bordered'),\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(hidden, 'hidden'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(rounded, 'rounded'),\n    useKeyOrValueAndKey(spaced, 'spaced'),\n    useValueAndKey(floated, 'floated'),\n    useVerticalAlignProp(verticalAlign, 'aligned'),\n    'image',\n    className,\n  )\n  const rest = getUnhandledProps(Image, props)\n  const [imgTagProps, rootProps] = partitionHTMLProps(rest, { htmlProps: htmlImageProps })\n  const ElementType = getElementType(Image, props, () => {\n    if (\n      !_.isNil(dimmer) ||\n      !_.isNil(label) ||\n      !_.isNil(wrapped) ||\n      !childrenUtils.isNil(children)\n    ) {\n      return 'div'\n    }\n  })\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  if (ElementType === 'img') {\n    return <ElementType {...rootProps} {...imgTagProps} className={classes} />\n  }\n  return (\n    <ElementType {...rootProps} className={classes} href={href}>\n      {Dimmer.create(dimmer, { autoGenerateKey: false })}\n      {Label.create(label, { autoGenerateKey: false })}\n      <img {...imgTagProps} />\n    </ElementType>\n  )\n}",
      "code_tokens": [
        "function",
        "Image",
        "(",
        "props",
        ")",
        "{",
        "const",
        "{",
        "avatar",
        ",",
        "bordered",
        ",",
        "centered",
        ",",
        "children",
        ",",
        "circular",
        ",",
        "className",
        ",",
        "content",
        ",",
        "dimmer",
        ",",
        "disabled",
        ",",
        "floated",
        ",",
        "fluid",
        ",",
        "hidden",
        ",",
        "href",
        ",",
        "inline",
        ",",
        "label",
        ",",
        "rounded",
        ",",
        "size",
        ",",
        "spaced",
        ",",
        "verticalAlign",
        ",",
        "wrapped",
        ",",
        "ui",
        ",",
        "}",
        "=",
        "props",
        "const",
        "classes",
        "=",
        "cx",
        "(",
        "useKeyOnly",
        "(",
        "ui",
        ",",
        "'ui'",
        ")",
        ",",
        "size",
        ",",
        "useKeyOnly",
        "(",
        "avatar",
        ",",
        "'avatar'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "bordered",
        ",",
        "'bordered'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "circular",
        ",",
        "'circular'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "centered",
        ",",
        "'centered'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "disabled",
        ",",
        "'disabled'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "fluid",
        ",",
        "'fluid'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "hidden",
        ",",
        "'hidden'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "inline",
        ",",
        "'inline'",
        ")",
        ",",
        "useKeyOnly",
        "(",
        "rounded",
        ",",
        "'rounded'",
        ")",
        ",",
        "useKeyOrValueAndKey",
        "(",
        "spaced",
        ",",
        "'spaced'",
        ")",
        ",",
        "useValueAndKey",
        "(",
        "floated",
        ",",
        "'floated'",
        ")",
        ",",
        "useVerticalAlignProp",
        "(",
        "verticalAlign",
        ",",
        "'aligned'",
        ")",
        ",",
        "'image'",
        ",",
        "className",
        ",",
        ")",
        "const",
        "rest",
        "=",
        "getUnhandledProps",
        "(",
        "Image",
        ",",
        "props",
        ")",
        "const",
        "[",
        "imgTagProps",
        ",",
        "rootProps",
        "]",
        "=",
        "partitionHTMLProps",
        "(",
        "rest",
        ",",
        "{",
        "htmlProps",
        ":",
        "htmlImageProps",
        "}",
        ")",
        "const",
        "ElementType",
        "=",
        "getElementType",
        "(",
        "Image",
        ",",
        "props",
        ",",
        "(",
        ")",
        "=>",
        "{",
        "if",
        "(",
        "!",
        "_",
        ".",
        "isNil",
        "(",
        "dimmer",
        ")",
        "||",
        "!",
        "_",
        ".",
        "isNil",
        "(",
        "label",
        ")",
        "||",
        "!",
        "_",
        ".",
        "isNil",
        "(",
        "wrapped",
        ")",
        "||",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "'div'",
        "}",
        "}",
        ")",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "children",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "children",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "!",
        "childrenUtils",
        ".",
        "isNil",
        "(",
        "content",
        ")",
        ")",
        "{",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rest",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        ">",
        "\n        ",
        "{",
        "content",
        "}",
        "\n      ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}",
        "if",
        "(",
        "ElementType",
        "===",
        "'img'",
        ")",
        "{",
        "return",
        "<",
        "ElementType",
        "{",
        "...",
        "rootProps",
        "}",
        "{",
        "...",
        "imgTagProps",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "/",
        ">",
        "}",
        "return",
        "(",
        "<",
        "ElementType",
        "{",
        "...",
        "rootProps",
        "}",
        "className",
        "=",
        "{",
        "classes",
        "}",
        "href",
        "=",
        "{",
        "href",
        "}",
        ">",
        "\n      ",
        "{",
        "Dimmer",
        ".",
        "create",
        "(",
        "dimmer",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "{",
        "Label",
        ".",
        "create",
        "(",
        "label",
        ",",
        "{",
        "autoGenerateKey",
        ":",
        "false",
        "}",
        ")",
        "}",
        "\n      ",
        "<",
        "img",
        "{",
        "...",
        "imgTagProps",
        "}",
        "/",
        ">",
        "\n    ",
        "<",
        "/",
        "ElementType",
        ">",
        ")",
        "}"
      ],
      "docstring": "An image is a graphic representation of something.\n@see Icon",
      "docstring_tokens": [
        "An",
        "image",
        "is",
        "a",
        "graphic",
        "representation",
        "of",
        "something",
        "."
      ],
      "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075",
      "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Image/Image.js#L28-L109"
    },
    "target": "An image is a graphic representation of something .",
    "arguments": [
      [
        "function Image ( props ) { const { avatar , bordered , centered , children , circular , className , content , dimmer , disabled , floated , fluid , hidden , href , inline , label , rounded , size , spaced , verticalAlign , wrapped , ui , } = props const classes = cx ( useKeyOnly ( ui , 'ui' ) , size , useKeyOnly ( avatar , 'avatar' ) , useKeyOnly ( bordered , 'bordered' ) , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( rounded , 'rounded' ) , useKeyOrValueAndKey ( spaced , 'spaced' ) , useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign , 'aligned' ) , 'image' , className , ) const rest = getUnhandledProps ( Image , props ) const [ imgTagProps , rootProps ] = partitionHTMLProps ( rest , { htmlProps : htmlImageProps } ) const ElementType = getElementType ( Image , props , ( ) => { if ( ! _ . isNil ( dimmer ) || ! _ . isNil ( label ) || ! _ . isNil ( wrapped ) || ! childrenUtils . isNil ( children ) ) { return 'div' } } ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } if ( ElementType === 'img' ) { return < ElementType { ... rootProps } { ... imgTagProps } className = { classes } / > } return ( < ElementType { ... rootProps } className = { classes } href = { href } > { Dimmer . create ( dimmer , { autoGenerateKey : false } ) } { Label . create ( label , { autoGenerateKey : false } ) } < img { ... imgTagProps } / > < / ElementType > ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " Image. displayName = 'Image' Image. propTypes = { avatar : PropTypes. bool, bordered : PropTypes. bool, centered : PropTypes. bool, children : PropTypes. node, circular : PropTypes. bool, className : PropTypes. string, content : PropTypes. node, dimmer : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. shape ( { active : PropTypes. bool, content : PropTypes. node } ) ] ), disabled : PropTypes. bool, floated : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. oneOf ( [ 'left', 'right' ] ) ] ), fluid : PropTypes. bool, hidden : PropTypes. bool, href : PropTypes. string, inline : PropTypes. bool, label : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. shape ( { as : PropTypes. oneOf ( [ 'a', 'img' ] ), content : PropTypes. node, image : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. shape ( { circular : PropTypes. bool, src : PropTypes. string } ) ] ) } ) ] ), rounded : PropTypes. bool, size : PropTypes. oneOf ( ['mini', 'tiny','small"
      ]
    ],
    "filtered_resps": [
      " Image. displayName = 'Image' Image. propTypes = { avatar : PropTypes. bool, bordered : PropTypes. bool, centered : PropTypes. bool, children : PropTypes. node, circular : PropTypes. bool, className : PropTypes. string, content : PropTypes. node, dimmer : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. shape ( { active : PropTypes. bool, content : PropTypes. node } ) ] ), disabled : PropTypes. bool, floated : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. oneOf ( [ 'left', 'right' ] ) ] ), fluid : PropTypes. bool, hidden : PropTypes. bool, href : PropTypes. string, inline : PropTypes. bool, label : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. shape ( { as : PropTypes. oneOf ( [ 'a', 'img' ] ), content : PropTypes. node, image : PropTypes. oneOfType ( [ PropTypes. bool, PropTypes. shape ( { circular : PropTypes. bool, src : PropTypes. string } ) ] ) } ) ] ), rounded : PropTypes. bool, size : PropTypes. oneOf ( ['mini', 'tiny','small"
    ],
    "smoothed_bleu_4": 0.545526132573025
  },
  {
    "doc_id": 81,
    "doc": {
      "id": 81,
      "repo": "liabru/matter-js",
      "path": "src/render/Render.js",
      "func_name": "",
      "original_string": "function(canvas) {\n        var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\n                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\n                                      || context.backingStorePixelRatio || 1;\n\n        return devicePixelRatio / backingStorePixelRatio;\n    }",
      "language": "javascript",
      "code": "function(canvas) {\n        var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\n                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\n                                      || context.backingStorePixelRatio || 1;\n\n        return devicePixelRatio / backingStorePixelRatio;\n    }",
      "code_tokens": [
        "function",
        "(",
        "canvas",
        ")",
        "{",
        "var",
        "context",
        "=",
        "canvas",
        ".",
        "getContext",
        "(",
        "'2d'",
        ")",
        ",",
        "devicePixelRatio",
        "=",
        "window",
        ".",
        "devicePixelRatio",
        "||",
        "1",
        ",",
        "backingStorePixelRatio",
        "=",
        "context",
        ".",
        "webkitBackingStorePixelRatio",
        "||",
        "context",
        ".",
        "mozBackingStorePixelRatio",
        "||",
        "context",
        ".",
        "msBackingStorePixelRatio",
        "||",
        "context",
        ".",
        "oBackingStorePixelRatio",
        "||",
        "context",
        ".",
        "backingStorePixelRatio",
        "||",
        "1",
        ";",
        "return",
        "devicePixelRatio",
        "/",
        "backingStorePixelRatio",
        ";",
        "}"
      ],
      "docstring": "Gets the pixel ratio of the canvas.\n@method _getPixelRatio\n@private\n@param {HTMLElement} canvas\n@return {Number} pixel ratio",
      "docstring_tokens": [
        "Gets",
        "the",
        "pixel",
        "ratio",
        "of",
        "the",
        "canvas",
        "."
      ],
      "sha": "2ec247b7af1c6b5da6ee05c73274ed5822c73503",
      "url": "https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/render/Render.js#L1348-L1356"
    },
    "target": "Gets the pixel ratio of the canvas .",
    "arguments": [
      [
        "function ( canvas ) { var context = canvas . getContext ( '2d' ) , devicePixelRatio = window . devicePixelRatio || 1 , backingStorePixelRatio = context . webkitBackingStorePixelRatio || context . mozBackingStorePixelRatio || context . msBackingStorePixelRatio || context . oBackingStorePixelRatio || context . backingStorePixelRatio || 1 ; return devicePixelRatio / backingStorePixelRatio ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ) ( document. querySelector ( 'canvas' ) ) ;\n+ var devicePixelRatio = window. devicePixelRatio || 1 ;\n+ var backingStorePixelRatio = context. webkitBackingStorePixelRatio || context. mozBackingStorePixelRatio || context. msBackingStorePixelRatio || context. oBackingStorePixelRatio || context. backingStorePixelRatio || 1 ;\n+ var pixelRatio = devicePixelRatio / backingStorePixelRatio ;\n+ context. setTransform ( 1 / pixelRatio, 0, 0, 1 / pixelRatio, 0, 0 ) ;\n+ context. setLineCap ( 'round' ) ;\n+ context. setLineJoin ( 'round' ) ;\n+ context. setMiterLimit ( 10 ) ;\n+ context. lineWidth = 1 ;\n+ context. strokeStyle = 'rgba(0, 0, 0, 0.5)' ;\n+ context. lineCap = 'round' ;\n+ context. lineJoin = 'round' ;\n+ context. miterLimit = 10 ;\n+ context. lineWidth = 1 ;\n+ context. strokeStyle = 'rgba(0, 0, 0, 0.5)'"
      ]
    ],
    "filtered_resps": [
      " ) ( document. querySelector ( 'canvas' ) ) ;\n+ var devicePixelRatio = window. devicePixelRatio || 1 ;\n+ var backingStorePixelRatio = context. webkitBackingStorePixelRatio || context. mozBackingStorePixelRatio || context. msBackingStorePixelRatio || context. oBackingStorePixelRatio || context. backingStorePixelRatio || 1 ;\n+ var pixelRatio = devicePixelRatio / backingStorePixelRatio ;\n+ context. setTransform ( 1 / pixelRatio, 0, 0, 1 / pixelRatio, 0, 0 ) ;\n+ context. setLineCap ( 'round' ) ;\n+ context. setLineJoin ( 'round' ) ;\n+ context. setMiterLimit ( 10 ) ;\n+ context. lineWidth = 1 ;\n+ context. strokeStyle = 'rgba(0, 0, 0, 0.5)' ;\n+ context. lineCap = 'round' ;\n+ context. lineJoin = 'round' ;\n+ context. miterLimit = 10 ;\n+ context. lineWidth = 1 ;\n+ context. strokeStyle = 'rgba(0, 0, 0, 0.5)'"
    ],
    "smoothed_bleu_4": 0.628384964563742
  },
  {
    "doc_id": 82,
    "doc": {
      "id": 82,
      "repo": "liabru/matter-js",
      "path": "src/render/Render.js",
      "func_name": "",
      "original_string": "function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    }",
      "language": "javascript",
      "code": "function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    }",
      "code_tokens": [
        "function",
        "(",
        "render",
        ",",
        "background",
        ")",
        "{",
        "var",
        "cssBackground",
        "=",
        "background",
        ";",
        "if",
        "(",
        "/",
        "(jpg|gif|png)$",
        "/",
        ".",
        "test",
        "(",
        "background",
        ")",
        ")",
        "cssBackground",
        "=",
        "'url('",
        "+",
        "background",
        "+",
        "')'",
        ";",
        "render",
        ".",
        "canvas",
        ".",
        "style",
        ".",
        "background",
        "=",
        "cssBackground",
        ";",
        "render",
        ".",
        "canvas",
        ".",
        "style",
        ".",
        "backgroundSize",
        "=",
        "\"contain\"",
        ";",
        "render",
        ".",
        "currentBackground",
        "=",
        "background",
        ";",
        "}"
      ],
      "docstring": "Applies the background to the canvas using CSS.\n@method applyBackground\n@private\n@param {render} render\n@param {string} background",
      "docstring_tokens": [
        "Applies",
        "the",
        "background",
        "to",
        "the",
        "canvas",
        "using",
        "CSS",
        "."
      ],
      "sha": "2ec247b7af1c6b5da6ee05c73274ed5822c73503",
      "url": "https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/render/Render.js#L1385-L1394"
    },
    "target": "Applies the background to the canvas using CSS .",
    "arguments": [
      [
        "function ( render , background ) { var cssBackground = background ; if ( / (jpg|gif|png)$ / . test ( background ) ) cssBackground = 'url(' + background + ')' ; render . canvas . style . background = cssBackground ; render . canvas . style . backgroundSize = \"contain\" ; render . currentBackground = background ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        ", function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground = '' ; }, function ( render, background ) { var cssBackground = background ; if ( / (jpg|gif|png)$ /. test ( background ) ) cssBackground = 'url(' + background + ')' ; render. canvas. style. background = cssBackground ; render. canvas. style. backgroundSize = \"contain\" ; render. currentBackground = background ; }, function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground = '' ; } ], function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground = '' ; } ], function ( render, background ) { var cssBackground = background ; if ( / (jpg|gif|png)$ /. test ( background ) ) cssBackground = 'url(' + background + ')' ; render. canvas. style. background = cssBackground ; render. canvas. style. backgroundSize = \"contain\" ; render. currentBackground = background ; }, function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground"
      ]
    ],
    "filtered_resps": [
      ", function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground = '' ; }, function ( render, background ) { var cssBackground = background ; if ( / (jpg|gif|png)$ /. test ( background ) ) cssBackground = 'url(' + background + ')' ; render. canvas. style. background = cssBackground ; render. canvas. style. backgroundSize = \"contain\" ; render. currentBackground = background ; }, function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground = '' ; } ], function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground = '' ; } ], function ( render, background ) { var cssBackground = background ; if ( / (jpg|gif|png)$ /. test ( background ) ) cssBackground = 'url(' + background + ')' ; render. canvas. style. background = cssBackground ; render. canvas. style. backgroundSize = \"contain\" ; render. currentBackground = background ; }, function ( render, background ) { render. canvas. style. background = '' ; render. currentBackground"
    ],
    "smoothed_bleu_4": 0.5259065913533828
  },
  {
    "doc_id": 83,
    "doc": {
      "id": 83,
      "repo": "liabru/matter-js",
      "path": "src/render/RenderPixi.js",
      "func_name": "",
      "original_string": "function(render, body) {\n        var bodyRender = body.render,\n            texturePath = bodyRender.sprite.texture,\n            texture = _getTexture(render, texturePath),\n            sprite = new PIXI.Sprite(texture);\n\n        sprite.anchor.x = body.render.sprite.xOffset;\n        sprite.anchor.y = body.render.sprite.yOffset;\n\n        return sprite;\n    }",
      "language": "javascript",
      "code": "function(render, body) {\n        var bodyRender = body.render,\n            texturePath = bodyRender.sprite.texture,\n            texture = _getTexture(render, texturePath),\n            sprite = new PIXI.Sprite(texture);\n\n        sprite.anchor.x = body.render.sprite.xOffset;\n        sprite.anchor.y = body.render.sprite.yOffset;\n\n        return sprite;\n    }",
      "code_tokens": [
        "function",
        "(",
        "render",
        ",",
        "body",
        ")",
        "{",
        "var",
        "bodyRender",
        "=",
        "body",
        ".",
        "render",
        ",",
        "texturePath",
        "=",
        "bodyRender",
        ".",
        "sprite",
        ".",
        "texture",
        ",",
        "texture",
        "=",
        "_getTexture",
        "(",
        "render",
        ",",
        "texturePath",
        ")",
        ",",
        "sprite",
        "=",
        "new",
        "PIXI",
        ".",
        "Sprite",
        "(",
        "texture",
        ")",
        ";",
        "sprite",
        ".",
        "anchor",
        ".",
        "x",
        "=",
        "body",
        ".",
        "render",
        ".",
        "sprite",
        ".",
        "xOffset",
        ";",
        "sprite",
        ".",
        "anchor",
        ".",
        "y",
        "=",
        "body",
        ".",
        "render",
        ".",
        "sprite",
        ".",
        "yOffset",
        ";",
        "return",
        "sprite",
        ";",
        "}"
      ],
      "docstring": "Creates a body sprite\n@method _createBodySprite\n@private\n@param {RenderPixi} render\n@param {body} body\n@return {PIXI.Sprite} sprite\n@deprecated",
      "docstring_tokens": [
        "Creates",
        "a",
        "body",
        "sprite"
      ],
      "sha": "2ec247b7af1c6b5da6ee05c73274ed5822c73503",
      "url": "https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/render/RenderPixi.js#L420-L430"
    },
    "target": "Creates a body sprite",
    "arguments": [
      [
        "function ( render , body ) { var bodyRender = body . render , texturePath = bodyRender . sprite . texture , texture = _getTexture ( render , texturePath ) , sprite = new PIXI . Sprite ( texture ) ; sprite . anchor . x = body . render . sprite . xOffset ; sprite . anchor . y = body . render . sprite . yOffset ; return sprite ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " } function _getTexture ( render, texturePath ) { var texture = render. textures [ texturePath ] ; if (! texture ) { texture = new PIXI. Texture ( texturePath ) ; render. textures [ texturePath ] = texture ; } return texture ; } function _createSprite ( render, body ) { var bodyRender = body. render, texturePath = bodyRender. sprite. texture, texture = _getTexture ( render, texturePath ), sprite = new PIXI. Sprite ( texture ) ; sprite. anchor. x = body. render. sprite. xOffset ; sprite. anchor. y = body. render. sprite. yOffset ; return sprite ; } function _updateSprite ( render, sprite, body ) { var bodyRender = body. render, texturePath = bodyRender. sprite. texture, texture = _getTexture ( render, texturePath ) ; sprite. texture = texture ; sprite. anchor. x = body. render. sprite. xOffset ; sprite. anchor. y = body. render. sprite. yOffset ; return sprite ; } function _updateSprites ( render, sprites, bodies ) { for ( var i = 0 ; i < sprites. length ; i ++ ) { var sprite ="
      ]
    ],
    "filtered_resps": [
      " } function _getTexture ( render, texturePath ) { var texture = render. textures [ texturePath ] ; if (! texture ) { texture = new PIXI. Texture ( texturePath ) ; render. textures [ texturePath ] = texture ; } return texture ; } function _createSprite ( render, body ) { var bodyRender = body. render, texturePath = bodyRender. sprite. texture, texture = _getTexture ( render, texturePath ), sprite = new PIXI. Sprite ( texture ) ; sprite. anchor. x = body. render. sprite. xOffset ; sprite. anchor. y = body. render. sprite. yOffset ; return sprite ; } function _updateSprite ( render, sprite, body ) { var bodyRender = body. render, texturePath = bodyRender. sprite. texture, texture = _getTexture ( render, texturePath ) ; sprite. texture = texture ; sprite. anchor. x = body. render. sprite. xOffset ; sprite. anchor. y = body. render. sprite. yOffset ; return sprite ; } function _updateSprites ( render, sprites, bodies ) { for ( var i = 0 ; i < sprites. length ; i ++ ) { var sprite ="
    ],
    "smoothed_bleu_4": 0.5142550349861007
  },
  {
    "doc_id": 84,
    "doc": {
      "id": 84,
      "repo": "liabru/matter-js",
      "path": "src/render/RenderPixi.js",
      "func_name": "",
      "original_string": "function(render, body) {\n        var bodyRender = body.render,\n            options = render.options,\n            primitive = new PIXI.Graphics(),\n            fillStyle = Common.colorToNumber(bodyRender.fillStyle),\n            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleWireframe = Common.colorToNumber('#bbb'),\n            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),\n            part;\n\n        primitive.clear();\n\n        // handle compound parts\n        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n            part = body.parts[k];\n\n            if (!options.wireframes) {\n                primitive.beginFill(fillStyle, 1);\n                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);\n            } else {\n                primitive.beginFill(0, 0);\n                primitive.lineStyle(1, strokeStyleWireframe, 1);\n            }\n\n            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            for (var j = 1; j < part.vertices.length; j++) {\n                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);\n            }\n\n            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            primitive.endFill();\n\n            // angle indicator\n            if (options.showAngleIndicator || options.showAxes) {\n                primitive.beginFill(0, 0);\n\n                if (options.wireframes) {\n                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);\n                } else {\n                    primitive.lineStyle(1, strokeStyleIndicator);\n                }\n\n                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);\n                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), \n                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));\n\n                primitive.endFill();\n            }\n        }\n\n        return primitive;\n    }",
      "language": "javascript",
      "code": "function(render, body) {\n        var bodyRender = body.render,\n            options = render.options,\n            primitive = new PIXI.Graphics(),\n            fillStyle = Common.colorToNumber(bodyRender.fillStyle),\n            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleWireframe = Common.colorToNumber('#bbb'),\n            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),\n            part;\n\n        primitive.clear();\n\n        // handle compound parts\n        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n            part = body.parts[k];\n\n            if (!options.wireframes) {\n                primitive.beginFill(fillStyle, 1);\n                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);\n            } else {\n                primitive.beginFill(0, 0);\n                primitive.lineStyle(1, strokeStyleWireframe, 1);\n            }\n\n            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            for (var j = 1; j < part.vertices.length; j++) {\n                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);\n            }\n\n            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            primitive.endFill();\n\n            // angle indicator\n            if (options.showAngleIndicator || options.showAxes) {\n                primitive.beginFill(0, 0);\n\n                if (options.wireframes) {\n                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);\n                } else {\n                    primitive.lineStyle(1, strokeStyleIndicator);\n                }\n\n                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);\n                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), \n                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));\n\n                primitive.endFill();\n            }\n        }\n\n        return primitive;\n    }",
      "code_tokens": [
        "function",
        "(",
        "render",
        ",",
        "body",
        ")",
        "{",
        "var",
        "bodyRender",
        "=",
        "body",
        ".",
        "render",
        ",",
        "options",
        "=",
        "render",
        ".",
        "options",
        ",",
        "primitive",
        "=",
        "new",
        "PIXI",
        ".",
        "Graphics",
        "(",
        ")",
        ",",
        "fillStyle",
        "=",
        "Common",
        ".",
        "colorToNumber",
        "(",
        "bodyRender",
        ".",
        "fillStyle",
        ")",
        ",",
        "strokeStyle",
        "=",
        "Common",
        ".",
        "colorToNumber",
        "(",
        "bodyRender",
        ".",
        "strokeStyle",
        ")",
        ",",
        "strokeStyleIndicator",
        "=",
        "Common",
        ".",
        "colorToNumber",
        "(",
        "bodyRender",
        ".",
        "strokeStyle",
        ")",
        ",",
        "strokeStyleWireframe",
        "=",
        "Common",
        ".",
        "colorToNumber",
        "(",
        "'#bbb'",
        ")",
        ",",
        "strokeStyleWireframeIndicator",
        "=",
        "Common",
        ".",
        "colorToNumber",
        "(",
        "'#CD5C5C'",
        ")",
        ",",
        "part",
        ";",
        "primitive",
        ".",
        "clear",
        "(",
        ")",
        ";",
        "// handle compound parts",
        "for",
        "(",
        "var",
        "k",
        "=",
        "body",
        ".",
        "parts",
        ".",
        "length",
        ">",
        "1",
        "?",
        "1",
        ":",
        "0",
        ";",
        "k",
        "<",
        "body",
        ".",
        "parts",
        ".",
        "length",
        ";",
        "k",
        "++",
        ")",
        "{",
        "part",
        "=",
        "body",
        ".",
        "parts",
        "[",
        "k",
        "]",
        ";",
        "if",
        "(",
        "!",
        "options",
        ".",
        "wireframes",
        ")",
        "{",
        "primitive",
        ".",
        "beginFill",
        "(",
        "fillStyle",
        ",",
        "1",
        ")",
        ";",
        "primitive",
        ".",
        "lineStyle",
        "(",
        "bodyRender",
        ".",
        "lineWidth",
        ",",
        "strokeStyle",
        ",",
        "1",
        ")",
        ";",
        "}",
        "else",
        "{",
        "primitive",
        ".",
        "beginFill",
        "(",
        "0",
        ",",
        "0",
        ")",
        ";",
        "primitive",
        ".",
        "lineStyle",
        "(",
        "1",
        ",",
        "strokeStyleWireframe",
        ",",
        "1",
        ")",
        ";",
        "}",
        "primitive",
        ".",
        "moveTo",
        "(",
        "part",
        ".",
        "vertices",
        "[",
        "0",
        "]",
        ".",
        "x",
        "-",
        "body",
        ".",
        "position",
        ".",
        "x",
        ",",
        "part",
        ".",
        "vertices",
        "[",
        "0",
        "]",
        ".",
        "y",
        "-",
        "body",
        ".",
        "position",
        ".",
        "y",
        ")",
        ";",
        "for",
        "(",
        "var",
        "j",
        "=",
        "1",
        ";",
        "j",
        "<",
        "part",
        ".",
        "vertices",
        ".",
        "length",
        ";",
        "j",
        "++",
        ")",
        "{",
        "primitive",
        ".",
        "lineTo",
        "(",
        "part",
        ".",
        "vertices",
        "[",
        "j",
        "]",
        ".",
        "x",
        "-",
        "body",
        ".",
        "position",
        ".",
        "x",
        ",",
        "part",
        ".",
        "vertices",
        "[",
        "j",
        "]",
        ".",
        "y",
        "-",
        "body",
        ".",
        "position",
        ".",
        "y",
        ")",
        ";",
        "}",
        "primitive",
        ".",
        "lineTo",
        "(",
        "part",
        ".",
        "vertices",
        "[",
        "0",
        "]",
        ".",
        "x",
        "-",
        "body",
        ".",
        "position",
        ".",
        "x",
        ",",
        "part",
        ".",
        "vertices",
        "[",
        "0",
        "]",
        ".",
        "y",
        "-",
        "body",
        ".",
        "position",
        ".",
        "y",
        ")",
        ";",
        "primitive",
        ".",
        "endFill",
        "(",
        ")",
        ";",
        "// angle indicator",
        "if",
        "(",
        "options",
        ".",
        "showAngleIndicator",
        "||",
        "options",
        ".",
        "showAxes",
        ")",
        "{",
        "primitive",
        ".",
        "beginFill",
        "(",
        "0",
        ",",
        "0",
        ")",
        ";",
        "if",
        "(",
        "options",
        ".",
        "wireframes",
        ")",
        "{",
        "primitive",
        ".",
        "lineStyle",
        "(",
        "1",
        ",",
        "strokeStyleWireframeIndicator",
        ",",
        "1",
        ")",
        ";",
        "}",
        "else",
        "{",
        "primitive",
        ".",
        "lineStyle",
        "(",
        "1",
        ",",
        "strokeStyleIndicator",
        ")",
        ";",
        "}",
        "primitive",
        ".",
        "moveTo",
        "(",
        "part",
        ".",
        "position",
        ".",
        "x",
        "-",
        "body",
        ".",
        "position",
        ".",
        "x",
        ",",
        "part",
        ".",
        "position",
        ".",
        "y",
        "-",
        "body",
        ".",
        "position",
        ".",
        "y",
        ")",
        ";",
        "primitive",
        ".",
        "lineTo",
        "(",
        "(",
        "(",
        "part",
        ".",
        "vertices",
        "[",
        "0",
        "]",
        ".",
        "x",
        "+",
        "part",
        ".",
        "vertices",
        "[",
        "part",
        ".",
        "vertices",
        ".",
        "length",
        "-",
        "1",
        "]",
        ".",
        "x",
        ")",
        "/",
        "2",
        "-",
        "body",
        ".",
        "position",
        ".",
        "x",
        ")",
        ",",
        "(",
        "(",
        "part",
        ".",
        "vertices",
        "[",
        "0",
        "]",
        ".",
        "y",
        "+",
        "part",
        ".",
        "vertices",
        "[",
        "part",
        ".",
        "vertices",
        ".",
        "length",
        "-",
        "1",
        "]",
        ".",
        "y",
        ")",
        "/",
        "2",
        "-",
        "body",
        ".",
        "position",
        ".",
        "y",
        ")",
        ")",
        ";",
        "primitive",
        ".",
        "endFill",
        "(",
        ")",
        ";",
        "}",
        "}",
        "return",
        "primitive",
        ";",
        "}"
      ],
      "docstring": "Creates a body primitive\n@method _createBodyPrimitive\n@private\n@param {RenderPixi} render\n@param {body} body\n@return {PIXI.Graphics} graphics\n@deprecated",
      "docstring_tokens": [
        "Creates",
        "a",
        "body",
        "primitive"
      ],
      "sha": "2ec247b7af1c6b5da6ee05c73274ed5822c73503",
      "url": "https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/render/RenderPixi.js#L441-L495"
    },
    "target": "Creates a body primitive",
    "arguments": [
      [
        "function ( render , body ) { var bodyRender = body . render , options = render . options , primitive = new PIXI . Graphics ( ) , fillStyle = Common . colorToNumber ( bodyRender . fillStyle ) , strokeStyle = Common . colorToNumber ( bodyRender . strokeStyle ) , strokeStyleIndicator = Common . colorToNumber ( bodyRender . strokeStyle ) , strokeStyleWireframe = Common . colorToNumber ( '#bbb' ) , strokeStyleWireframeIndicator = Common . colorToNumber ( '#CD5C5C' ) , part ; primitive . clear ( ) ; // handle compound parts for ( var k = body . parts . length > 1 ? 1 : 0 ; k < body . parts . length ; k ++ ) { part = body . parts [ k ] ; if ( ! options . wireframes ) { primitive . beginFill ( fillStyle , 1 ) ; primitive . lineStyle ( bodyRender . lineWidth , strokeStyle , 1 ) ; } else { primitive . beginFill ( 0 , 0 ) ; primitive . lineStyle ( 1 , strokeStyleWireframe , 1 ) ; } primitive . moveTo ( part . vertices [ 0 ] . x - body . position . x , part . vertices [ 0 ] . y - body . position . y ) ; for ( var j = 1 ; j < part . vertices . length ; j ++ ) { primitive . lineTo ( part . vertices [ j ] . x - body . position . x , part . vertices [ j ] . y - body . position . y ) ; } primitive . lineTo ( part . vertices [ 0 ] . x - body . position . x , part . vertices [ 0 ] . y - body . position . y ) ; primitive . endFill ( ) ; // angle indicator if ( options . showAngleIndicator || options . showAxes ) { primitive . beginFill ( 0 , 0 ) ; if ( options . wireframes ) { primitive . lineStyle ( 1 , strokeStyleWireframeIndicator , 1 ) ; } else { primitive . lineStyle ( 1 , strokeStyleIndicator ) ; } primitive . moveTo ( part . position . x - body . position . x , part . position . y - body . position . y ) ; primitive . lineTo ( ( ( part . vertices [ 0 ] . x + part . vertices [ part . vertices . length - 1 ] . x ) / 2 - body . position . x ) , ( ( part . vertices [ 0 ] . y + part . vertices [ part . vertices . length - 1 ] . y ) / 2 - body . position . y ) ) ; primitive . endFill ( ) ; } } return primitive ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " }, render : { options : { showAngleIndicator : false, showAxes : false, wireframes : false } } } }, { id : 'body', type : 'body', parts : [ { vertices : [ { x : 0, y : 0 }, { x : 1, y : 0 }, { x : 1, y : 1 }, { x : 0, y : 1 } ], position : { x : 0, y : 0 } } ], position : { x : 0, y : 0 }, render : { fillStyle : '0x00ff00', strokeStyle : '0x00ff00', lineWidth : 1 } }, { id : 'body', type : 'body', parts : [ { vertices : [ { x : 0, y : 0 }, { x : 1, y : 0 }, { x : 1, y : 1 }, { x : 0, y : 1 } ], position : { x : 0, y : 0 } } ], position : { x : "
      ]
    ],
    "filtered_resps": [
      " }, render : { options : { showAngleIndicator : false, showAxes : false, wireframes : false } } } }, { id : 'body', type : 'body', parts : [ { vertices : [ { x : 0, y : 0 }, { x : 1, y : 0 }, { x : 1, y : 1 }, { x : 0, y : 1 } ], position : { x : 0, y : 0 } } ], position : { x : 0, y : 0 }, render : { fillStyle : '0x00ff00', strokeStyle : '0x00ff00', lineWidth : 1 } }, { id : 'body', type : 'body', parts : [ { vertices : [ { x : 0, y : 0 }, { x : 1, y : 0 }, { x : 1, y : 1 }, { x : 0, y : 1 } ], position : { x : 0, y : 0 } } ], position : { x : "
    ],
    "smoothed_bleu_4": 0.4733764321337928
  },
  {
    "doc_id": 85,
    "doc": {
      "id": 85,
      "repo": "liabru/matter-js",
      "path": "src/body/Body.js",
      "func_name": "",
      "original_string": "function(body, options) {\n        options = options || {};\n\n        // init required properties (order is important)\n        Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            parts: body.parts || [body],\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping,\n            parent: body.parent || body\n        });\n\n        Vertices.rotate(body.vertices, body.angle, body.position);\n        Axes.rotate(body.axes, body.angle);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n\n        // allow options to override the automatically calculated properties\n        Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n        });\n\n        // render properties\n        var defaultFillStyle = (body.isStatic ? '#2e2b44' : Common.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56'])),\n            defaultStrokeStyle = '#000';\n        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n    }",
      "language": "javascript",
      "code": "function(body, options) {\n        options = options || {};\n\n        // init required properties (order is important)\n        Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            parts: body.parts || [body],\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping,\n            parent: body.parent || body\n        });\n\n        Vertices.rotate(body.vertices, body.angle, body.position);\n        Axes.rotate(body.axes, body.angle);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n\n        // allow options to override the automatically calculated properties\n        Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n        });\n\n        // render properties\n        var defaultFillStyle = (body.isStatic ? '#2e2b44' : Common.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56'])),\n            defaultStrokeStyle = '#000';\n        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n    }",
      "code_tokens": [
        "function",
        "(",
        "body",
        ",",
        "options",
        ")",
        "{",
        "options",
        "=",
        "options",
        "||",
        "{",
        "}",
        ";",
        "// init required properties (order is important)",
        "Body",
        ".",
        "set",
        "(",
        "body",
        ",",
        "{",
        "bounds",
        ":",
        "body",
        ".",
        "bounds",
        "||",
        "Bounds",
        ".",
        "create",
        "(",
        "body",
        ".",
        "vertices",
        ")",
        ",",
        "positionPrev",
        ":",
        "body",
        ".",
        "positionPrev",
        "||",
        "Vector",
        ".",
        "clone",
        "(",
        "body",
        ".",
        "position",
        ")",
        ",",
        "anglePrev",
        ":",
        "body",
        ".",
        "anglePrev",
        "||",
        "body",
        ".",
        "angle",
        ",",
        "vertices",
        ":",
        "body",
        ".",
        "vertices",
        ",",
        "parts",
        ":",
        "body",
        ".",
        "parts",
        "||",
        "[",
        "body",
        "]",
        ",",
        "isStatic",
        ":",
        "body",
        ".",
        "isStatic",
        ",",
        "isSleeping",
        ":",
        "body",
        ".",
        "isSleeping",
        ",",
        "parent",
        ":",
        "body",
        ".",
        "parent",
        "||",
        "body",
        "}",
        ")",
        ";",
        "Vertices",
        ".",
        "rotate",
        "(",
        "body",
        ".",
        "vertices",
        ",",
        "body",
        ".",
        "angle",
        ",",
        "body",
        ".",
        "position",
        ")",
        ";",
        "Axes",
        ".",
        "rotate",
        "(",
        "body",
        ".",
        "axes",
        ",",
        "body",
        ".",
        "angle",
        ")",
        ";",
        "Bounds",
        ".",
        "update",
        "(",
        "body",
        ".",
        "bounds",
        ",",
        "body",
        ".",
        "vertices",
        ",",
        "body",
        ".",
        "velocity",
        ")",
        ";",
        "// allow options to override the automatically calculated properties",
        "Body",
        ".",
        "set",
        "(",
        "body",
        ",",
        "{",
        "axes",
        ":",
        "options",
        ".",
        "axes",
        "||",
        "body",
        ".",
        "axes",
        ",",
        "area",
        ":",
        "options",
        ".",
        "area",
        "||",
        "body",
        ".",
        "area",
        ",",
        "mass",
        ":",
        "options",
        ".",
        "mass",
        "||",
        "body",
        ".",
        "mass",
        ",",
        "inertia",
        ":",
        "options",
        ".",
        "inertia",
        "||",
        "body",
        ".",
        "inertia",
        "}",
        ")",
        ";",
        "// render properties",
        "var",
        "defaultFillStyle",
        "=",
        "(",
        "body",
        ".",
        "isStatic",
        "?",
        "'#2e2b44'",
        ":",
        "Common",
        ".",
        "choose",
        "(",
        "[",
        "'#006BA6'",
        ",",
        "'#0496FF'",
        ",",
        "'#FFBC42'",
        ",",
        "'#D81159'",
        ",",
        "'#8F2D56'",
        "]",
        ")",
        ")",
        ",",
        "defaultStrokeStyle",
        "=",
        "'#000'",
        ";",
        "body",
        ".",
        "render",
        ".",
        "fillStyle",
        "=",
        "body",
        ".",
        "render",
        ".",
        "fillStyle",
        "||",
        "defaultFillStyle",
        ";",
        "body",
        ".",
        "render",
        ".",
        "strokeStyle",
        "=",
        "body",
        ".",
        "render",
        ".",
        "strokeStyle",
        "||",
        "defaultStrokeStyle",
        ";",
        "body",
        ".",
        "render",
        ".",
        "sprite",
        ".",
        "xOffset",
        "+=",
        "-",
        "(",
        "body",
        ".",
        "bounds",
        ".",
        "min",
        ".",
        "x",
        "-",
        "body",
        ".",
        "position",
        ".",
        "x",
        ")",
        "/",
        "(",
        "body",
        ".",
        "bounds",
        ".",
        "max",
        ".",
        "x",
        "-",
        "body",
        ".",
        "bounds",
        ".",
        "min",
        ".",
        "x",
        ")",
        ";",
        "body",
        ".",
        "render",
        ".",
        "sprite",
        ".",
        "yOffset",
        "+=",
        "-",
        "(",
        "body",
        ".",
        "bounds",
        ".",
        "min",
        ".",
        "y",
        "-",
        "body",
        ".",
        "position",
        ".",
        "y",
        ")",
        "/",
        "(",
        "body",
        ".",
        "bounds",
        ".",
        "max",
        ".",
        "y",
        "-",
        "body",
        ".",
        "bounds",
        ".",
        "min",
        ".",
        "y",
        ")",
        ";",
        "}"
      ],
      "docstring": "Initialises body properties.\n@method _initProperties\n@private\n@param {body} body\n@param {} [options]",
      "docstring_tokens": [
        "Initialises",
        "body",
        "properties",
        "."
      ],
      "sha": "2ec247b7af1c6b5da6ee05c73274ed5822c73503",
      "url": "https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/body/Body.js#L141-L175"
    },
    "target": "Initialises body properties .",
    "arguments": [
      [
        "function ( body , options ) { options = options || { } ; // init required properties (order is important) Body . set ( body , { bounds : body . bounds || Bounds . create ( body . vertices ) , positionPrev : body . positionPrev || Vector . clone ( body . position ) , anglePrev : body . anglePrev || body . angle , vertices : body . vertices , parts : body . parts || [ body ] , isStatic : body . isStatic , isSleeping : body . isSleeping , parent : body . parent || body } ) ; Vertices . rotate ( body . vertices , body . angle , body . position ) ; Axes . rotate ( body . axes , body . angle ) ; Bounds . update ( body . bounds , body . vertices , body . velocity ) ; // allow options to override the automatically calculated properties Body . set ( body , { axes : options . axes || body . axes , area : options . area || body . area , mass : options . mass || body . mass , inertia : options . inertia || body . inertia } ) ; // render properties var defaultFillStyle = ( body . isStatic ? '#2e2b44' : Common . choose ( [ '#006BA6' , '#0496FF' , '#FFBC42' , '#D81159' , '#8F2D56' ] ) ) , defaultStrokeStyle = '#000' ; body . render . fillStyle = body . render . fillStyle || defaultFillStyle ; body . render . strokeStyle = body . render . strokeStyle || defaultStrokeStyle ; body . render . sprite . xOffset += - ( body . bounds . min . x - body . position . x ) / ( body . bounds . max . x - body . bounds . min . x ) ; body . render . sprite . yOffset += - ( body . bounds . min . y - body . position . y ) / ( body . bounds . max . y - body . bounds . min . y ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        ", update : function ( body, options ) { options = options || { } ; // init required properties (order is important) Body. set ( body, { bounds : body. bounds || Bounds. create ( body. vertices ), positionPrev : body. positionPrev || Vector. clone ( body. position ), anglePrev : body. anglePrev || body. angle, vertices : body. vertices, parts : body. parts || [ body ], isStatic : body. isStatic, isSleeping : body. isSleeping, parent : body. parent || body } ) ; Vertices. rotate ( body. vertices, body. angle, body. position ) ; Axes. rotate ( body. axes, body. angle ) ; Bounds. update ( body. bounds, body. vertices, body. velocity ) ; // allow options to override the automatically calculated properties Body. set ( body, { axes : options. axes || body. axes, area : options. area || body. area, mass : options. mass || body. mass, inertia : options. inertia || body. inertia } ) ; // render properties var defaultFillStyle = ( body. isStatic? '#2e2b44' : Common"
      ]
    ],
    "filtered_resps": [
      ", update : function ( body, options ) { options = options || { } ; // init required properties (order is important) Body. set ( body, { bounds : body. bounds || Bounds. create ( body. vertices ), positionPrev : body. positionPrev || Vector. clone ( body. position ), anglePrev : body. anglePrev || body. angle, vertices : body. vertices, parts : body. parts || [ body ], isStatic : body. isStatic, isSleeping : body. isSleeping, parent : body. parent || body } ) ; Vertices. rotate ( body. vertices, body. angle, body. position ) ; Axes. rotate ( body. axes, body. angle ) ; Bounds. update ( body. bounds, body. vertices, body. velocity ) ; // allow options to override the automatically calculated properties Body. set ( body, { axes : options. axes || body. axes, area : options. area || body. area, mass : options. mass || body. mass, inertia : options. inertia || body. inertia } ) ; // render properties var defaultFillStyle = ( body. isStatic? '#2e2b44' : Common"
    ],
    "smoothed_bleu_4": 0.5366285598032902
  },
  {
    "doc_id": 86,
    "doc": {
      "id": 86,
      "repo": "react-dnd/react-dnd",
      "path": "packages/documentation/gatsby-node.js",
      "func_name": "createPages",
      "original_string": "async function createPages({ actions, graphql }) {\n\tconst retrieveMarkdownPages = () =>\n\t\tgraphql(`\n\t\t\t{\n\t\t\t\tallMarkdownRemark(limit: 1000) {\n\t\t\t\t\tedges {\n\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\tfrontmatter {\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`)\n\n\tconst exampleTemplate = path.resolve(`src/templates/exampleTemplate.tsx`)\n\tconst docTemplate = path.resolve(`src/templates/docTemplate.tsx`)\n\tconst result = await retrieveMarkdownPages()\n\n\tif (result.errors) {\n\t\tconsole.error('graphql error', result.errors)\n\t\tthrow new Error('Error invoking graphql for pages')\n\t}\n\n\tresult.data.allMarkdownRemark.edges.forEach(({ node }) => {\n\t\tconst {\n\t\t\tfrontmatter: { path: pagePath },\n\t\t} = node\n\t\tconst category = (pagePath || '/').split('/').filter(t => !!t)[0]\n\t\tconst isExample = category === 'examples'\n\t\tconsole.log(`create page for ${pagePath} - type is ${category}`)\n\t\tactions.createPage({\n\t\t\tpath: pagePath,\n\t\t\tcomponent: isExample ? exampleTemplate : docTemplate,\n\t\t\tcontext: {}, // additional data can be passed via context\n\t\t})\n\t})\n}",
      "language": "javascript",
      "code": "async function createPages({ actions, graphql }) {\n\tconst retrieveMarkdownPages = () =>\n\t\tgraphql(`\n\t\t\t{\n\t\t\t\tallMarkdownRemark(limit: 1000) {\n\t\t\t\t\tedges {\n\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\tfrontmatter {\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`)\n\n\tconst exampleTemplate = path.resolve(`src/templates/exampleTemplate.tsx`)\n\tconst docTemplate = path.resolve(`src/templates/docTemplate.tsx`)\n\tconst result = await retrieveMarkdownPages()\n\n\tif (result.errors) {\n\t\tconsole.error('graphql error', result.errors)\n\t\tthrow new Error('Error invoking graphql for pages')\n\t}\n\n\tresult.data.allMarkdownRemark.edges.forEach(({ node }) => {\n\t\tconst {\n\t\t\tfrontmatter: { path: pagePath },\n\t\t} = node\n\t\tconst category = (pagePath || '/').split('/').filter(t => !!t)[0]\n\t\tconst isExample = category === 'examples'\n\t\tconsole.log(`create page for ${pagePath} - type is ${category}`)\n\t\tactions.createPage({\n\t\t\tpath: pagePath,\n\t\t\tcomponent: isExample ? exampleTemplate : docTemplate,\n\t\t\tcontext: {}, // additional data can be passed via context\n\t\t})\n\t})\n}",
      "code_tokens": [
        "async",
        "function",
        "createPages",
        "(",
        "{",
        "actions",
        ",",
        "graphql",
        "}",
        ")",
        "{",
        "const",
        "retrieveMarkdownPages",
        "=",
        "(",
        ")",
        "=>",
        "graphql",
        "(",
        "`",
        "`",
        ")",
        "const",
        "exampleTemplate",
        "=",
        "path",
        ".",
        "resolve",
        "(",
        "`",
        "`",
        ")",
        "const",
        "docTemplate",
        "=",
        "path",
        ".",
        "resolve",
        "(",
        "`",
        "`",
        ")",
        "const",
        "result",
        "=",
        "await",
        "retrieveMarkdownPages",
        "(",
        ")",
        "if",
        "(",
        "result",
        ".",
        "errors",
        ")",
        "{",
        "console",
        ".",
        "error",
        "(",
        "'graphql error'",
        ",",
        "result",
        ".",
        "errors",
        ")",
        "throw",
        "new",
        "Error",
        "(",
        "'Error invoking graphql for pages'",
        ")",
        "}",
        "result",
        ".",
        "data",
        ".",
        "allMarkdownRemark",
        ".",
        "edges",
        ".",
        "forEach",
        "(",
        "(",
        "{",
        "node",
        "}",
        ")",
        "=>",
        "{",
        "const",
        "{",
        "frontmatter",
        ":",
        "{",
        "path",
        ":",
        "pagePath",
        "}",
        ",",
        "}",
        "=",
        "node",
        "const",
        "category",
        "=",
        "(",
        "pagePath",
        "||",
        "'/'",
        ")",
        ".",
        "split",
        "(",
        "'/'",
        ")",
        ".",
        "filter",
        "(",
        "t",
        "=>",
        "!",
        "!",
        "t",
        ")",
        "[",
        "0",
        "]",
        "const",
        "isExample",
        "=",
        "category",
        "===",
        "'examples'",
        "console",
        ".",
        "log",
        "(",
        "`",
        "${",
        "pagePath",
        "}",
        "${",
        "category",
        "}",
        "`",
        ")",
        "actions",
        ".",
        "createPage",
        "(",
        "{",
        "path",
        ":",
        "pagePath",
        ",",
        "component",
        ":",
        "isExample",
        "?",
        "exampleTemplate",
        ":",
        "docTemplate",
        ",",
        "context",
        ":",
        "{",
        "}",
        ",",
        "// additional data can be passed via context",
        "}",
        ")",
        "}",
        ")",
        "}"
      ],
      "docstring": "Dynamically creates pages in the static website",
      "docstring_tokens": [
        "Dynamically",
        "creates",
        "pages",
        "in",
        "the",
        "static",
        "website"
      ],
      "sha": "5fefffc8c6c1ceced3aa0356fd869354ad74734a",
      "url": "https://github.com/react-dnd/react-dnd/blob/5fefffc8c6c1ceced3aa0356fd869354ad74734a/packages/documentation/gatsby-node.js#L6-L44"
    },
    "target": "Dynamically creates pages in the static website",
    "arguments": [
      [
        "async function createPages ( { actions , graphql } ) { const retrieveMarkdownPages = ( ) => graphql ( ` ` ) const exampleTemplate = path . resolve ( ` ` ) const docTemplate = path . resolve ( ` ` ) const result = await retrieveMarkdownPages ( ) if ( result . errors ) { console . error ( 'graphql error' , result . errors ) throw new Error ( 'Error invoking graphql for pages' ) } result . data . allMarkdownRemark . edges . forEach ( ( { node } ) => { const { frontmatter : { path : pagePath } , } = node const category = ( pagePath || '/' ) . split ( '/' ) . filter ( t => ! ! t ) [ 0 ] const isExample = category === 'examples' console . log ( ` ${ pagePath } ${ category } ` ) actions . createPage ( { path : pagePath , component : isExample ? exampleTemplate : docTemplate , context : { } , // additional data can be passed via context } ) } ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " return { } } module. exports = createPages ```\n\nThis code defines a function called `createPages` that is used to create pages for a Gatsby site. It uses the `graphql` function to query the site's data and then loops through the results to create pages for each markdown file. The `actions.createPage` function is used to create a new page for each markdown file, and the `component` property is set to either the `exampleTemplate` or `docTemplate` depending on the category of the page.\n\nThe code uses the `path.resolve` function to resolve the paths to the template files, and the `graphql` function to query the site's data. It also uses the `forEach` method to loop through the results of the query and create a new page for each markdown file.\n\nThe `context` property is an object that can be used to pass additional data to the page component. In this case, it is an empty object, but it could be used to pass data such as the site's metadata or other relevant information.\n\nThe `return` statement at the end of the function is not necessary, as the function does not return any value. However, it is included to make the code more explicit"
      ]
    ],
    "filtered_resps": [
      " return { } } module. exports = createPages ```\n\nThis code defines a function called `createPages` that is used to create pages for a Gatsby site. It uses the `graphql` function to query the site's data and then loops through the results to create pages for each markdown file. The `actions.createPage` function is used to create a new page for each markdown file, and the `component` property is set to either the `exampleTemplate` or `docTemplate` depending on the category of the page.\n\nThe code uses the `path.resolve` function to resolve the paths to the template files, and the `graphql` function to query the site's data. It also uses the `forEach` method to loop through the results of the query and create a new page for each markdown file.\n\nThe `context` property is an object that can be used to pass additional data to the page component. In this case, it is an empty object, but it could be used to pass data such as the site's metadata or other relevant information.\n\nThe `return` statement at the end of the function is not necessary, as the function does not return any value. However, it is included to make the code more explicit"
    ],
    "smoothed_bleu_4": 0.5280165709288415
  },
  {
    "doc_id": 87,
    "doc": {
      "id": 87,
      "repo": "jsdom/jsdom",
      "path": "lib/jsdom/living/events/UIEvent-impl.js",
      "func_name": "isWindow",
      "original_string": "function isWindow(val) {\n  if (typeof val !== \"object\") {\n    return false;\n  }\n  const wrapper = idlUtils.wrapperForImpl(val);\n  if (typeof wrapper === \"object\") {\n    return wrapper === wrapper._globalProxy;\n  }\n\n  // `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global\n  // proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time,\n  // some internal usage call this constructor with the actual global proxy.\n  return isWindow(idlUtils.implForWrapper(val));\n}",
      "language": "javascript",
      "code": "function isWindow(val) {\n  if (typeof val !== \"object\") {\n    return false;\n  }\n  const wrapper = idlUtils.wrapperForImpl(val);\n  if (typeof wrapper === \"object\") {\n    return wrapper === wrapper._globalProxy;\n  }\n\n  // `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global\n  // proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time,\n  // some internal usage call this constructor with the actual global proxy.\n  return isWindow(idlUtils.implForWrapper(val));\n}",
      "code_tokens": [
        "function",
        "isWindow",
        "(",
        "val",
        ")",
        "{",
        "if",
        "(",
        "typeof",
        "val",
        "!==",
        "\"object\"",
        ")",
        "{",
        "return",
        "false",
        ";",
        "}",
        "const",
        "wrapper",
        "=",
        "idlUtils",
        ".",
        "wrapperForImpl",
        "(",
        "val",
        ")",
        ";",
        "if",
        "(",
        "typeof",
        "wrapper",
        "===",
        "\"object\"",
        ")",
        "{",
        "return",
        "wrapper",
        "===",
        "wrapper",
        ".",
        "_globalProxy",
        ";",
        "}",
        "// `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global",
        "// proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time,",
        "// some internal usage call this constructor with the actual global proxy.",
        "return",
        "isWindow",
        "(",
        "idlUtils",
        ".",
        "implForWrapper",
        "(",
        "val",
        ")",
        ")",
        ";",
        "}"
      ],
      "docstring": "Until webidl2js gains support for checking for Window, this would have to do.",
      "docstring_tokens": [
        "Until",
        "webidl2js",
        "gains",
        "support",
        "for",
        "checking",
        "for",
        "Window",
        "this",
        "would",
        "have",
        "to",
        "do",
        "."
      ],
      "sha": "43f2089142f57cddc3983e6429c34351699625f2",
      "url": "https://github.com/jsdom/jsdom/blob/43f2089142f57cddc3983e6429c34351699625f2/lib/jsdom/living/events/UIEvent-impl.js#L8-L21"
    },
    "target": "Until webidl2js gains support for checking for Window this would have to do .",
    "arguments": [
      [
        "function isWindow ( val ) { if ( typeof val !== \"object\" ) { return false ; } const wrapper = idlUtils . wrapperForImpl ( val ) ; if ( typeof wrapper === \"object\" ) { return wrapper === wrapper . _globalProxy ; } // `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global // proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time, // some internal usage call this constructor with the actual global proxy. return isWindow ( idlUtils . implForWrapper ( val ) ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function isDocument ( val ) { if ( typeof val!== \"object\" ) { return false ; } const wrapper = idlUtils. wrapperForImpl ( val ) ; if ( typeof wrapper === \"object\" ) { return wrapper === wrapper. _globalProxy ; } // `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global // proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time, // some internal usage call this constructor with the actual global proxy. return isDocument ( idlUtils. implForWrapper ( val ) ) ; } function isElement ( val ) { if ( typeof val!== \"object\" ) { return false ; } const wrapper = idlUtils. wrapperForImpl ( val ) ; if ( typeof wrapper === \"object\" ) { return wrapper === wrapper. _globalProxy ; } // `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global // proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time, // some internal usage call this"
      ]
    ],
    "filtered_resps": [
      " function isDocument ( val ) { if ( typeof val!== \"object\" ) { return false ; } const wrapper = idlUtils. wrapperForImpl ( val ) ; if ( typeof wrapper === \"object\" ) { return wrapper === wrapper. _globalProxy ; } // `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global // proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time, // some internal usage call this constructor with the actual global proxy. return isDocument ( idlUtils. implForWrapper ( val ) ) ; } function isElement ( val ) { if ( typeof val!== \"object\" ) { return false ; } const wrapper = idlUtils. wrapperForImpl ( val ) ; if ( typeof wrapper === \"object\" ) { return wrapper === wrapper. _globalProxy ; } // `val` may be either impl or wrapper currently, because webidl2js currently unwraps Window objects (and their global // proxies) to their underlying EventTargetImpl during conversion, which is not what we want. But at the same time, // some internal usage call this"
    ],
    "smoothed_bleu_4": 0.6329557678691783
  },
  {
    "doc_id": 88,
    "doc": {
      "id": 88,
      "repo": "jsdom/jsdom",
      "path": "lib/jsdom/living/events/EventTarget-impl.js",
      "func_name": "normalizeEventHandlerOptions",
      "original_string": "function normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}",
      "language": "javascript",
      "code": "function normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}",
      "code_tokens": [
        "function",
        "normalizeEventHandlerOptions",
        "(",
        "options",
        ",",
        "defaultBoolKeys",
        ")",
        "{",
        "const",
        "returnValue",
        "=",
        "{",
        "}",
        ";",
        "// no need to go further here",
        "if",
        "(",
        "typeof",
        "options",
        "===",
        "\"boolean\"",
        "||",
        "options",
        "===",
        "null",
        "||",
        "typeof",
        "options",
        "===",
        "\"undefined\"",
        ")",
        "{",
        "returnValue",
        ".",
        "capture",
        "=",
        "Boolean",
        "(",
        "options",
        ")",
        ";",
        "return",
        "returnValue",
        ";",
        "}",
        "// non objects options so we typecast its value as \"capture\" value",
        "if",
        "(",
        "typeof",
        "options",
        "!==",
        "\"object\"",
        ")",
        "{",
        "returnValue",
        ".",
        "capture",
        "=",
        "Boolean",
        "(",
        "options",
        ")",
        ";",
        "// at this point we don't need to loop the \"capture\" key anymore",
        "defaultBoolKeys",
        "=",
        "defaultBoolKeys",
        ".",
        "filter",
        "(",
        "k",
        "=>",
        "k",
        "!==",
        "\"capture\"",
        ")",
        ";",
        "}",
        "for",
        "(",
        "const",
        "key",
        "of",
        "defaultBoolKeys",
        ")",
        "{",
        "returnValue",
        "[",
        "key",
        "]",
        "=",
        "Boolean",
        "(",
        "options",
        "[",
        "key",
        "]",
        ")",
        ";",
        "}",
        "return",
        "returnValue",
        ";",
        "}"
      ],
      "docstring": "Normalize the event listeners options argument in order to get always a valid options object\n@param   {Object} options         - user defined options\n@param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n@returns {Object} object containing at least the \"defaultBoolKeys\"",
      "docstring_tokens": [
        "Normalize",
        "the",
        "event",
        "listeners",
        "options",
        "argument",
        "in",
        "order",
        "to",
        "get",
        "always",
        "a",
        "valid",
        "options",
        "object"
      ],
      "sha": "43f2089142f57cddc3983e6429c34351699625f2",
      "url": "https://github.com/jsdom/jsdom/blob/43f2089142f57cddc3983e6429c34351699625f2/lib/jsdom/living/events/EventTarget-impl.js#L352-L373"
    },
    "target": "Normalize the event listeners options argument in order to get always a valid options object",
    "arguments": [
      [
        "function normalizeEventHandlerOptions ( options , defaultBoolKeys ) { const returnValue = { } ; // no need to go further here if ( typeof options === \"boolean\" || options === null || typeof options === \"undefined\" ) { returnValue . capture = Boolean ( options ) ; return returnValue ; } // non objects options so we typecast its value as \"capture\" value if ( typeof options !== \"object\" ) { returnValue . capture = Boolean ( options ) ; // at this point we don't need to loop the \"capture\" key anymore defaultBoolKeys = defaultBoolKeys . filter ( k => k !== \"capture\" ) ; } for ( const key of defaultBoolKeys ) { returnValue [ key ] = Boolean ( options [ key ] ) ; } return returnValue ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export { normalizeEventHandlerOptions } ; ```\n  2. In the normalizeEventHandlerOptions function, we first check if the options parameter is a boolean, null, or undefined. If it is, we set the capture property of the returnValue object to the value of the options parameter and return the returnValue object.\n  3. If the options parameter is not a boolean, null, or undefined, we check if it's not an object. If it's not an object, we set the capture property of the returnValue object to the value of the options parameter and filter out the \"capture\" key from the defaultBoolKeys array.\n  4. We then loop through the remaining keys in the defaultBoolKeys array and set the corresponding properties in the returnValue object to the value of the options parameter.\n  5. Finally, we return the returnValue object.\n\nThe normalizeEventHandlerOptions function takes two parameters: options and defaultBoolKeys. The options parameter is the event handler options object that needs to be normalized, and the defaultBoolKeys parameter is an array of default boolean keys that should be included in the normalized options object.\n\nThe function returns an object with the normalized event handler options, where the capture property is set to the value of the options parameter"
      ]
    ],
    "filtered_resps": [
      " export { normalizeEventHandlerOptions } ; ```\n  2. In the normalizeEventHandlerOptions function, we first check if the options parameter is a boolean, null, or undefined. If it is, we set the capture property of the returnValue object to the value of the options parameter and return the returnValue object.\n  3. If the options parameter is not a boolean, null, or undefined, we check if it's not an object. If it's not an object, we set the capture property of the returnValue object to the value of the options parameter and filter out the \"capture\" key from the defaultBoolKeys array.\n  4. We then loop through the remaining keys in the defaultBoolKeys array and set the corresponding properties in the returnValue object to the value of the options parameter.\n  5. Finally, we return the returnValue object.\n\nThe normalizeEventHandlerOptions function takes two parameters: options and defaultBoolKeys. The options parameter is the event handler options object that needs to be normalized, and the defaultBoolKeys parameter is an array of default boolean keys that should be included in the normalized options object.\n\nThe function returns an object with the normalized event handler options, where the capture property is set to the value of the options parameter"
    ],
    "smoothed_bleu_4": 0.9571364687515707
  },
  {
    "doc_id": 89,
    "doc": {
      "id": 89,
      "repo": "avwo/whistle",
      "path": "docs/script/docify.js",
      "func_name": "sammary",
      "original_string": "function sammary() {\n  const nodeFn = function ({ parentPaths, lang, item, isDir, result }) {\n    const navTitle = generateNavTitle({ parentPaths, item, sign: isDir ? '-' : '*', lang });\n    result.push(navTitle);\n  };\n\n  langs.forEach(dir => {\n    const SUMMARY = 'SUMMARY.md';\n    const targetFile = path.join(docsDir, `${dir}/${SUMMARY}`);\n\n    const result = walk({\n      catalog: docConfig.catalog,\n      lang: dir,\n      result: [],\n      parentPaths: [],\n      fn: nodeFn\n    });\n\n    if (result && result.length) {\n      result.unshift('# whistle\\n');\n      fs.writeFileSync(targetFile, result.join('\\n'));\n    }\n  });\n}",
      "language": "javascript",
      "code": "function sammary() {\n  const nodeFn = function ({ parentPaths, lang, item, isDir, result }) {\n    const navTitle = generateNavTitle({ parentPaths, item, sign: isDir ? '-' : '*', lang });\n    result.push(navTitle);\n  };\n\n  langs.forEach(dir => {\n    const SUMMARY = 'SUMMARY.md';\n    const targetFile = path.join(docsDir, `${dir}/${SUMMARY}`);\n\n    const result = walk({\n      catalog: docConfig.catalog,\n      lang: dir,\n      result: [],\n      parentPaths: [],\n      fn: nodeFn\n    });\n\n    if (result && result.length) {\n      result.unshift('# whistle\\n');\n      fs.writeFileSync(targetFile, result.join('\\n'));\n    }\n  });\n}",
      "code_tokens": [
        "function",
        "sammary",
        "(",
        ")",
        "{",
        "const",
        "nodeFn",
        "=",
        "function",
        "(",
        "{",
        "parentPaths",
        ",",
        "lang",
        ",",
        "item",
        ",",
        "isDir",
        ",",
        "result",
        "}",
        ")",
        "{",
        "const",
        "navTitle",
        "=",
        "generateNavTitle",
        "(",
        "{",
        "parentPaths",
        ",",
        "item",
        ",",
        "sign",
        ":",
        "isDir",
        "?",
        "'-'",
        ":",
        "'*'",
        ",",
        "lang",
        "}",
        ")",
        ";",
        "result",
        ".",
        "push",
        "(",
        "navTitle",
        ")",
        ";",
        "}",
        ";",
        "langs",
        ".",
        "forEach",
        "(",
        "dir",
        "=>",
        "{",
        "const",
        "SUMMARY",
        "=",
        "'SUMMARY.md'",
        ";",
        "const",
        "targetFile",
        "=",
        "path",
        ".",
        "join",
        "(",
        "docsDir",
        ",",
        "`",
        "${",
        "dir",
        "}",
        "${",
        "SUMMARY",
        "}",
        "`",
        ")",
        ";",
        "const",
        "result",
        "=",
        "walk",
        "(",
        "{",
        "catalog",
        ":",
        "docConfig",
        ".",
        "catalog",
        ",",
        "lang",
        ":",
        "dir",
        ",",
        "result",
        ":",
        "[",
        "]",
        ",",
        "parentPaths",
        ":",
        "[",
        "]",
        ",",
        "fn",
        ":",
        "nodeFn",
        "}",
        ")",
        ";",
        "if",
        "(",
        "result",
        "&&",
        "result",
        ".",
        "length",
        ")",
        "{",
        "result",
        ".",
        "unshift",
        "(",
        "'# whistle\\n'",
        ")",
        ";",
        "fs",
        ".",
        "writeFileSync",
        "(",
        "targetFile",
        ",",
        "result",
        ".",
        "join",
        "(",
        "'\\n'",
        ")",
        ")",
        ";",
        "}",
        "}",
        ")",
        ";",
        "}"
      ],
      "docstring": "generate `SUMMARY.md` by `config.json`",
      "docstring_tokens": [
        "generate",
        "SUMMARY",
        ".",
        "md",
        "by",
        "config",
        ".",
        "json"
      ],
      "sha": "b419da1d6185a006327f2ce267667f11c0d4109e",
      "url": "https://github.com/avwo/whistle/blob/b419da1d6185a006327f2ce267667f11c0d4109e/docs/script/docify.js#L136-L159"
    },
    "target": "generate SUMMARY . md by config . json",
    "arguments": [
      [
        "function sammary ( ) { const nodeFn = function ( { parentPaths , lang , item , isDir , result } ) { const navTitle = generateNavTitle ( { parentPaths , item , sign : isDir ? '-' : '*' , lang } ) ; result . push ( navTitle ) ; } ; langs . forEach ( dir => { const SUMMARY = 'SUMMARY.md' ; const targetFile = path . join ( docsDir , ` ${ dir } ${ SUMMARY } ` ) ; const result = walk ( { catalog : docConfig . catalog , lang : dir , result : [ ] , parentPaths : [ ] , fn : nodeFn } ) ; if ( result && result . length ) { result . unshift ( '# whistle\\n' ) ; fs . writeFileSync ( targetFile , result . join ( '\\n' ) ) ; } } ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ; exports. sammary = sammary ; ```\n\nThis code defines a function `sammary` that takes no arguments. It uses the `langs` array to iterate over each language directory in the `docsDir`. For each language directory, it generates a `SUMMARY.md` file by walking the catalog using the `walk` function and the `nodeFn` function. The `nodeFn` function generates a navigation title for each item in the catalog and adds it to the `result` array. The `result` array is then written to the `SUMMARY.md` file.\n\nThe `walk` function is not defined in this code snippet, but it is assumed to be a function that walks the catalog and calls the `nodeFn` function for each item. The `generateNavTitle` function is also not defined, but it is assumed to generate a navigation title for each item based on the `parentPaths`, `item`, `sign`, and `lang` arguments.\n\nThe `fs.writeFileSync` function is used to write the `result` array to the `SUMMARY.md` file. The `unshift` method is used to add a `# whistle\\n` line to the beginning of the `result` array before"
      ]
    ],
    "filtered_resps": [
      " ; exports. sammary = sammary ; ```\n\nThis code defines a function `sammary` that takes no arguments. It uses the `langs` array to iterate over each language directory in the `docsDir`. For each language directory, it generates a `SUMMARY.md` file by walking the catalog using the `walk` function and the `nodeFn` function. The `nodeFn` function generates a navigation title for each item in the catalog and adds it to the `result` array. The `result` array is then written to the `SUMMARY.md` file.\n\nThe `walk` function is not defined in this code snippet, but it is assumed to be a function that walks the catalog and calls the `nodeFn` function for each item. The `generateNavTitle` function is also not defined, but it is assumed to generate a navigation title for each item based on the `parentPaths`, `item`, `sign`, and `lang` arguments.\n\nThe `fs.writeFileSync` function is used to write the `result` array to the `SUMMARY.md` file. The `unshift` method is used to add a `# whistle\\n` line to the beginning of the `result` array before"
    ],
    "smoothed_bleu_4": 0.9987782905718074
  },
  {
    "doc_id": 90,
    "doc": {
      "id": 90,
      "repo": "avwo/whistle",
      "path": "biz/webui/htdocs/src/js/components/react-json-tree/JSONIterableNode.js",
      "func_name": "createItemString",
      "original_string": "function createItemString(data, limit) {\n  var count = 0;\n  var hasMore = false;\n  if ((0, _isSafeInteger2['default'])(data.size)) {\n    count = data.size;\n  } else {\n    for (var _iterator = data, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3['default'])(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var entry = _ref;\n      // eslint-disable-line no-unused-vars\n      if (limit && count + 1 > limit) {\n        hasMore = true;\n        break;\n      }\n      count += 1;\n    }\n  }\n  return '' + (hasMore ? '>' : '') + count + ' ' + (count !== 1 ? 'entries' : 'entry');\n}",
      "language": "javascript",
      "code": "function createItemString(data, limit) {\n  var count = 0;\n  var hasMore = false;\n  if ((0, _isSafeInteger2['default'])(data.size)) {\n    count = data.size;\n  } else {\n    for (var _iterator = data, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3['default'])(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var entry = _ref;\n      // eslint-disable-line no-unused-vars\n      if (limit && count + 1 > limit) {\n        hasMore = true;\n        break;\n      }\n      count += 1;\n    }\n  }\n  return '' + (hasMore ? '>' : '') + count + ' ' + (count !== 1 ? 'entries' : 'entry');\n}",
      "code_tokens": [
        "function",
        "createItemString",
        "(",
        "data",
        ",",
        "limit",
        ")",
        "{",
        "var",
        "count",
        "=",
        "0",
        ";",
        "var",
        "hasMore",
        "=",
        "false",
        ";",
        "if",
        "(",
        "(",
        "0",
        ",",
        "_isSafeInteger2",
        "[",
        "'default'",
        "]",
        ")",
        "(",
        "data",
        ".",
        "size",
        ")",
        ")",
        "{",
        "count",
        "=",
        "data",
        ".",
        "size",
        ";",
        "}",
        "else",
        "{",
        "for",
        "(",
        "var",
        "_iterator",
        "=",
        "data",
        ",",
        "_isArray",
        "=",
        "Array",
        ".",
        "isArray",
        "(",
        "_iterator",
        ")",
        ",",
        "_i",
        "=",
        "0",
        ",",
        "_iterator",
        "=",
        "_isArray",
        "?",
        "_iterator",
        ":",
        "(",
        "0",
        ",",
        "_getIterator3",
        "[",
        "'default'",
        "]",
        ")",
        "(",
        "_iterator",
        ")",
        ";",
        ";",
        ")",
        "{",
        "var",
        "_ref",
        ";",
        "if",
        "(",
        "_isArray",
        ")",
        "{",
        "if",
        "(",
        "_i",
        ">=",
        "_iterator",
        ".",
        "length",
        ")",
        "break",
        ";",
        "_ref",
        "=",
        "_iterator",
        "[",
        "_i",
        "++",
        "]",
        ";",
        "}",
        "else",
        "{",
        "_i",
        "=",
        "_iterator",
        ".",
        "next",
        "(",
        ")",
        ";",
        "if",
        "(",
        "_i",
        ".",
        "done",
        ")",
        "break",
        ";",
        "_ref",
        "=",
        "_i",
        ".",
        "value",
        ";",
        "}",
        "var",
        "entry",
        "=",
        "_ref",
        ";",
        "// eslint-disable-line no-unused-vars",
        "if",
        "(",
        "limit",
        "&&",
        "count",
        "+",
        "1",
        ">",
        "limit",
        ")",
        "{",
        "hasMore",
        "=",
        "true",
        ";",
        "break",
        ";",
        "}",
        "count",
        "+=",
        "1",
        ";",
        "}",
        "}",
        "return",
        "''",
        "+",
        "(",
        "hasMore",
        "?",
        "'>'",
        ":",
        "''",
        ")",
        "+",
        "count",
        "+",
        "' '",
        "+",
        "(",
        "count",
        "!==",
        "1",
        "?",
        "'entries'",
        ":",
        "'entry'",
        ")",
        ";",
        "}"
      ],
      "docstring": "Returns the \"n Items\" string for this node, generating and caching it if it hasn't been created yet.",
      "docstring_tokens": [
        "Returns",
        "the",
        "n",
        "Items",
        "string",
        "for",
        "this",
        "node",
        "generating",
        "and",
        "caching",
        "it",
        "if",
        "it",
        "hasn",
        "t",
        "been",
        "created",
        "yet",
        "."
      ],
      "sha": "b419da1d6185a006327f2ce267667f11c0d4109e",
      "url": "https://github.com/avwo/whistle/blob/b419da1d6185a006327f2ce267667f11c0d4109e/biz/webui/htdocs/src/js/components/react-json-tree/JSONIterableNode.js#L35-L63"
    },
    "target": "Returns the n Items string for this node generating and caching it if it hasn t been created yet .",
    "arguments": [
      [
        "function createItemString ( data , limit ) { var count = 0 ; var hasMore = false ; if ( ( 0 , _isSafeInteger2 [ 'default' ] ) ( data . size ) ) { count = data . size ; } else { for ( var _iterator = data , _isArray = Array . isArray ( _iterator ) , _i = 0 , _iterator = _isArray ? _iterator : ( 0 , _getIterator3 [ 'default' ] ) ( _iterator ) ; ; ) { var _ref ; if ( _isArray ) { if ( _i >= _iterator . length ) break ; _ref = _iterator [ _i ++ ] ; } else { _i = _iterator . next ( ) ; if ( _i . done ) break ; _ref = _i . value ; } var entry = _ref ; // eslint-disable-line no-unused-vars if ( limit && count + 1 > limit ) { hasMore = true ; break ; } count += 1 ; } } return '' + ( hasMore ? '>' : '' ) + count + ' ' + ( count !== 1 ? 'entries' : 'entry' ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " exports. createItemString = createItemString ; } }, { './isSafeInteger' : 1, './getIterator' : 2 }, [ 1, 2 ] ]); });\n\n[FILEPATH] node_modules/@babel/runtime/helpers/esm/defineProperty.js [/FILEPATH]\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _default = _defineProperty;\nexports.default = _default;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/objectSpread.js\":\n/*!******************************************************************!*\\\n !***./node_modules/@babel/runtime/helpers/esm/objectSpread.js ***!\n  \\******************************************************************/\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export [ \"default\" ] */ __webpack_require__.d(__webpack"
      ]
    ],
    "filtered_resps": [
      " exports. createItemString = createItemString ; } }, { './isSafeInteger' : 1, './getIterator' : 2 }, [ 1, 2 ] ]); });\n\n[FILEPATH] node_modules/@babel/runtime/helpers/esm/defineProperty.js [/FILEPATH]\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _default = _defineProperty;\nexports.default = _default;\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/objectSpread.js\":\n/*!******************************************************************!*\\\n !***./node_modules/@babel/runtime/helpers/esm/objectSpread.js ***!\n  \\******************************************************************/\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export [ \"default\" ] */ __webpack_require__.d(__webpack"
    ],
    "smoothed_bleu_4": 0.2949190557155801
  },
  {
    "doc_id": 91,
    "doc": {
      "id": 91,
      "repo": "acornjs/acorn",
      "path": "acorn/src/tokentype.js",
      "func_name": "kw",
      "original_string": "function kw(name, options = {}) {\n  options.keyword = name\n  return keywords[name] = new TokenType(name, options)\n}",
      "language": "javascript",
      "code": "function kw(name, options = {}) {\n  options.keyword = name\n  return keywords[name] = new TokenType(name, options)\n}",
      "code_tokens": [
        "function",
        "kw",
        "(",
        "name",
        ",",
        "options",
        "=",
        "{",
        "}",
        ")",
        "{",
        "options",
        ".",
        "keyword",
        "=",
        "name",
        "return",
        "keywords",
        "[",
        "name",
        "]",
        "=",
        "new",
        "TokenType",
        "(",
        "name",
        ",",
        "options",
        ")",
        "}"
      ],
      "docstring": "Succinct definitions of keyword token types",
      "docstring_tokens": [
        "Succinct",
        "definitions",
        "of",
        "keyword",
        "token",
        "types"
      ],
      "sha": "073a12c8285353866dfd74de5d88c543bd3ae20d",
      "url": "https://github.com/acornjs/acorn/blob/073a12c8285353866dfd74de5d88c543bd3ae20d/acorn/src/tokentype.js#L49-L52"
    },
    "target": "Succinct definitions of keyword token types",
    "arguments": [
      [
        "function kw ( name , options = { } ) { options . keyword = name return keywords [ name ] = new TokenType ( name , options ) }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options"
      ]
    ],
    "filtered_resps": [
      " function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } + function kw ( name, options = { } ) { options. keyword = name return keywords [ name ] = new TokenType ( name, options ) } function kw ( name, options"
    ],
    "smoothed_bleu_4": 0.4012058332071188
  },
  {
    "doc_id": 92,
    "doc": {
      "id": 92,
      "repo": "acornjs/acorn",
      "path": "acorn/src/identifier.js",
      "func_name": "isInAstralSet",
      "original_string": "function isInAstralSet(code, set) {\n  let pos = 0x10000\n  for (let i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}",
      "language": "javascript",
      "code": "function isInAstralSet(code, set) {\n  let pos = 0x10000\n  for (let i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}",
      "code_tokens": [
        "function",
        "isInAstralSet",
        "(",
        "code",
        ",",
        "set",
        ")",
        "{",
        "let",
        "pos",
        "=",
        "0x10000",
        "for",
        "(",
        "let",
        "i",
        "=",
        "0",
        ";",
        "i",
        "<",
        "set",
        ".",
        "length",
        ";",
        "i",
        "+=",
        "2",
        ")",
        "{",
        "pos",
        "+=",
        "set",
        "[",
        "i",
        "]",
        "if",
        "(",
        "pos",
        ">",
        "code",
        ")",
        "return",
        "false",
        "pos",
        "+=",
        "set",
        "[",
        "i",
        "+",
        "1",
        "]",
        "if",
        "(",
        "pos",
        ">=",
        "code",
        ")",
        "return",
        "true",
        "}",
        "}"
      ],
      "docstring": "This has a complexity linear to the value of the code. The assumption is that looking up astral identifier characters is rare.",
      "docstring_tokens": [
        "This",
        "has",
        "a",
        "complexity",
        "linear",
        "to",
        "the",
        "value",
        "of",
        "the",
        "code",
        ".",
        "The",
        "assumption",
        "is",
        "that",
        "looking",
        "up",
        "astral",
        "identifier",
        "characters",
        "is",
        "rare",
        "."
      ],
      "sha": "073a12c8285353866dfd74de5d88c543bd3ae20d",
      "url": "https://github.com/acornjs/acorn/blob/073a12c8285353866dfd74de5d88c543bd3ae20d/acorn/src/identifier.js#L53-L61"
    },
    "target": "This has a complexity linear to the value of the code . The assumption is that looking up astral identifier characters is rare .",
    "arguments": [
      [
        "function isInAstralSet ( code , set ) { let pos = 0x10000 for ( let i = 0 ; i < set . length ; i += 2 ) { pos += set [ i ] if ( pos > code ) return false pos += set [ i + 1 ] if ( pos >= code ) return true } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function getAstralSet ( code ) { let set = [] let pos = 0x10000 for ( let i = 0 ; i < code. length ; i += 2 ) { set. push ( code [ i ] ) pos += code [ i ] set. push ( code [ i + 1 ] ) pos += code [ i + 1 ] if ( pos >= 0x10000 ) break } return set } function astralToCode ( astral ) { let code = [] let pos = 0x10000 for ( let i = 0 ; i < astral. length ; i += 2 ) { code. push ( astral [ i ] ) pos += astral [ i ] code. push ( astral [ i + 1 ] ) pos += astral [ i + 1 ] if ( pos >= 0x10000 ) break } return code } function codeToAstral ( code ) { let astral = [] let pos = 0x10000 for ( let i = 0 ; i < code. length ; i += 2 ) { astral. push ( code [ i ] ) pos += code [ i ] astral"
      ]
    ],
    "filtered_resps": [
      " function getAstralSet ( code ) { let set = [] let pos = 0x10000 for ( let i = 0 ; i < code. length ; i += 2 ) { set. push ( code [ i ] ) pos += code [ i ] set. push ( code [ i + 1 ] ) pos += code [ i + 1 ] if ( pos >= 0x10000 ) break } return set } function astralToCode ( astral ) { let code = [] let pos = 0x10000 for ( let i = 0 ; i < astral. length ; i += 2 ) { code. push ( astral [ i ] ) pos += astral [ i ] code. push ( astral [ i + 1 ] ) pos += astral [ i + 1 ] if ( pos >= 0x10000 ) break } return code } function codeToAstral ( code ) { let astral = [] let pos = 0x10000 for ( let i = 0 ; i < code. length ; i += 2 ) { astral. push ( code [ i ] ) pos += code [ i ] astral"
    ],
    "smoothed_bleu_4": 0.7849733680402551
  },
  {
    "doc_id": 93,
    "doc": {
      "id": 93,
      "repo": "carbon-design-system/carbon-components",
      "path": "packages/themes/tasks/build.js",
      "func_name": "transformMetadata",
      "original_string": "function transformMetadata(metadata) {\n  const namesRegEx = new RegExp(\n    metadata.tokens.map(token => token.name).join('|'),\n    'g'\n  );\n\n  const replaceMap = {};\n  metadata.tokens.map(token => {\n    replaceMap[token.name] = formatTokenName(token.name);\n  });\n\n  metadata.tokens.forEach((token, i) => {\n    // interactive01 to `$interactive-01`\n    if (token.role) {\n      token.role.forEach((role, j) => {\n        metadata.tokens[i].role[j] = role.replace(namesRegEx, match => {\n          return '`$' + replaceMap[match] + '`';\n        });\n      });\n    }\n\n    // brand01 to brand-01\n    if (token.alias) {\n      token.alias = formatTokenName(token.alias);\n    }\n  });\n\n  return metadata;\n}",
      "language": "javascript",
      "code": "function transformMetadata(metadata) {\n  const namesRegEx = new RegExp(\n    metadata.tokens.map(token => token.name).join('|'),\n    'g'\n  );\n\n  const replaceMap = {};\n  metadata.tokens.map(token => {\n    replaceMap[token.name] = formatTokenName(token.name);\n  });\n\n  metadata.tokens.forEach((token, i) => {\n    // interactive01 to `$interactive-01`\n    if (token.role) {\n      token.role.forEach((role, j) => {\n        metadata.tokens[i].role[j] = role.replace(namesRegEx, match => {\n          return '`$' + replaceMap[match] + '`';\n        });\n      });\n    }\n\n    // brand01 to brand-01\n    if (token.alias) {\n      token.alias = formatTokenName(token.alias);\n    }\n  });\n\n  return metadata;\n}",
      "code_tokens": [
        "function",
        "transformMetadata",
        "(",
        "metadata",
        ")",
        "{",
        "const",
        "namesRegEx",
        "=",
        "new",
        "RegExp",
        "(",
        "metadata",
        ".",
        "tokens",
        ".",
        "map",
        "(",
        "token",
        "=>",
        "token",
        ".",
        "name",
        ")",
        ".",
        "join",
        "(",
        "'|'",
        ")",
        ",",
        "'g'",
        ")",
        ";",
        "const",
        "replaceMap",
        "=",
        "{",
        "}",
        ";",
        "metadata",
        ".",
        "tokens",
        ".",
        "map",
        "(",
        "token",
        "=>",
        "{",
        "replaceMap",
        "[",
        "token",
        ".",
        "name",
        "]",
        "=",
        "formatTokenName",
        "(",
        "token",
        ".",
        "name",
        ")",
        ";",
        "}",
        ")",
        ";",
        "metadata",
        ".",
        "tokens",
        ".",
        "forEach",
        "(",
        "(",
        "token",
        ",",
        "i",
        ")",
        "=>",
        "{",
        "// interactive01 to `$interactive-01`",
        "if",
        "(",
        "token",
        ".",
        "role",
        ")",
        "{",
        "token",
        ".",
        "role",
        ".",
        "forEach",
        "(",
        "(",
        "role",
        ",",
        "j",
        ")",
        "=>",
        "{",
        "metadata",
        ".",
        "tokens",
        "[",
        "i",
        "]",
        ".",
        "role",
        "[",
        "j",
        "]",
        "=",
        "role",
        ".",
        "replace",
        "(",
        "namesRegEx",
        ",",
        "match",
        "=>",
        "{",
        "return",
        "'`$'",
        "+",
        "replaceMap",
        "[",
        "match",
        "]",
        "+",
        "'`'",
        ";",
        "}",
        ")",
        ";",
        "}",
        ")",
        ";",
        "}",
        "// brand01 to brand-01",
        "if",
        "(",
        "token",
        ".",
        "alias",
        ")",
        "{",
        "token",
        ".",
        "alias",
        "=",
        "formatTokenName",
        "(",
        "token",
        ".",
        "alias",
        ")",
        ";",
        "}",
        "}",
        ")",
        ";",
        "return",
        "metadata",
        ";",
        "}"
      ],
      "docstring": "Transform token names to formats expected by Sassdoc for descriptions and\naliases\n@param {Object} - token metadata\n@return {Object} token metadata",
      "docstring_tokens": [
        "Transform",
        "token",
        "names",
        "to",
        "formats",
        "expected",
        "by",
        "Sassdoc",
        "for",
        "descriptions",
        "and",
        "aliases"
      ],
      "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302",
      "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/themes/tasks/build.js#L203-L231"
    },
    "target": "Transform token names to formats expected by Sassdoc for descriptions and aliases",
    "arguments": [
      [
        "function transformMetadata ( metadata ) { const namesRegEx = new RegExp ( metadata . tokens . map ( token => token . name ) . join ( '|' ) , 'g' ) ; const replaceMap = { } ; metadata . tokens . map ( token => { replaceMap [ token . name ] = formatTokenName ( token . name ) ; } ) ; metadata . tokens . forEach ( ( token , i ) => { // interactive01 to `$interactive-01` if ( token . role ) { token . role . forEach ( ( role , j ) => { metadata . tokens [ i ] . role [ j ] = role . replace ( namesRegEx , match => { return '`$' + replaceMap [ match ] + '`' ; } ) ; } ) ; } // brand01 to brand-01 if ( token . alias ) { token . alias = formatTokenName ( token . alias ) ; } } ) ; return metadata ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function formatTokenName ( name ) { const match = name. match ( / ( \\d + ) $ / ) ; if ( match ) { return name. replace ( match [ 0 ], ` ${ match [ 1 ] } ` ) ; } else { return name ; } } module. exports = { transformMetadata } ; ```\nThis code defines a function `transformMetadata` that takes a metadata object as input and returns the transformed metadata object. The function uses regular expressions to replace token names with formatted names, and it also formats token aliases. The `formatTokenName` function is used to format token names by replacing numeric suffixes with hyphens.\n\nYou can use this code in your project by requiring the module and calling the `transformMetadata` function with your metadata object as an argument. For example:\n```javascript\nconst transformMetadata = require ( './transform-metadata' ) ;\nconst metadata = { /* your metadata object */ } ;\nconst transformedMetadata = transformMetadata ( metadata ) ;\nconsole. log ( transformedMetadata ) ;\n```\nNote that this code assumes that the metadata object has a `tokens` property that contains an array of token objects, each with `name`, `role`, and `alias` properties."
      ]
    ],
    "filtered_resps": [
      " function formatTokenName ( name ) { const match = name. match ( / ( \\d + ) $ / ) ; if ( match ) { return name. replace ( match [ 0 ], ` ${ match [ 1 ] } ` ) ; } else { return name ; } } module. exports = { transformMetadata } ; ```\nThis code defines a function `transformMetadata` that takes a metadata object as input and returns the transformed metadata object. The function uses regular expressions to replace token names with formatted names, and it also formats token aliases. The `formatTokenName` function is used to format token names by replacing numeric suffixes with hyphens.\n\nYou can use this code in your project by requiring the module and calling the `transformMetadata` function with your metadata object as an argument. For example:\n```javascript\nconst transformMetadata = require ( './transform-metadata' ) ;\nconst metadata = { /* your metadata object */ } ;\nconst transformedMetadata = transformMetadata ( metadata ) ;\nconsole. log ( transformedMetadata ) ;\n```\nNote that this code assumes that the metadata object has a `tokens` property that contains an array of token objects, each with `name`, `role`, and `alias` properties."
    ],
    "smoothed_bleu_4": 0.8398690841750653
  },
  {
    "doc_id": 94,
    "doc": {
      "id": 94,
      "repo": "carbon-design-system/carbon-components",
      "path": "packages/bundler/src/commands/measure.js",
      "func_name": "findPackageFor",
      "original_string": "async function findPackageFor(filepath) {\n  let directory = filepath;\n\n  while (directory !== '/') {\n    const directoryToSearch = path.dirname(directory);\n    const files = await fs.readdir(directoryToSearch);\n\n    if (files.indexOf('package.json') !== -1) {\n      const packageJson = await fs.readJson(\n        path.join(directoryToSearch, 'package.json')\n      );\n      return packageJson.name;\n    }\n\n    directory = path.resolve(directory, '..');\n  }\n\n  throw new Error(`Unable to find package for: ${filepath}`);\n}",
      "language": "javascript",
      "code": "async function findPackageFor(filepath) {\n  let directory = filepath;\n\n  while (directory !== '/') {\n    const directoryToSearch = path.dirname(directory);\n    const files = await fs.readdir(directoryToSearch);\n\n    if (files.indexOf('package.json') !== -1) {\n      const packageJson = await fs.readJson(\n        path.join(directoryToSearch, 'package.json')\n      );\n      return packageJson.name;\n    }\n\n    directory = path.resolve(directory, '..');\n  }\n\n  throw new Error(`Unable to find package for: ${filepath}`);\n}",
      "code_tokens": [
        "async",
        "function",
        "findPackageFor",
        "(",
        "filepath",
        ")",
        "{",
        "let",
        "directory",
        "=",
        "filepath",
        ";",
        "while",
        "(",
        "directory",
        "!==",
        "'/'",
        ")",
        "{",
        "const",
        "directoryToSearch",
        "=",
        "path",
        ".",
        "dirname",
        "(",
        "directory",
        ")",
        ";",
        "const",
        "files",
        "=",
        "await",
        "fs",
        ".",
        "readdir",
        "(",
        "directoryToSearch",
        ")",
        ";",
        "if",
        "(",
        "files",
        ".",
        "indexOf",
        "(",
        "'package.json'",
        ")",
        "!==",
        "-",
        "1",
        ")",
        "{",
        "const",
        "packageJson",
        "=",
        "await",
        "fs",
        ".",
        "readJson",
        "(",
        "path",
        ".",
        "join",
        "(",
        "directoryToSearch",
        ",",
        "'package.json'",
        ")",
        ")",
        ";",
        "return",
        "packageJson",
        ".",
        "name",
        ";",
        "}",
        "directory",
        "=",
        "path",
        ".",
        "resolve",
        "(",
        "directory",
        ",",
        "'..'",
        ")",
        ";",
        "}",
        "throw",
        "new",
        "Error",
        "(",
        "`",
        "${",
        "filepath",
        "}",
        "`",
        ")",
        ";",
        "}"
      ],
      "docstring": "Rough heuristic used to find the package name for a given file. Idea is to move upwards looking for directories that have a `package.json` file. Once we find one, we report back the name from that file.",
      "docstring_tokens": [
        "Rough",
        "heuristic",
        "used",
        "to",
        "find",
        "the",
        "package",
        "name",
        "for",
        "a",
        "given",
        "file",
        ".",
        "Idea",
        "is",
        "to",
        "move",
        "upwards",
        "looking",
        "for",
        "directories",
        "that",
        "have",
        "a",
        "package",
        ".",
        "json",
        "file",
        ".",
        "Once",
        "we",
        "find",
        "one",
        "we",
        "report",
        "back",
        "the",
        "name",
        "from",
        "that",
        "file",
        "."
      ],
      "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302",
      "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/bundler/src/commands/measure.js#L89-L107"
    },
    "target": "Rough heuristic used to find the package name for a given file . Idea is to move upwards looking for directories that have a package . json file . Once we find one we report back the name from that file .",
    "arguments": [
      [
        "async function findPackageFor ( filepath ) { let directory = filepath ; while ( directory !== '/' ) { const directoryToSearch = path . dirname ( directory ) ; const files = await fs . readdir ( directoryToSearch ) ; if ( files . indexOf ( 'package.json' ) !== - 1 ) { const packageJson = await fs . readJson ( path . join ( directoryToSearch , 'package.json' ) ) ; return packageJson . name ; } directory = path . resolve ( directory , '..' ) ; } throw new Error ( ` ${ filepath } ` ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " module. exports = { findPackageFor, } ; ```\n  3. In your main application file, import the `findPackageFor` function and use it to find the package name for a given file path. For example: ``` const { findPackageFor } = require ( './find-package-for' ) ; const filepath = '/path/to/file.js' ; const packageName = findPackageFor ( filepath ) ; console. log ( packageName ) ; ```\n  4. Run your application and pass a file path as an argument to the `findPackageFor` function. The function will return the name of the package that contains the file.\n\nNote: This implementation assumes that the `package.json` file is in the root of the package directory. If your `package.json` file is located elsewhere, you'll need to modify the `findPackageFor` function accordingly.\n\nAlso, keep in mind that this implementation has some limitations. For example, it doesn't handle cases where the file path is a symbolic link, or where the `package.json` file is not a JSON file. You may need to add additional error handling and edge cases depending on your specific use case. ```javascript\n// find-package-for.js\nconst path = require"
      ]
    ],
    "filtered_resps": [
      " module. exports = { findPackageFor, } ; ```\n  3. In your main application file, import the `findPackageFor` function and use it to find the package name for a given file path. For example: ``` const { findPackageFor } = require ( './find-package-for' ) ; const filepath = '/path/to/file.js' ; const packageName = findPackageFor ( filepath ) ; console. log ( packageName ) ; ```\n  4. Run your application and pass a file path as an argument to the `findPackageFor` function. The function will return the name of the package that contains the file.\n\nNote: This implementation assumes that the `package.json` file is in the root of the package directory. If your `package.json` file is located elsewhere, you'll need to modify the `findPackageFor` function accordingly.\n\nAlso, keep in mind that this implementation has some limitations. For example, it doesn't handle cases where the file path is a symbolic link, or where the `package.json` file is not a JSON file. You may need to add additional error handling and edge cases depending on your specific use case. ```javascript\n// find-package-for.js\nconst path = require"
    ],
    "smoothed_bleu_4": 5.0978405154122335
  },
  {
    "doc_id": 95,
    "doc": {
      "id": 95,
      "repo": "carbon-design-system/carbon-components",
      "path": "packages/components/src/globals/js/misc/svg-toggle-class.js",
      "func_name": "svgToggleClass",
      "original_string": "function svgToggleClass(svg, name, forceAdd) {\n  const list = svg\n    .getAttribute('class')\n    .trim()\n    .split(/\\s+/);\n  const uniqueList = Object.keys(list.reduce((o, item) => Object.assign(o, { [item]: 1 }), {}));\n  const index = uniqueList.indexOf(name);\n  const found = index >= 0;\n  const add = forceAdd === undefined ? !found : forceAdd;\n\n  if (found === !add) {\n    if (add) {\n      uniqueList.push(name);\n    } else {\n      uniqueList.splice(index, 1);\n    }\n    svg.setAttribute('class', uniqueList.join(' '));\n  }\n}",
      "language": "javascript",
      "code": "function svgToggleClass(svg, name, forceAdd) {\n  const list = svg\n    .getAttribute('class')\n    .trim()\n    .split(/\\s+/);\n  const uniqueList = Object.keys(list.reduce((o, item) => Object.assign(o, { [item]: 1 }), {}));\n  const index = uniqueList.indexOf(name);\n  const found = index >= 0;\n  const add = forceAdd === undefined ? !found : forceAdd;\n\n  if (found === !add) {\n    if (add) {\n      uniqueList.push(name);\n    } else {\n      uniqueList.splice(index, 1);\n    }\n    svg.setAttribute('class', uniqueList.join(' '));\n  }\n}",
      "code_tokens": [
        "function",
        "svgToggleClass",
        "(",
        "svg",
        ",",
        "name",
        ",",
        "forceAdd",
        ")",
        "{",
        "const",
        "list",
        "=",
        "svg",
        ".",
        "getAttribute",
        "(",
        "'class'",
        ")",
        ".",
        "trim",
        "(",
        ")",
        ".",
        "split",
        "(",
        "/",
        "\\s+",
        "/",
        ")",
        ";",
        "const",
        "uniqueList",
        "=",
        "Object",
        ".",
        "keys",
        "(",
        "list",
        ".",
        "reduce",
        "(",
        "(",
        "o",
        ",",
        "item",
        ")",
        "=>",
        "Object",
        ".",
        "assign",
        "(",
        "o",
        ",",
        "{",
        "[",
        "item",
        "]",
        ":",
        "1",
        "}",
        ")",
        ",",
        "{",
        "}",
        ")",
        ")",
        ";",
        "const",
        "index",
        "=",
        "uniqueList",
        ".",
        "indexOf",
        "(",
        "name",
        ")",
        ";",
        "const",
        "found",
        "=",
        "index",
        ">=",
        "0",
        ";",
        "const",
        "add",
        "=",
        "forceAdd",
        "===",
        "undefined",
        "?",
        "!",
        "found",
        ":",
        "forceAdd",
        ";",
        "if",
        "(",
        "found",
        "===",
        "!",
        "add",
        ")",
        "{",
        "if",
        "(",
        "add",
        ")",
        "{",
        "uniqueList",
        ".",
        "push",
        "(",
        "name",
        ")",
        ";",
        "}",
        "else",
        "{",
        "uniqueList",
        ".",
        "splice",
        "(",
        "index",
        ",",
        "1",
        ")",
        ";",
        "}",
        "svg",
        ".",
        "setAttribute",
        "(",
        "'class'",
        ",",
        "uniqueList",
        ".",
        "join",
        "(",
        "' '",
        ")",
        ")",
        ";",
        "}",
        "}"
      ],
      "docstring": "Copyright IBM Corp. 2016, 2018\n\nThis source code is licensed under the Apache-2.0 license found in the\nLICENSE file in the root directory of this source tree.",
      "docstring_tokens": [
        "Copyright",
        "IBM",
        "Corp",
        ".",
        "2016",
        "2018"
      ],
      "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302",
      "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/components/src/globals/js/misc/svg-toggle-class.js#L8-L26"
    },
    "target": "Copyright IBM Corp . 2016 2018",
    "arguments": [
      [
        "function svgToggleClass ( svg , name , forceAdd ) { const list = svg . getAttribute ( 'class' ) . trim ( ) . split ( / \\s+ / ) ; const uniqueList = Object . keys ( list . reduce ( ( o , item ) => Object . assign ( o , { [ item ] : 1 } ) , { } ) ) ; const index = uniqueList . indexOf ( name ) ; const found = index >= 0 ; const add = forceAdd === undefined ? ! found : forceAdd ; if ( found === ! add ) { if ( add ) { uniqueList . push ( name ) ; } else { uniqueList . splice ( index , 1 ) ; } svg . setAttribute ( 'class' , uniqueList . join ( ' ' ) ) ; } }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ``` This function takes an SVG element, a class name, and an optional `forceAdd` parameter. It first gets the current class list, splits it into an array, removes duplicates, and finds the index of the specified class name. If the class is found and `forceAdd` is `undefined` or `false`, it removes the class from the list. If the class is not found and `forceAdd` is `true`, it adds the class to the list. Finally, it updates the `class` attribute of the SVG element with the new list of classes. This function can be used to toggle a class on or off an SVG element, and can also be used to add or remove a class regardless of its current state. Example usage: ``` svgToggleClass ( svgElement,'my-class' ) ; // toggle'my-class' on or off svgToggleClass ( svgElement,'my-class', true ) ; // add'my-class' regardless of its current state svgToggleClass ( svgElement,'my-class', false ) ; // remove'my-class' regardless of its current state ``` Note that this function assumes that the SVG element has a `class` attribute. If the SVG element does"
      ]
    ],
    "filtered_resps": [
      " ``` This function takes an SVG element, a class name, and an optional `forceAdd` parameter. It first gets the current class list, splits it into an array, removes duplicates, and finds the index of the specified class name. If the class is found and `forceAdd` is `undefined` or `false`, it removes the class from the list. If the class is not found and `forceAdd` is `true`, it adds the class to the list. Finally, it updates the `class` attribute of the SVG element with the new list of classes. This function can be used to toggle a class on or off an SVG element, and can also be used to add or remove a class regardless of its current state. Example usage: ``` svgToggleClass ( svgElement,'my-class' ) ; // toggle'my-class' on or off svgToggleClass ( svgElement,'my-class', true ) ; // add'my-class' regardless of its current state svgToggleClass ( svgElement,'my-class', false ) ; // remove'my-class' regardless of its current state ``` Note that this function assumes that the SVG element has a `class` attribute. If the SVG element does"
    ],
    "smoothed_bleu_4": 0.3933157614265924
  },
  {
    "doc_id": 96,
    "doc": {
      "id": 96,
      "repo": "carbon-design-system/carbon-components",
      "path": "packages/icons/src/tools.js",
      "func_name": "flatMapAsync",
      "original_string": "async function flatMapAsync(source, mapFn) {\n  const results = await Promise.all(source.map(mapFn));\n  return results.reduce((acc, result) => acc.concat(result), []);\n}",
      "language": "javascript",
      "code": "async function flatMapAsync(source, mapFn) {\n  const results = await Promise.all(source.map(mapFn));\n  return results.reduce((acc, result) => acc.concat(result), []);\n}",
      "code_tokens": [
        "async",
        "function",
        "flatMapAsync",
        "(",
        "source",
        ",",
        "mapFn",
        ")",
        "{",
        "const",
        "results",
        "=",
        "await",
        "Promise",
        ".",
        "all",
        "(",
        "source",
        ".",
        "map",
        "(",
        "mapFn",
        ")",
        ")",
        ";",
        "return",
        "results",
        ".",
        "reduce",
        "(",
        "(",
        "acc",
        ",",
        "result",
        ")",
        "=>",
        "acc",
        ".",
        "concat",
        "(",
        "result",
        ")",
        ",",
        "[",
        "]",
        ")",
        ";",
        "}"
      ],
      "docstring": "Copyright IBM Corp. 2018, 2018\n\nThis source code is licensed under the Apache-2.0 license found in the\nLICENSE file in the root directory of this source tree.",
      "docstring_tokens": [
        "Copyright",
        "IBM",
        "Corp",
        ".",
        "2018",
        "2018"
      ],
      "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302",
      "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/icons/src/tools.js#L8-L11"
    },
    "target": "Copyright IBM Corp . 2018 2018",
    "arguments": [
      [
        "async function flatMapAsync ( source , mapFn ) { const results = await Promise . all ( source . map ( mapFn ) ) ; return results . reduce ( ( acc , result ) => acc . concat ( result ) , [ ] ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " export { flatMapAsync } ; ``` This function takes a source array and a map function as arguments. It uses `Promise.all` to wait for all the promises returned by the map function to resolve, and then uses `reduce` to flatten the resulting array of arrays into a single array. Note that this implementation assumes that the map function returns promises that resolve to arrays. If the map function returns promises that resolve to non-array values, you may need to modify the implementation accordingly. Also, this implementation does not handle errors that may occur during the execution of the map function. You may want to add error handling depending on your specific use case. ```javascript import { flatMapAsync } from './flatMapAsync.js'; const source = [ 1, 2, 3 ] ; const mapFn = async ( x ) => [ x * 2, x * 3 ] ; const result = await flatMapAsync ( source, mapFn ) ; console. log ( result ) ; // Output: [ 2, 6, 4, 12, 6, 18 ] ``` In this example, the `flatMapAsync` function is used to flatten the array of arrays returned by the `mapFn` function."
      ]
    ],
    "filtered_resps": [
      " export { flatMapAsync } ; ``` This function takes a source array and a map function as arguments. It uses `Promise.all` to wait for all the promises returned by the map function to resolve, and then uses `reduce` to flatten the resulting array of arrays into a single array. Note that this implementation assumes that the map function returns promises that resolve to arrays. If the map function returns promises that resolve to non-array values, you may need to modify the implementation accordingly. Also, this implementation does not handle errors that may occur during the execution of the map function. You may want to add error handling depending on your specific use case. ```javascript import { flatMapAsync } from './flatMapAsync.js'; const source = [ 1, 2, 3 ] ; const mapFn = async ( x ) => [ x * 2, x * 3 ] ; const result = await flatMapAsync ( source, mapFn ) ; console. log ( result ) ; // Output: [ 2, 6, 4, 12, 6, 18 ] ``` In this example, the `flatMapAsync` function is used to flatten the array of arrays returned by the `mapFn` function."
    ],
    "smoothed_bleu_4": 0.41451022298448587
  },
  {
    "doc_id": 97,
    "doc": {
      "id": 97,
      "repo": "carbon-design-system/carbon-components",
      "path": "packages/bundler/src/tools/sassdoc.js",
      "func_name": "createJson",
      "original_string": "async function createJson(sourceDir, config) {\n  config = config || {};\n\n  return sassdoc.parse(sourceDir, config).then(\n    data => {\n      return data;\n    },\n    err => {\n      console.error(err);\n    }\n  );\n}",
      "language": "javascript",
      "code": "async function createJson(sourceDir, config) {\n  config = config || {};\n\n  return sassdoc.parse(sourceDir, config).then(\n    data => {\n      return data;\n    },\n    err => {\n      console.error(err);\n    }\n  );\n}",
      "code_tokens": [
        "async",
        "function",
        "createJson",
        "(",
        "sourceDir",
        ",",
        "config",
        ")",
        "{",
        "config",
        "=",
        "config",
        "||",
        "{",
        "}",
        ";",
        "return",
        "sassdoc",
        ".",
        "parse",
        "(",
        "sourceDir",
        ",",
        "config",
        ")",
        ".",
        "then",
        "(",
        "data",
        "=>",
        "{",
        "return",
        "data",
        ";",
        "}",
        ",",
        "err",
        "=>",
        "{",
        "console",
        ".",
        "error",
        "(",
        "err",
        ")",
        ";",
        "}",
        ")",
        ";",
        "}"
      ],
      "docstring": "Create a JSON file of documented Sass items\n@see {@link http://sassdoc.com/configuration/|Sassdoc configuration}\n@param {string} sourceDir - source directory\n@param {Object} config - configuration object\n@return {Object} json object",
      "docstring_tokens": [
        "Create",
        "a",
        "JSON",
        "file",
        "of",
        "documented",
        "Sass",
        "items"
      ],
      "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302",
      "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/bundler/src/tools/sassdoc.js#L41-L52"
    },
    "target": "Create a JSON file of documented Sass items",
    "arguments": [
      [
        "async function createJson ( sourceDir , config ) { config = config || { } ; return sassdoc . parse ( sourceDir , config ) . then ( data => { return data ; } , err => { console . error ( err ) ; } ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " module. exports = { createJson, } ; ```\n  3. Install the required dependencies by running the following command in your terminal: ``` npm install sassdoc ```\n  4. Create a new file called `config.json` in the root of your project with the following content: ``` {   \"sourceDir\": \"path/to/your/sass/files\",   \"outputDir\": \"path/to/your/json/output\" } ```\n  5. Replace `\"path/to/your/sass/files\"` and `\"path/to/your/json/output\"` with the actual paths to your SASS files and the desired output directory for the JSON file.\n  6. Run the script by executing the following command in your terminal: ``` node createJson.js ```\n  7. The script will generate a JSON file in the specified output directory with the documentation for your SASS files.\n\nNote: Make sure to replace the `sourceDir` and `outputDir` paths in the `config.json` file with the actual paths to your SASS files and the desired output directory for the JSON file. Also, ensure that the `sassdoc` package is installed and available in your project's `node_modules` directory. If you encounter any issues"
      ]
    ],
    "filtered_resps": [
      " module. exports = { createJson, } ; ```\n  3. Install the required dependencies by running the following command in your terminal: ``` npm install sassdoc ```\n  4. Create a new file called `config.json` in the root of your project with the following content: ``` {   \"sourceDir\": \"path/to/your/sass/files\",   \"outputDir\": \"path/to/your/json/output\" } ```\n  5. Replace `\"path/to/your/sass/files\"` and `\"path/to/your/json/output\"` with the actual paths to your SASS files and the desired output directory for the JSON file.\n  6. Run the script by executing the following command in your terminal: ``` node createJson.js ```\n  7. The script will generate a JSON file in the specified output directory with the documentation for your SASS files.\n\nNote: Make sure to replace the `sourceDir` and `outputDir` paths in the `config.json` file with the actual paths to your SASS files and the desired output directory for the JSON file. Also, ensure that the `sassdoc` package is installed and available in your project's `node_modules` directory. If you encounter any issues"
    ],
    "smoothed_bleu_4": 1.0036839640308854
  },
  {
    "doc_id": 98,
    "doc": {
      "id": 98,
      "repo": "carbon-design-system/carbon-components",
      "path": "packages/bundler/src/tools/sassdoc.js",
      "func_name": "dedupeArray",
      "original_string": "function dedupeArray(arr) {\n  return arr.reduce(\n    (p, item) => {\n      const type = item.type || item.context.type;\n      const name = item.name || item.context.name;\n      const id = [type, name].join('|');\n\n      if (p.temp.indexOf(id) === -1) {\n        p.out.push(item);\n        p.temp.push(id);\n      }\n      return p;\n    },\n    { temp: [], out: [] }\n  ).out;\n}",
      "language": "javascript",
      "code": "function dedupeArray(arr) {\n  return arr.reduce(\n    (p, item) => {\n      const type = item.type || item.context.type;\n      const name = item.name || item.context.name;\n      const id = [type, name].join('|');\n\n      if (p.temp.indexOf(id) === -1) {\n        p.out.push(item);\n        p.temp.push(id);\n      }\n      return p;\n    },\n    { temp: [], out: [] }\n  ).out;\n}",
      "code_tokens": [
        "function",
        "dedupeArray",
        "(",
        "arr",
        ")",
        "{",
        "return",
        "arr",
        ".",
        "reduce",
        "(",
        "(",
        "p",
        ",",
        "item",
        ")",
        "=>",
        "{",
        "const",
        "type",
        "=",
        "item",
        ".",
        "type",
        "||",
        "item",
        ".",
        "context",
        ".",
        "type",
        ";",
        "const",
        "name",
        "=",
        "item",
        ".",
        "name",
        "||",
        "item",
        ".",
        "context",
        ".",
        "name",
        ";",
        "const",
        "id",
        "=",
        "[",
        "type",
        ",",
        "name",
        "]",
        ".",
        "join",
        "(",
        "'|'",
        ")",
        ";",
        "if",
        "(",
        "p",
        ".",
        "temp",
        ".",
        "indexOf",
        "(",
        "id",
        ")",
        "===",
        "-",
        "1",
        ")",
        "{",
        "p",
        ".",
        "out",
        ".",
        "push",
        "(",
        "item",
        ")",
        ";",
        "p",
        ".",
        "temp",
        ".",
        "push",
        "(",
        "id",
        ")",
        ";",
        "}",
        "return",
        "p",
        ";",
        "}",
        ",",
        "{",
        "temp",
        ":",
        "[",
        "]",
        ",",
        "out",
        ":",
        "[",
        "]",
        "}",
        ")",
        ".",
        "out",
        ";",
        "}"
      ],
      "docstring": "Remove duplicate objects in `require` and `usedBy` arrays. Array objects have\n`name` and `type` properties, sometimes nested in a `context` object.\n@param {Array} arr - array with potential duplicates\n@return {Array} deduped array",
      "docstring_tokens": [
        "Remove",
        "duplicate",
        "objects",
        "in",
        "require",
        "and",
        "usedBy",
        "arrays",
        ".",
        "Array",
        "objects",
        "have",
        "name",
        "and",
        "type",
        "properties",
        "sometimes",
        "nested",
        "in",
        "a",
        "context",
        "object",
        "."
      ],
      "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302",
      "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/bundler/src/tools/sassdoc.js#L60-L75"
    },
    "target": "Remove duplicate objects in require and usedBy arrays . Array objects have name and type properties sometimes nested in a context object .",
    "arguments": [
      [
        "function dedupeArray ( arr ) { return arr . reduce ( ( p , item ) => { const type = item . type || item . context . type ; const name = item . name || item . context . name ; const id = [ type , name ] . join ( '|' ) ; if ( p . temp . indexOf ( id ) === - 1 ) { p . out . push ( item ) ; p . temp . push ( id ) ; } return p ; } , { temp : [ ] , out : [ ] } ) . out ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " ``` This function takes an array of objects as input and returns a new array with duplicates removed. It uses the `reduce` method to iterate over the array, and for each item, it checks if the combination of `type` and `name` (or `context.type` and `context.name` if they exist) is already in the `temp` array. If it's not, it adds the item to the `out` array and the combination to the `temp` array. The `reduce` method returns an object with `temp` and `out` properties, and we return the `out` array. This function assumes that the input array contains objects with `type` and `name` (or `context.type` and `context.name`) properties, and that the `type` and `name` values are strings. If the input array contains objects with different properties or values, the function may not work as expected. You can use this function like this: ``` const arr = [ { type : 'A', name : 'X' }, { type : 'B', name : 'Y' }, { type : 'A', name : 'X' }, { type : 'C"
      ]
    ],
    "filtered_resps": [
      " ``` This function takes an array of objects as input and returns a new array with duplicates removed. It uses the `reduce` method to iterate over the array, and for each item, it checks if the combination of `type` and `name` (or `context.type` and `context.name` if they exist) is already in the `temp` array. If it's not, it adds the item to the `out` array and the combination to the `temp` array. The `reduce` method returns an object with `temp` and `out` properties, and we return the `out` array. This function assumes that the input array contains objects with `type` and `name` (or `context.type` and `context.name`) properties, and that the `type` and `name` values are strings. If the input array contains objects with different properties or values, the function may not work as expected. You can use this function like this: ``` const arr = [ { type : 'A', name : 'X' }, { type : 'B', name : 'Y' }, { type : 'A', name : 'X' }, { type : 'C"
    ],
    "smoothed_bleu_4": 0.746131658241917
  },
  {
    "doc_id": 99,
    "doc": {
      "id": 99,
      "repo": "carbon-design-system/carbon-components",
      "path": "packages/bundler/src/tools/sassdoc.js",
      "func_name": "createMarkdown",
      "original_string": "async function createMarkdown(sourceDir, config) {\n  config = config || {};\n\n  return sassdoc.parse(sourceDir, config).then(\n    data => {\n      let markdownFile = '';\n\n      const documentedItems = data.filter(\n        (item, index) => item.access === 'public' || item.access === 'private'\n      );\n\n      markdownFile += `# Sass API\n\n| Mark | Description |\n| --- | --- |\n| \u2705 | Public functions, mixins, placeholders, and variables |\n| \u274c | Private items - not supported outside package's build |\n| \u26a0\ufe0f | Deprecated items - may not be available in future releases |\n\n<!-- toc -->\n<!-- tocstop -->`;\n\n      let currentGroup = '';\n\n      documentedItems.forEach(item => {\n        const itemGroup = createGroupName(item.group);\n\n        if (itemGroup !== currentGroup) {\n          markdownFile += `\\n\\n## ${itemGroup}`;\n          currentGroup = itemGroup;\n        }\n\n        markdownFile += createMarkdownItem(item);\n      });\n\n      return prettier.format(\n        toc.insert(markdownFile, { slugify }),\n        prettierOptions\n      );\n    },\n    err => {\n      console.error(err);\n    }\n  );\n}",
      "language": "javascript",
      "code": "async function createMarkdown(sourceDir, config) {\n  config = config || {};\n\n  return sassdoc.parse(sourceDir, config).then(\n    data => {\n      let markdownFile = '';\n\n      const documentedItems = data.filter(\n        (item, index) => item.access === 'public' || item.access === 'private'\n      );\n\n      markdownFile += `# Sass API\n\n| Mark | Description |\n| --- | --- |\n| \u2705 | Public functions, mixins, placeholders, and variables |\n| \u274c | Private items - not supported outside package's build |\n| \u26a0\ufe0f | Deprecated items - may not be available in future releases |\n\n<!-- toc -->\n<!-- tocstop -->`;\n\n      let currentGroup = '';\n\n      documentedItems.forEach(item => {\n        const itemGroup = createGroupName(item.group);\n\n        if (itemGroup !== currentGroup) {\n          markdownFile += `\\n\\n## ${itemGroup}`;\n          currentGroup = itemGroup;\n        }\n\n        markdownFile += createMarkdownItem(item);\n      });\n\n      return prettier.format(\n        toc.insert(markdownFile, { slugify }),\n        prettierOptions\n      );\n    },\n    err => {\n      console.error(err);\n    }\n  );\n}",
      "code_tokens": [
        "async",
        "function",
        "createMarkdown",
        "(",
        "sourceDir",
        ",",
        "config",
        ")",
        "{",
        "config",
        "=",
        "config",
        "||",
        "{",
        "}",
        ";",
        "return",
        "sassdoc",
        ".",
        "parse",
        "(",
        "sourceDir",
        ",",
        "config",
        ")",
        ".",
        "then",
        "(",
        "data",
        "=>",
        "{",
        "let",
        "markdownFile",
        "=",
        "''",
        ";",
        "const",
        "documentedItems",
        "=",
        "data",
        ".",
        "filter",
        "(",
        "(",
        "item",
        ",",
        "index",
        ")",
        "=>",
        "item",
        ".",
        "access",
        "===",
        "'public'",
        "||",
        "item",
        ".",
        "access",
        "===",
        "'private'",
        ")",
        ";",
        "markdownFile",
        "+=",
        "`",
        "`",
        ";",
        "let",
        "currentGroup",
        "=",
        "''",
        ";",
        "documentedItems",
        ".",
        "forEach",
        "(",
        "item",
        "=>",
        "{",
        "const",
        "itemGroup",
        "=",
        "createGroupName",
        "(",
        "item",
        ".",
        "group",
        ")",
        ";",
        "if",
        "(",
        "itemGroup",
        "!==",
        "currentGroup",
        ")",
        "{",
        "markdownFile",
        "+=",
        "`",
        "\\n",
        "\\n",
        "${",
        "itemGroup",
        "}",
        "`",
        ";",
        "currentGroup",
        "=",
        "itemGroup",
        ";",
        "}",
        "markdownFile",
        "+=",
        "createMarkdownItem",
        "(",
        "item",
        ")",
        ";",
        "}",
        ")",
        ";",
        "return",
        "prettier",
        ".",
        "format",
        "(",
        "toc",
        ".",
        "insert",
        "(",
        "markdownFile",
        ",",
        "{",
        "slugify",
        "}",
        ")",
        ",",
        "prettierOptions",
        ")",
        ";",
        "}",
        ",",
        "err",
        "=>",
        "{",
        "console",
        ".",
        "error",
        "(",
        "err",
        ")",
        ";",
        "}",
        ")",
        ";",
        "}"
      ],
      "docstring": "Create a markdown file of documented Sass items\n@see {@link http://sassdoc.com/configuration/|Sassdoc configuration}\n@param {string} sourceDir - source directory\n@param {Object} config - configuration object\n@return {string} markdown",
      "docstring_tokens": [
        "Create",
        "a",
        "markdown",
        "file",
        "of",
        "documented",
        "Sass",
        "items"
      ],
      "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302",
      "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/bundler/src/tools/sassdoc.js#L347-L391"
    },
    "target": "Create a markdown file of documented Sass items",
    "arguments": [
      [
        "async function createMarkdown ( sourceDir , config ) { config = config || { } ; return sassdoc . parse ( sourceDir , config ) . then ( data => { let markdownFile = '' ; const documentedItems = data . filter ( ( item , index ) => item . access === 'public' || item . access === 'private' ) ; markdownFile += ` ` ; let currentGroup = '' ; documentedItems . forEach ( item => { const itemGroup = createGroupName ( item . group ) ; if ( itemGroup !== currentGroup ) { markdownFile += ` \\n \\n ${ itemGroup } ` ; currentGroup = itemGroup ; } markdownFile += createMarkdownItem ( item ) ; } ) ; return prettier . format ( toc . insert ( markdownFile , { slugify } ) , prettierOptions ) ; } , err => { console . error ( err ) ; } ) ; }",
        {
          "num_beams": 2,
          "max_length": 128,
          "until": [
            "</s>"
          ],
          "do_sample": false,
          "temperature": 1.0,
          "top_p": 1.0,
          "top_k": 0,
          "max_new_tokens": 250
        }
      ]
    ],
    "resps": [
      [
        " function createGroupName ( group ) { return group? ` ${ group } ` : '' ; } function createMarkdownItem ( item ) { return ` \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\"
      ]
    ],
    "filtered_resps": [
      " function createGroupName ( group ) { return group? ` ${ group } ` : '' ; } function createMarkdownItem ( item ) { return ` \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\"
    ],
    "smoothed_bleu_4": 4.919820703819271e-78
  }
]